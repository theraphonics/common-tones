<!DOCTYPE html>

<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>CLM</title>
<style type="text/css">
	EM.red {color: red; font-style: normal}
	EM.gen {font-weight: bold; font-style: normal}
        EM.tab {font-style: normal; font-size: small}
	EM.emdef {font-weight: bold; font-style: normal}
	H1 {text-align: center}
	UL {list-style-type: none}

	A {text-decoration:none}
	A:hover {text-decoration:underline}
	A.quiet {color:black; text-decoration:none}
	A.quiet:hover {text-decoration:underline}
	A.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
	A.olddef {font-style: normal; text-decoration:none; color:gray}
	EM.gray {color:gray; font-style: normal}
	EM.def {font-weight: bold; font-style: normal; text-decoration:none; text-color:black}
	EM.noem {font-style: normal}

        TABLE.borderspaced {margin-top: 0.5cm;
	              margin-bottom: 0.5cm;
		      margin-left: 0.5cm;
		      border: 8px solid gray;
		      }	
	TH.beige {background-color: beige;
	          border: 1px solid black;
		  padding-left: 0.2cm;
		  padding-right: 0.2cm;
		  padding-top: 0.1cm;
		  padding-bottom: 0.1cm;
		  }
	TD.br {border: 1px solid lightgray;
		  padding-left: 0.2cm;
		  padding-right: 0.2cm;
		  padding-top: 0.1cm;
		  padding-bottom: 0.1cm;
	       }
        TD.green {background-color: lightgreen}
	TD.bluish {background-color: #f2f4ff;
                  padding-right: 1.0cm;
		  padding-top: 0.1cm;
		  }
        TD.greenish {background-color: #eefdee}

        PRE.indented {padding-left: 1.0cm;
	             }

        TABLE.b4 {border: 4px solid lightgray;
	         /* padding-left: 0.5cm; */
		  padding-right: 0.5cm;	
		  padding-top: 0.5cm;	
		  padding-bottom: 0.5cm;
		  margin-top: 0.5cm;
		  margin-bottom: 0.5cm;	
		  margin-left: 1.0cm;
                 }	    
        TABLE.b1 {/* border: 1px solid black; */
	          padding-left: 1.0cm;
		  /* padding-right: 0.1cm;	*/
		  /*  padding-top: 0.1cm;	*/
		  /* padding-bottom: 0.1cm;	*/
                 }
        TABLE.spaced {margin-top: 0.5cm;
	              margin-bottom: 0.5cm;
		      margin-left: 0.5cm;
		      }		 
        TABLE.method {margin-top: 0.2cm;
                      margin-bottom: 0.2cm;
		      margin-left: 1.0cm;
		      border: 1px solid gray;
		      padding-left: 0.1cm;
		      padding-right: 0.1cm;
		      padding-top: 0.1cm;
		      padding-bottom: 0.1cm;
		      }	    
        TD.title {background-color: beige;
		  border: 1px solid gray;
		  padding-top: 0.2cm;	
		  padding-bottom: 0.2cm;
		  text-align: center;
		  }
        TD.inner {padding-right: 0.5cm;
	          padding-top: 0.1cm;
	         }
	DIV.center {text-align: center}
        BODY.body {background-color: #ffffff;    /* white */
	           margin-left: 0.5cm; 
                   }
        DIV.centered1 {padding-left: 35%;
	               padding-bottom: 0.5cm;
		       }
        DIV.topheader {margin-top: 10px;
	            margin-bottom: 40px;
	            border: 4px solid #00ff00; /* green */
		    background-color: #f5f5dc; /* beige */
		    font-family: 'Helvetica';
		    font-size: 30px;
		    text-align: center;
		    padding-top: 10px;
		    padding-bottom: 10px;
	           }
        DIV.header {margin-top: 50px;
	            margin-bottom: 10px;
		    font-size: 20px;
		    font-weight: bold;
	            border: 4px solid #00ff00; /* green */
		    background-color: #f5f5dc; /* beige */
		    text-align: center;
		    padding-top: 20px;
		    padding-bottom: 20px;
	           }
        DIV.innerheader {margin-top: 60px;
	            margin-bottom: 30px;
	            border: 4px solid #00ff00; /* green */
		    background-color: #eefdee; /* lightgreen */
		    padding-left: 30px;
		    width: 50%;
		    padding-top: 20px;
		    padding-bottom: 20px;
	           }
	DIV.related {text-align:center;
	             border: 1px solid lightgray;
		     margin-bottom: 1.0cm;
		     margin-top: 1.0cm;
		     padding-top: 10px;
		     padding-bottom: 10px;
		     background-color: #f0f0f0;
	            }
</style>
</head>


<body class="body">

<div class="topheader">CLM</div>

<p>CLM (originally an acronym for Common Lisp Music) is a sound synthesis
package in the Music V family.  It provides much the same functionality as
Stk, Csound, SuperCollider, PD, CMix, cmusic, and Arctic &mdash; a collection of functions
that create and manipulate sounds, aimed primarily at composers (in CLM's
case anyway).  The instrument builder plugs together these functions
(called generators here), along with general programming glue to
make computer instruments.  These are then called in a note list
or through some user interface (provided by Snd, for example).
</p>

<p>
CLM exists in several forms: 
the original Common Lisp implementation (clm-5.tar.gz), 
a C version (sndlib.tar.gz), 
a Scheme version (sndlib.tar.gz with s7), Ruby (sndlib again but using Ruby),
and Forth (sndlib).  The Scheme, Ruby, and Forth versions are also built into
the Snd editor (snd-17.tar.gz).
This document is aimed at the Common Lisp version in clm-5.tar.gz.  See sndclm.html
in the Snd tarball for the Scheme/Ruby/Forth/C version (sndclm.html has much more
information than this file).
There are a variety of unavoidable differences between these
versions, but in general, the differences are obvious and consistent: Lisp "-" becomes
C "_", "?" becomes "_p", "-&gt;" becomes "_to_", and so on, so the function
named mus_oscil in C, becomes oscil elsewhere, mus_oscil_p becomes oscil?,
and mus_hz_to_radians becomes hz-&gt;radians in Lisp/Scheme. 
If you'd like to compare
a standard instrument in the various implementations, check out the
fm-violin: v.ins (Common Lisp), v.scm (Scheme), v.rb (Ruby), clm-ins.fs (Forth),
and sndlib.html (C). 
</p>

<p>CLM has several sections: <a href="#generators">"generators"</a>, instruments
(<a href="#definstrument">definstrument</a> and *.ins), examples of note lists
(<a href="#with-sound">with-sound</a>, *.clm), a "make" facility for sound files (<a href="#with-mix">with-mix</a>), 
and various functions that are useful in sound file work.
CLM is available free: (<a href="clm-5.tar.gz">clm-5.tar.gz</a>
<a href="https://ccrma.stanford.edu/software/clm/clm-5.tar.gz">clm tarball</a>).
</p>

<div class="centered1">Bill Schottstaedt (bil@ccrma.stanford.edu)</div>

<div class="related">
related documentation: &nbsp;
<a href="snd.html">snd.html &nbsp;</a>
<a href="extsnd.html">extsnd.html &nbsp;</a>
<a href="grfsnd.html">grfsnd.html &nbsp;</a>
<a href="sndscm.html">sndscm.html &nbsp;</a>
<a href="sndclm.html">sndclm.html &nbsp;</a>
<a href="sndlib.html">sndlib.html &nbsp;</a>
<a href="cl-fm.html">cl-fm.html &nbsp;</a>
</div>


<div class="header">Contents</div>

<ul>
<li><a href="#introduction">Introduction</a>
<li><a href="#instruments">Instruments</a>
<ul>
<li><small><a href="#generators">Generators</a></small>
<li><small><a href="#generic-functions">Generic Functions</a></small>
<li><small><a href="#soundio">Sound file IO</a></small>
<li><small><a href="#functions">Useful functions</a></small>
<li><small><a href="#def-clm-struct">def-clm-struct</a></small>
<li><small><a href="#definstrument">Definstrument</a></small>
</ul>
<li><a href="#note-lists">Note Lists</a>
<ul>
<li><small><a href="#with-sound">With-sound</a></small>
<li><small><a href="#mix-and-with-mix">With-mix</a></small>
<li><small><a href="#sound-let">Sound-let</a></small>
</ul>
<li><a href="#debugging-aids">Debugging</a>
<li><a href="#appendices">Appendices</a>
<ul>
<li><small><a href="#header-types">Header and data types supported in CLM</a></small>
<li><small><a href="#clm-init.lisp">Example of clm-init.lisp</a></small>
<li><small><a href="#savedimages">About CLM in saved images</a></small>
</ul>
</ul>



<div class="header" id="introduction">Introduction</div>

<p>CLM provides functions to experiment with sounds.
The easiest way to make a new sound is 
<a href="#with-sound">with-sound</a>.  Say we want to hear one second of the fm violin (in <a href="v.ins">v.ins</a>,
named fm-violin) at 440 Hz, and a somewhat soft amplitude.  Compile v.ins and load v, then call with-sound:</p>

<pre class="indented">
(compile-file "v.ins")
(load "v")
(<a class=quiet href="#with-sound">with-sound</a> () (fm-violin 0 1 440 .1)) 
</pre>

<p>and the note should emerge from the speakers.  (In CMU-CL, load v.cmucl, not v.x86f). The compile and load sequence can be abbreviated
in most lisps. 
Once loaded, we don't
need to reload v unless we change it in some way.  
To get an arpeggio:</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> ()
  (loop for i from 0 to 7 do
    (fm-violin (* i .25) .5 (* 100 (1+ i)) .1))) 
</pre>

<p><a href="clm-example.lisp">clm-example.lisp</a> shows how to create such a note list algorithmically.
To listen to the last computed sound again:
</p>

<pre class="indented">
(play)
</pre>

<p>or, if you have some saved sound file:
</p>

<pre class="indented">
(<a class=quiet href="#dac">play</a> "a-great.snd")
</pre>

<p>Although you can use CLM simply as a bunch of canned functions, it's a lot more
fun to make your own.  In CLM, these are called instruments, and a sequence of
instrumental calls is a note list.  
To create your own instrument, you need to write the function that expresses
in CLM's terms the sound processing actions you want.
In the simplest case, you can just calculate your new
value, and add it into the current output:</p>

<pre class="indented">
(definstrument simp (start-time duration frequency amplitude)
  (let* ((beg (floor (* start-time *srate*)))
	 (end (+ beg (floor (* duration *srate*))))
	 (j 0))
    (run
      (loop for i from beg below end do
        (<a class=quiet href="#outa">outa</a> i (* amplitude (sin (* j 2.0 pi (/ frequency *srate*)))))
	(incf j)))))
</pre>

<p>Now to hear our sine wave, place this code in a file, say simp.ins, compile and load it, then:</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> () (simp 0 0.25 440.0 0.2))
</pre>

<p>This creates a sine-wave at 440.0 Hz, 0.2 amplitude, between times 0 and
0.25 seconds.  The line:</p>

<pre class="indented">
(definstrument simp (start-time duration frequency amplitude) <!-- ) -->
</pre>

<p>says that we are defining an instrument (via definstrument) named simp which
takes the four parameters start-time, duration, frequency, and amplitude.
The next two lines:</p>

<pre class="indented">
(let* ((beg (floor (* start-time *srate*)))
       (end (+ beg (floor (* duration *srate*))))) <!-- ) -->
</pre>

<p>turn the start-time and duration values, passed by the caller in
terms of seconds, into samples.  The variable *srate*
holds the current sampling rate.
The "run" macro is an optimizer;
it turns its body into a C foreign function call.
The next
line:</p>

<pre class="indented">
(loop for i from beg below end and j from 0 by 1 do <!-- ) -->
</pre>

<p>uses the Lisp loop construct to loop through the samples
between the start time in samples (beg) and the end point (end) calculating
simp's output on each sample.  We are also using the variable j
to increment the current phase in the last line:</p>

<pre class="indented">
(<a class=quiet href="#outa">outa</a> i (* amplitude (sin (* j 2.0 pi (/ frequency *srate*)))))))) <!-- ((( -->
</pre>

<p>This is the heart of our instrument.  The call (<a href="#outa">outa</a> i ...)
adds its third argument (in this case a complicated expression) into channel 0 of the
current output stream at sample i.  The expression:</p>

<pre class="indented">
(* amplitude (sin (* j 2.0 pi (/ frequency *srate*)))))))) <!-- (((( -->
</pre>

<p>is creating a sinusoid (via the "sin" function) at the specified
volume ("amplitude" is passed as an argument to simp), and the
desired frequency ("frequency" is also an argument to simp).  The
caller passes simp a frequency in cycles per second (440.0 for
example), but we need to turn that into the corresponding phase
value for the "sin" function.  We do that by translating from
cycles per second to radians per sample by multiplying by two pi
(this multiply gives us radians
per second), then dividing by the sampling rate (samples per
second) to give us radians per sample (i.e. radians/second
divided by samples/second gives radians/sample); we then multiply
by "j" to step forward on each sample. 
Finally, the line:</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> () (simp 0 0.25 440.0 0.2))
</pre>

<p>opens an output sound file, calls simp, closes the file, and
plays the result.  
We need to put the instrument definition in a separate file
and compile and load it; we can't just paste it into the listener (this limitation applies only to the Common Lisp CLM).
</p>

<p>We can simplify simp by using <b>oscil</b> for the sinusoid and
<b>hz-&gt;radians</b>.  <b>make-oscil</b> creates an oscil generator;
similarly <b>make-env</b> creates an envelope generator:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> simp (start-time duration frequency amplitude &amp;optional (amp-env '(0 0 .5 1.0 1.0 0)))
  (multiple-value-bind (beg end) (<a class=quiet href="#timestosamples">times-&gt;samples</a> start-time duration)
    (let ((osc (<a class=quiet href="#make-oscil">make-oscil</a> :frequency frequency))
	  (amp-env (<a class=quiet href="#make-env">make-env</a> amp-env :scaler amplitude :duration duration)))
      (run 
       (loop for i from beg below end do
	 (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> amp-env) (<a class=quiet href="#oscil">oscil</a> osc))))))))
</pre>

<p>Our envelope is a list of (x y) break-point pairs.  The
x-axis bounds are arbitrary, but it is conventional (here at ccrma) to
go from 0 to 1.0.  The y-axis values are normally between -1.0 and
1.0, to make it easier to figure out how to apply the envelope in
various different situations.  In this case, our envelope is a ramp up
to the middle of the note: "(0.0 0.0 0.5 1.0)", then a ramp down to 0. 
The <a href="#env">env</a> generator produces the envelope on a sample-by-sample
basis.
</p>

<p>If you make a change to an instrument, just recompile and reload it to
use the changed version; there's no need to restart lisp, or unload the old version (in most
lisps there's actually no way to unload it).
</p>


<div class="header" id="instruments">Instruments</div>

<p>The normal structure of an instrument is:</p>

<pre class="indented">
(definstrument name (args) (setup code (run run-time code)))
</pre>

<p>The setup code creates any needed generators for the
run-time code which actually generates the samples.
The run-time code can contain any of the lisp functions (generators etc)
described in the next several sections.  Since life is short,
not every feature of lisp is supported by the <em class=def id="run">run</em> macro; 
I've concentrated on those that have been useful in the past, so let me know
if you need something new!
</p>

<em class=def id="lisp-functions"></em>
<!-- INDEX lisp-functions:Run support for Lisp -->
<p>Lisp functions that can occur within the body of the run macro:</p>

<pre class="indented">
+  /  *  -  1+  1-  incf decf setf setq
 =  /=  &lt;  &gt;  &lt;=  &gt;=  zerop plusp  
minusp oddp evenp max min abs mod rem identity
floor ceiling round truncate signum sqrt random float
ash log expt exp sin cos tan asin acos atan cosh sinh tanh asinh acosh atanh
erf erfc lgamma bes-j0 bes-j1 bes-jn bes-y0 bes-y1 bes-yn bes-i0
or and not null if unless when cond progn prog1 prog2 case tagbody go 
error warn print princ terpri probe-file
block return return-from let let* loop do do* dotimes declare
lambda apply loop-finish
aref elt svref array-total-size array-in-bounds-p array-rank array-dimension
integerp numberp floatp realp eq eql arrayp
</pre>

<p>The function <em class=def id="clm-print">clm-print</em> stands in for Lisp's
format &mdash; I don't support all of format's
options, but enough to be useful, I hope.  clm-print's syntax is (clm-print
format-string &amp;rest args). It is also possible to write to a file:
</p>

<pre class="indented">
(definstrument fileit ()
  (let ((file (c-open-output-file "test.clm-data")))
    (run
     (loop for i from 0 to 10 do
       (clm-print file "hiho ~D " i)))
    (c-close file)))
</pre>

<p>
Loop is expanded as a macro and anything in
the loop syntax is ok if it expands into something else mentioned above (i.e. a
lambda form with go's and so forth). 
</p>

<p>
Declare can be used to set the variable types and debugging options.
Since the run macro can't always tell what type a variable is, it will
generate run-time code to figure out the type.  The generated code will
be faster and tighter (and a lot easier to read) if you use declare to
tell run what the types are.
In Common Lisp, the recognized types are :integer, :float, :string, :boolean, :bignum (sample number),
:double*, :int*, :mus-any, and :mus-any* (the keyword package
is used to avoid endless CL package name troubles).
</p>


<!-- INDEX generators:Generators -->

<div class="header" id="generators">Generators</div>


<table class="b4">
<tr><td>
<table class="b1">
  <tr><td><a href="#all-pass">all-pass</a></td><td>all-pass filter</td></tr>
  <tr><td><a href="#asymmetric-fm">asymmetric-fm</a></td><td>asymmetric fm</td></tr>
  <tr><td><a href="#comb">comb</a></td><td>comb filter</td></tr>
  <tr><td><a href="#convolve">convolve</a></td><td>convolution</td></tr>
  <tr><td><a href="#delay">delay</a></td><td>delay line</td></tr>
  <tr><td><a href="#env">env</a></td><td>line segment envelope</td></tr>
  <tr><td><a href="#filter">filter</a></td><td>direct form FIR/IIR filter</td></tr>
  <tr><td><a href="#filtered-comb">filtered-comb</a></td><td>comb filter with filter on feedback</td></tr>
  <tr><td><a href="#fir-filter">fir-filter</a></td><td>FIR filter</td></tr>
  <tr><td><a href="#formant">formant</a></td><td>resonance</td></tr>
  <tr><td><a href="#granulate">granulate</a></td><td>granular synthesis</td></tr>
  <tr><td><a href="#iir-filter">iir-filter</a></td><td>IIR filter</td></tr>
  <tr><td><a href="#in-any">in-any</a></td><td>sound file input</td></tr>
  <tr><td><a href="#locsig">locsig</a></td><td>static sound placement</td></tr>
  <tr><td><a href="#move-sound">move-sound</a></td><td>sound motion</td></tr>
  <tr><td><a href="#moving-average">moving-average</a></td><td>moving window average</td></tr>
  <tr><td><a href="#ncos">ncos</a></td><td>sum of equal amplitude cosines</td></tr>
  <tr><td><a href="#notch">notch</a></td><td>notch filter</td></tr>
  <tr><td><a href="#nsin">nsin</a></td><td>sum of equal amplitude sines</td></tr>
  <tr><td><a href="#nrxycos">nrxycos</a></td><td>sum of n scaled cosines</td></tr>
  <tr><td><a href="#nrxysin">nrxysin</a></td><td>sum of n scaled sines</td></tr>
</table>
</td><td>
<table class="b1">
  <tr><td><a href="#one-pole">one-pole</a></td><td>one pole filter</td></tr>
  <tr><td><a href="#one-zero">one-zero</a></td><td>one zero filter</td></tr>
  <tr><td><a href="#oscil">oscil</a></td><td>sine wave and FM</td></tr>
  <tr><td><a href="#out-any">out-any</a></td><td>sound output</td></tr>
  <tr><td><a href="#polyshape">polywave and polyshape</a></td><td>waveshaping</td></tr>
  <tr><td><a href="#phase-vocoder">phase-vocoder</a></td><td>vocoder analysis and resynthesis</td></tr>
  <tr><td><a href="#pulse-train">pulse-train</a></td><td>pulse train</td></tr>
  <tr><td><a href="#rand">rand,rand-interp</a></td><td>random numbers, noise</td></tr>
  <tr><td><a href="#readin">readin</a></td><td>sound input</td></tr>
  <tr><td><a href="#sawtooth-wave">sawtooth-wave</a></td><td>sawtooth</td></tr>
  <tr><td><a href="#square-wave">square-wave</a></td><td>square wave</td></tr>
  <tr><td><a href="#src">src</a></td><td>sampling rate conversion</td></tr>
  <tr><td><a href="#ssb-am">ssb-am</a></td><td>single sideband amplitude modulation</td></tr>
  <tr><td><a href="#table-lookup">table-lookup</a></td><td>interpolated table lookup</td></tr>
  <tr><td><a href="#tap">tap</a></td><td>delay line tap</td></tr>
  <tr><td><a href="#triangle-wave">triangle-wave</a></td><td>triangle wave</td></tr>
  <tr><td><a href="#two-pole">two-pole</a></td><td>two pole filter</td></tr>
  <tr><td><a href="#two-zero">two-zero</a></td><td>two zero filter</td></tr>
  <tr><td><a href="#wave-train">wave-train</a></td><td>wave train</td></tr>
</table>
</td></tr>
</table>



<p>A generator is a function that returns the next sample in an infinite stream of samples
each time it is called.  An oscillator, for example, returns an endless sine wave, one sample
at a time.  
Each generator consists of a set of functions:  Make-&lt;gen&gt; sets up the
data structure associated with the generator at initialization time;
&lt;gen&gt; produces a new sample;
&lt;gen&gt;? checks whether a variable is that kind of generator.
Internal fields are accessible via various generic functions such as mus-frequency.
</p>

<pre class="indented">
(setf oscillator (<a class=quiet href="#make-oscil">make-oscil</a> :frequency 330))
</pre>

<p>prepares oscillator to produce a sine wave
when set in motion via</p>

<pre class="indented">
(<a class=quiet href="#oscil">oscil</a> oscillator)
</pre>

<p>(<a class=quiet href="#oscil?">oscil?</a> oscillator) returns t, and (<a class=quiet href="#mus-frequency">mus-frequency</a> oscillator) returns 330.
The initialization function (make-oscil above)
normally takes a number of optional arguments, setting whatever choices need to be made to specify the
generator's behavior.  The run-time function (oscil above) always takes the generator as its first argument.
Its second argument is nearly always
something like an FM input; in a few cases, it is a function to provide input data or editing operations.
Frequency sweeps of all kinds (vibrato, glissando, breath
noise, FM proper) are all forms of run-time frequency modulation.  So, in
normal usage, our oscillator looks something like:</p>

<pre class="indented">
(<a class=quiet href="#oscil">oscil</a> oscillator (+ vibrato glissando frequency-modulation))
</pre>

<p>
Frequencies are always in cycles per
second (also known as Hz).  The
FM (or frequency change) argument is assumed to be a phase change in radians,
applied on each sample.  Normally composers would rather think in terms of
Hz, so the function <a href="#hztoradians">hz-&gt;radians</a> can be used to convert from units of cycles
per second to radians per sample.
</p>

<p>Finally, one special aspect of the make-&lt;gen&gt; functions is the way they
read their arguments.  I use the word <em class=def id="optional-key">optional-key</em>
in the function definitions in this document to indicate that the arguments are
keywords, but the keywords themselves are optional.
Take the make-oscil call, defined as:</p>

<pre class="indented">
make-oscil &amp;optional-key (frequency 0.0) (initial-phase 0.0)
</pre>

<p>When make-oscil is called, it scans its arguments; if a keyword is seen, that
argument and all following arguments are passed unchanged, but if a value is
seen, the corresponding keyword is prepended in the argument list:
</p>

<pre class="indented">
(<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0)
(<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0 :initial-phase 0.0)
(<a class=quiet href="#make-oscil">make-oscil</a> 440.0)
(<a class=quiet href="#make-oscil">make-oscil</a>)
(<a class=quiet href="#make-oscil">make-oscil</a> 440.0 :initial-phase 0.0)
(<a class=quiet href="#make-oscil">make-oscil</a> 440.0 0.0)
</pre>

<p>are all equivalent, but</p>

<pre class="indented">
(<a class=quiet href="#make-oscil">make-oscil</a> :frequency 440.0 0.0)
(<a class=quiet href="#make-oscil">make-oscil</a> :initial-phase 0.0 440.0)
</pre>

<p>are in error, because once we see any keyword, all the rest of the arguments have
to use keywords too (we can't reliably make any assumptions after that point about argument
ordering).  If this is confusing, just use the keywords all the time.  I implemented this somewhat
unusual argument interpretation because
in many cases it is silly to insist on the keyword; for example, in make-env,
the envelope argument is obvious and can't be confused with any other argument, so
it's an annoyance to have to say ":envelope" over and over.  Keyword arguments are also
useful when there are so many arguments to a function that it becomes impossible to
remember what they are and what order they come in.
</p>



<!--  OSCIL  -->

<div class="innerheader">oscil</div>

<pre class="indented">
<em class=def id="make-oscil">make-oscil</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (initial-phase 0.0)
<em class=def id="oscil">oscil</em> os &amp;optional (fm-input 0.0) (pm-input 0.0)
<em class=def id="oscil?">oscil?</em> os
</pre>

<p><b>oscil</b> produces a sine wave (using sin) with optional frequency change (i.e. FM).
Its first argument is an oscil created by <b>make-oscil</b>.
Oscil's second (optional) argument is the current (sample-wise)
frequency change.  The optional third argument is the (sample-wise)
phase change (in addition to the carrier increment and so on).  
So the second argument can be viewed as FM, while the third is PM (phase modulation).
The initial-phase argument to make-oscil is in radians. You can
use <b>degrees-&gt;radians</b> to convert from degrees to radians.
To get a cosine (as opposed to sin), set the initial-phase to (/ pi 2):
<code>(make-oscil 440.0 (/ pi 2)) </code>.
</p>

<table class="method">
<tr><td colspan=2 class="title">oscil methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td> <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>     <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>    <td class="inner">1 (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td> <td class="inner">frequency in radians per sample</td></tr>
</table>

<p>Oscil might be defined:
</p>
<pre class="indented">
  (prog1
    (sin (+ phase pm-input))
    (incf phase (+ (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) fm-input)))
</pre>

<p><b>oscil</b> takes both FM and PM arguments; here is an example of FM:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> simple-fm (beg dur freq amp mc-ratio index &amp;optional amp-env index-env)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (cr (<em class=red>make-oscil</em> freq))                     ; our carrier
         (md (<em class=red>make-oscil</em> (* freq mc-ratio)))        ; our modulator
         (fm-index (<a class=quiet href="#hztoradians">hz-&gt;radians</a> (* index mc-ratio freq)))
         (ampf (<a class=quiet href="#make-env">make-env</a> (or amp-env '(0 0 .5 1 1 0)) :scaler amp :duration dur))
         (indf (<a class=quiet href="#make-env">make-env</a> (or index-env '(0 0 .5 1 1 0)) :scaler fm-index :duration dur)))
    (run
      (loop for i from start to end do
        (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>oscil</em> cr (* (<a class=quiet href="#env">env</a> indf) (<em class=red>oscil</em> md)))))))))
</pre>


<p>See <a href="cl-fm.html">cl-fm.html</a> for a
discussion of FM.  The standard additive synthesis instruments use an array of oscillators to
create the individual spectral components:
</p>

<pre class="indented">
(definstrument simple-osc (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (arr (make-array 20))) ; we'll create a tone with 20 harmonics
    (do ((i 0 (1+ i)))
	((= i 20))
      (setf (aref arr i) (<em class=red>make-oscil</em> (* (1+ i) 100))))
    (run
     (loop for i from start to end do
       (let ((sum 0.0))
	 (do ((i 0 (1+ i)))
	     ((= i (length arr)))
	   (incf sum (<em class=red>oscil</em> (aref arr i))))
	 (<a class=quiet href="#outa">outa</a> i (* amp .05 sum)))))))
</pre>





<!--  ENV  -->

<!-- INDEX envelopes:Envelopes --><em class=def id="envelopes"></em>

<div class="innerheader">env</div>

<pre class="indented">
<em class=def id="make-env">make-env</em> <a class=quiet href="#optional-key">&amp;optional-key</a> 
      envelope      ; list of x,y break-point pairs
      (scaler 1.0)  ; scaler on every y value (before offset is added)
      duration      ; seconds
      (offset 0.0)  ; value added to every y value
      base          ; type of connecting line between break-points
      end           ; end point in samples (similar to dur)
      length        ; duration in samples (can be used instead of end)
<em class=def id="env">env</em> e
<em class=def id="env?">env?</em> e
<em class=def id="env-interp">env-interp</em> x env &amp;optional (base 1.0)
<em class=def id="envelope-interp">envelope-interp</em> x envelope &amp;optional (base 1.0)
</pre>

<table class="method">
<tr><td colspan=2 class="title">env methods</td></tr>
<tr><td class="inner"><em class=gen>mus-location</em></td> <td class="inner">call counter value (number of calls so far on env)</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td><td class="inner">base value (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>     <td class="inner">original breakpoint list</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>   <td class="inner">original scaler</td></tr>
<tr><td class="inner"><em class=gen>mus-offset</em></td>   <td class="inner">original offset</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>   <td class="inner">original duration in samples</td></tr>
</table>

<p>An envelope is a list of break point pairs:  '(0 0  100 1)  is
a ramp from 0 to 1 over an x-axis excursion from 0 to 100 (that is, we have (x0 y0 x1 y1), so
we're going from (0, 0) to (100, 1)).
This list is passed
to <b>make-env</b> along with the scaler
applied to the y axis, the offset added to every y value,
and the time in samples or seconds that the x axis represents.  make-env
returns an env generator which returns the next sample of the envelope each
time it is called.  The actual envelope value, leaving aside the base
is <code>offset + scaler * envelope-value</code>.
</p>

<p>
The kind of interpolation used to get y-values between the break
points (the connecting curve) is determined by the envelope's base.
The default (base = 1.0) gives a straight line connecting the points.
Say we want a ramp moving from .3 to .5 over 1 second.
The corresponding make-env call would be
</p>

<pre class="indented">
(make-env '(0 0 100 1) :scaler .2 :offset .3 :duration 1.0)
or
(make-env '(0 .3 1 .5) :duration 1.0)
</pre>


<p>base = 0.0 gives a step
function (the envelope changes its value suddenly to the new one without any
interpolation).  Any other positive value becomes the exponent of the exponential curve
connecting the points.  base &lt; 1.0 gives convex curves (i.e. bowed
out), and base &gt; 1.0 gives concave curves (i.e. sagging).
If you'd rather think in terms of e^-kt, set the base to (exp k).  
To get arbitrary connecting curves between the break points, treat
the output of env as the input to the connecting function.  Here's an
instrument that maps the line segments into sin x^3:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> mapenv (beg dur frq amp en)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (osc (<a class=quiet href="#make-oscil">make-oscil</a> frq))
         (half-pi (* pi 0.5))
	 (zv (<em class=red>make-env</em> <em class=red>en</em> 1.0 dur)))
    (run
     (loop for i from start below end do
       (let ((zval (<em class=red>env</em> zv))) ; zval^3 is [0.0..1.0], as is sin between 0 and half-pi.
	 (<a class=quiet href="#outa">outa</a> i (* amp (sin (* half-pi zval zval zval)) (<a class=quiet href="#oscil">oscil</a> osc))))))))

(<a class=quiet href="#with-sound">with-sound</a> () (mapenv 0 1 440 .4 '(0 0 50 1 75 0 86 .5 100 0)))
</pre>


<p>Or create your own generator that traces out the curve you want.
J.C.Risset's bell curve could be:</p>

<pre class="indented">
(defmacro bell-curve (x)
  ;; x from 0.0 to 1.0 creates bell curve between .64e-4 and nearly 1.0
  ;; if x goes on from there, you get more bell curves; x can be
  ;; an envelope (a ramp from 0 to 1 if you want just a bell curve)
  `(+ .64e-4 (* .1565 (- (exp (- 1.0 (cos (* two-pi ,x)))) 1.0))))
</pre>

<p><b>mus-reset</b> of an envelope causes it
to start all over again from the beginning. To jump to any position in
an envelope, use <a href="#mus-location">mus-location</a>.
</p>

<p>This instrument repeats the same envelope over and over:
</p>

<pre class="indented">
(definstrument strummer (beg dur env-dur)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a>))
	 (e (<a class=quiet href="#make-env">make-env</a> '(0 0 50 1 100 0) :length env-dur :scaler .1)))
    (run
     (loop for i from beg below (+ beg dur) do 
       (if (&gt; (<em class=red>mus-location</em> e) (<em class=red>mus-length</em> e))
           (<em class=red>mus-reset</em> e))
       (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> e) (<a class=quiet href="#oscil">oscil</a> os)))))))

;;; (with-sound () (strummer 0 22050 2000))
</pre>

<p><b>env-interp</b> and <b>envelope-interp</b> return the value of the envelope at some point
on the x axis; env-interp operates on an 'env' (the output of make-env), whereas
envelope-interp operates on an 'envelope' (a list of breakpoints).
To get weighted random numbers, use the output of
(random 100.0) as the lookup index into an envelope whose x axis goes
from 0 to 100.  Then the envelope y values are the numbers returned,
and the amount of the x-axis taken by a given value is its weight.
Say we want 40% .5, and 60% 1.0,
</p>

<pre class="indented">
(loop for i from 0 to 10 collect 
  (<a class=quiet href="#envelope-interp">envelope-interp</a> (random 100.0) (list 0 .5 40 .5 40.01 1.0 100 1.0)))
=&gt; '(1.0 1.0 0.5 1.0 1.0 0.5 0.5 1.0 0.5 1.0 1.0) 
</pre>

<p>This idea is also available in the <a href="#rand">rand</a> and <a href="#rand-interp">rand-interp</a> generators.
Other env-related functions are:</p>

<table class="spaced">
<tr><td class="bluish"><em class=emdef>envelope-reverse</em> <code>e</code></td><td class="bluish">reverse an envelope</td></tr>
<tr><td><em class=emdef>envelope-repeat</em> <code>e num &amp;optional refl xnorm</code></td><td>repeat an envelope</td></tr>
<tr><td class="bluish"><em class=emdef>envelope-concatenate</em> <code>&amp;rest es</code></td><td class="bluish">concatenate any number of envelopes</td></tr>
<tr><td><em class=emdef>envelope+</em> <code>es</code></td><td>add together any number of envelopes</td></tr>
<tr><td class="bluish"><em class=emdef>envelope*</em> <code>es</code></td><td class="bluish">same but multiply</td></tr>
<tr><td><em class=emdef>envelope-simplify</em> <code>e &amp;optional yg xg</code></td><td>simplify an evelope</td></tr>
<tr><td class="bluish"><em class=emdef>meld-envelopes</em> <code>e0 e1</code></td><td class="bluish">meld two envelopes together</td></tr>
<tr><td><em class=emdef>map-across-envelopes</em> <code>func es</code></td><td>map a function across any number of envelopes</td></tr>
<tr><td class="bluish"><em class=def id="envelope-exp">envelope-exp</em>  <code>e &amp;optional pow xg</code></td><td class="bluish">create exponential segments of envelopes</td></tr>
<tr><td><em class=def id="window-envelope">window-envelope</em> <code>beg end e</code></td><td>return portion of e between two x values</td></tr>
<tr><td class="bluish"><em class=def id="stretch-envelope">stretch-envelope</em> <code>e a0 a1 &amp;optional d0 d1</code></td><td class="bluish">attack and decay portions</td></tr>
<tr><td><em class=def id="scale-envelope">scale-envelope</em> <code>e scale &amp;optional offset</code></td><td>scale e</td></tr>
<tr><td class="bluish"><em class=def id="normalize-envelope">normalize-envelope</em> <code>e &amp;optional norm</code></td><td class="bluish">normalize e</td></tr>
</table>

<p>See env.lisp for more such functions.  To copy an existing envelope while changing one aspect (say
duration), it's simplest to use make-env:
</p>

<pre class="indented">
(defun change-env-dur (e dur)
  (<a class=quiet href="#make-env">make-env</a> (<a class=quiet href="#mus-data">mus-data</a> e)            ; the original breakpoints
	    :scaler (<a class=quiet href="#mus-scaler">mus-scaler</a> e)  ; these are the original values passed to make-env
	    :offset (<a class=quiet href="#mus-offset">mus-offset</a> e)
            :base (<a class=quiet href="#mus-increment">mus-increment</a> e) ; the base (using "mus-increment" because it was available...)
	    :duration dur))
</pre>




<!--  TABLE-LOOKUP  -->

<div class="innerheader">table-lookup</div>

<pre class="indented">
<em class=def id="make-table-lookup">make-table-lookup</em> <a class=quiet href="#optional-key">&amp;optional-key</a> 
        (frequency 0.0)   ; in Hz
        (initial-phase 0.0) ; in radians 
        wave                ; double-float array
        size                ; table size if wave not specified
        type                ; interpolation type (mus-interp-linear)
<em class=def id="table-lookup">table-lookup</em> tl &amp;optional (fm-input 0.0)
<em class=def id="table-lookup?">table-lookup?</em> tl
</pre>


<p><b>table-lookup</b> performs interpolating table lookup.  Indices are first
made to fit in the current table (FM input can produce negative indices), then
interpolation returns the table value.  Table-lookup scales its
frequency change argument (fm-input) to fit whatever its table size is
(that is, it assumes the caller is thinking in terms of a table size of two pi,
and fixes it up).  The wave table should be an array of double-floats (the function
make-double-array can be used to create it).
type sets the type of interpolation used: mus-interp-none,
mus-interp-linear, mus-interp-lagrange, mus-interp-bezier, or mus-interp-hermite.
</p>

<table class="method">
<tr><td colspan=2 class="title">table-lookup methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>      <td class="inner">phase in radians (wave-size/(2*pi))</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>       <td class="inner">wave array</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">wave size (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-interp-type</em></td><td class="inner">interpolation choice (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">table increment per sample</td></tr>
</table>

<p>Table-lookup might be defined:
</p>
<pre class="indented">
(prog1
  (<a class=quiet href="#array-interp">array-interp</a> wave phase)
  (incf phase (+ (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) 
                 (* fm-input 
                    (/ (length wave) 
                       (* 2 pi))))))
</pre>

<p>There are two functions that make it easier to load up
various wave forms:
</p>

<pre class="indented">
<em class=def id="partialstowave">partials-&gt;wave</em> synth-data table &amp;optional (norm t)
<em class=def id="phase-partialstowave">phase-partials-&gt;wave</em> synth-data table &amp;optional (norm t)
</pre>

<p>The synth-data argument is a list of (partial amp) pairs: '(1 .5  2 .25)
gives a combination of a sine wave at the carrier (1) at amplitude .5, and
another at the first harmonic (2) at amplitude .25.  The partial amplitudes are
normalized to sum to a total amplitude of 1.0 unless the argument norm
is nil.  If the initial phases matter (they almost never do), you can use
phase-partials-&gt;wave; in this case the synth-data is a list of (partial amp phase) triples with phases in radians.</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> simple-table (dur)
  (let ((tab (<em class=red>make-table-lookup</em> :wave (<em class=red>partials-&gt;wave</em> '(1 .5 2 .5)))))
    (run
     (loop for i from 0 to dur do
       (<a class=quiet href="#outa">outa</a> i (* .3 (<em class=red>table-lookup</em> tab)))))))
</pre>

<p><a href="spectr.clm">spectr.clm</a> has a steady state spectra of
several standard orchestral instruments, courtesy of James A. Moorer.
<a href="bird.clm">bird.clm</a> (using bird.ins and bigbird.ins) has about 50 North American bird songs. </p>



<!--  POLYWAVE, POLYSHAPE  -->

<div class="innerheader">polywave</div>

<pre class="indented">
<em class=def id="make-polywave">make-polywave</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) 
        (partials '(1 1)) (type mus-chebyshev-first-kind)
<em class=def id="polywave">polywave</em> w &amp;optional (fm 0.0)
<em class=def id="polywave?">polywave?</em> w

<em class=def id="make-polyshape">make-polyshape</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) 
        (initial-phase 0.0) coeffs (partials '(1 1)) (kind mus-chebyshev-first-kind)
<em class=def id="polyshape">polyshape</em> w &amp;optional (index 1.0) (fm 0.0)
<em class=def id="polyshape?">polyshape?</em> w

<em class=def id="partialstopolynomial">partials-&gt;polynomial</em> partials &amp;optional (kind mus-chebyshev-first-kind)
</pre>

<p>polywave is the new form of polyshape.
These two generators
drive a sum of scaled Chebyshev polynomials with
a sinusoid, creating a sort of cross between additive synthesis and FM; see
"Digital Waveshaping Synthesis" by Marc Le Brun in JAES 1979 April, vol 27, no 4, p250.
kind or type can be <b>mus-chebyshev-first-kind</b> or <b>mus-chebyshev-second-kind</b>.
</p>

<table class="method">
<tr><td colspan=2 class="title">polywave methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td> <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>    <td class="inner">index (polywave only)</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>     <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>      <td class="inner">polynomial coeffs</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>    <td class="inner">number of partials</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td> <td class="inner">frequency in radians per sample</td></tr>
</table>

<p>Polywave and polyshape:</p>
<pre class="indented">
(prog1
  (<a class=quiet href="#array-interp">array-interp</a> wave (* (length wave) 
                        (+ 0.5 (* index 0.5 (sin phase)))))
  (incf phase (+ (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) fm)))

(prog1
  (<a class=quiet href="#polynomial">polynomial</a> wave (sin phase))
  (incf phase (+ (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) fm)))
</pre>

<p>In its simplest use, waveshaping is an inexpensive additive synthesis:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> simp ()
  (let ((wav (<em class=red>make-polyshape</em> :frequency 440 :partials '(1 .5 2 .3 3 .2))))
    (run (loop for i from 0 to 1000 do (<a class=quiet href="#outa">outa</a> i (<em class=red>polyshape</em> wav))))))
</pre>

<p>
Bigbird is another example:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> bigbird (start duration frequency freqskew amplitude freq-env amp-env partials)
  (multiple-value-bind (beg end) (<a class=quiet href="#timestosamples">times-&gt;samples</a> start duration)
    (let* ((gls-env (<a class=quiet href="#make-env">make-env</a> freq-env (<a class=quiet href="#hztoradians">hz-&gt;radians</a> freqskew) duration))
           (polyos (<a class=quiet href="#make-oscil">make-polyshape</a> frequency
                     :coeffs (<em class=red>partials-&gt;polynomial</em> (normalize-partials partials))))
           (fil (<a class=quiet href="#make-one-pole">make-one-pole</a> .1 .9))
           (amp-env (<a class=quiet href="#make-env">make-env</a> amp-env amplitude duration)))
      (run
        (loop for i from beg below end do
          (<a class=quiet href="#outa">outa</a> i 
            (<a class=quiet href="#one-pole">one-pole</a> fil   ; for distance effects
              (* (<a class=quiet href="#env">env</a> amp-env) 
                 (<em class=red>polyshape</em> polyos 1.0 (<a class=quiet href="#env">env</a> gls-env))))))))))

(with-sound ()
  (bigbird beg .05 1800 1800 .2
           '(.00 .00 .40 1.00 .60 1.00 1.00 .0)         ; freq env
           '(.00 .00 .25 1.00 .60 .70 .75 1.00 1.00 .0) ; amp env
           '(1 .5 2 1 3 .5 4 .1 5 .01)))                ; partials (bird song spectrum)
</pre>

<p>
See also <a href="pqw.ins">pqw.ins</a> for phase quadrature waveshaping (single-sideband tricks).
</p>



<!--  SAWTOOTH ETC  -->

<div class="innerheader">sawtooth-wave and friends</div>

<pre class="indented">
<em class=def id="make-triangle-wave">make-triangle-wave</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (amplitude 1.0) (initial-phase pi)
<em class=def id="triangle-wave">triangle-wave</em> s &amp;optional (fm 0.0)
<em class=def id="triangle-wave?">triangle-wave?</em> s

<em class=def id="make-square-wave">make-square-wave</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (amplitude 1.0) (initial-phase 0)
<em class=def id="square-wave">square-wave</em> s &amp;optional (fm  0.0)
<em class=def id="square-wave?">square-wave?</em> s

<em class=def id="make-sawtooth-wave">make-sawtooth-wave</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (amplitude 1.0) (initial-phase pi)
<em class=def id="sawtooth-wave">sawtooth-wave</em> s &amp;optional (fm 0.0)
<em class=def id="sawtooth-wave?">sawtooth-wave?</em> s

<em class=def id="make-pulse-train">make-pulse-train</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (amplitude 1.0) (initial-phase two-pi)
<em class=def id="pulse-train">pulse-train</em> s &amp;optional (fm 0.0)
<em class=def id="pulse-train?">pulse-train?</em> s
</pre>


<p>These generators produce some standard old-timey wave forms that are still occasionally useful (well, triangle-wave
is useful; the others are silly).
<b>sawtooth-wave</b> ramps from -1 to 1, then goes immediately back to -1.
Use a negative frequency to turn the "teeth" the other way.
<b>triangle-wave</b> ramps from -1 to 1, then ramps from 1 to -1.
<b>pulse-train</b> produces a single sample of 1.0, then zeros.
<b>square-wave</b> produces 1 for half a period, then 0.  All have a period
of two-pi, so the fm argument should have an effect comparable to the
same FM applied to the same waveform in <a href="#table-lookup">table-lookup</a>.
These are not band-limited; if the frequency is too high, you can get foldover,
but as far as I
know, no-one uses these as audio frequency tone generators &mdash; who would want to
listen to a square wave?  A more reasonable square-wave can be generated via
tanh(n * sin(theta)), where "n" (a float) sets how squared-off it is.
Even more amusing is this algorithm:
</p>

<pre class="indented">
(defun cossq (c theta)    ; as c -&gt; 1.0+, more of a square wave (try 1.00001)
  (let* ((cs (cos theta)) ; (+ theta pi) if matching sin case (or (- ...))
	 (cp1 (+ c 1.0))
	 (cm1 (- c 1.0))
	 (cm1c (expt cm1 cs))
	 (cp1c (expt cp1 cs)))
    (/ (- cp1c cm1c)
       (+ cp1c cm1c))))  ; from "From Squares to Circles..." Lasters and Sharpe, Math Spectrum 38:2

(defun sinsq (c theta) (cossq c (- theta (* 0.5 pi))))
(defun sqsq (c theta) (sinsq c (- (sinsq c theta)))) ; a sharper square wave

(let ((angle 0.0))
  (loop ...
    (let ((val (* 0.5 (+ 1.0 (sqsq 1.001 angle))))) 
      (set! angle (+ angle .02)) 
    ...)))
</pre>

<table class="method">
<tr><td colspan=2 class="title">saw-tooth and friends' methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td> <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>     <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>    <td class="inner">amplitude arg used in make-&lt;gen&gt;</td></tr>
<tr><td class="inner"><em class=gen>mus-width</em></td>     <td class="inner">width of square-wave pulse (0.0 to 1.0)</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td> <td class="inner">frequency in radians per sample</td></tr>
</table>

<pre class="indented">
One popular kind of vibrato is:
  (+ (triangle-wave pervib) 
     (<a class=quiet href="#rand-interp">rand-interp</a> ranvib))
</pre>

<p>Just for completeness, here's an example:
</p>

<pre class="indented">
(definstrument simple-saw (beg dur amp)
  (let* ((os (<em class=red>make-sawtooth-wave</em> 440.0))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*)))))
    (run
     (loop for i from start to end do
       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>sawtooth-wave</em> os)))))))
</pre>



<!--  NCOS, NSIN  -->

<div class="innerheader">ncos and nsin</div>

<pre class="indented">
<em class=def id="make-ncos">make-ncos</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (n 1)
<em class=def id="ncos">ncos</em> cs &amp;optional (fm 0.0)
<em class=def id="ncos?">ncos?</em> cs

<em class=def id="make-nsin">make-nsin</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (n 1)
<em class=def id="nsin">nsin</em> cs &amp;optional (fm 0.0)
<em class=def id="nsin?">nsin?</em> cs
</pre>

<p>
<b>ncos</b> produces a band-limited pulse train containing
n cosines.  I think this was originally viewed as a way to get a speech-oriented
pulse train that would then be passed through formant filters (see pulse-voice in examp.scm).  There are many similar formulas:
see <a href="sndclm.html#ncos2">ncos2</a> and friends in generators.scm. "Trigonometric Delights" by Eli Maor has
a derivation of a nsin formula and a neat
geometric explanation.  For a derivation of the ncos formula, see "Fourier
Analysis" by Stein and Shakarchi, or multiply the left side (the cosines) by sin(x/2), use the trig
formula 2sin(a)cos(b) = sin(b+a)-sin(b-a), and notice that all the terms in the series
cancel except the last.
</p>

<table class="method">
<tr><td colspan=2 class="title">ncos methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>      <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>     <td class="inner">(/ 1.0 cosines)</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">n or cosines arg used in make-&lt;gen&gt;</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">frequency in radians per sample</td></tr>
</table>

<pre class="indented">
ncos is based on:
  cos(x) + cos(2x) + ... cos(nx) = 
    (sin((n + .5)x) / (2 * sin(x / 2))) - 1/2

  known as the Dirichlet kernel
</pre>

<pre class="indented">
(definstrument simple-soc (beg dur freq amp)
  (let* ((os (<em class=red>make-ncos</em> freq 10))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*)))))
    (run
     (loop for i from start to end do
       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>ncos</em> os)))))))
</pre>

<p>If you sweep ncos upwards in frequency, you'll eventually
get foldover; the generator produces its preset number of cosines no
matter what.  It is possible to vary the spectrum smoothly (without stooping a filter): multiply the
output of ncos by an exponential &mdash; there's an example in <a href="sndclm.html#ncos">sndclm.html</a>.
</p>

<p><b>nsin</b> produces a sum of n equal amplitude sines.  It is very similar (good and bad) to ncos.
</p>

<table class="method">
<tr><td colspan=2 class="title">nsin methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td> <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>     <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>    <td class="inner">dependent on number of sines</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>    <td class="inner">n or sines arg used in make-&lt;gen&gt;</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td> <td class="inner">frequency in radians per sample</td></tr>
</table>

<pre class="indented">
nsin is based on:
  sin(x) + sin(2x) + ... sin(nx) = 
    sin(n * x / 2) * (sin((n + .5)x) / sin(x / 2))

  known as the conjugate Dirichlet kernel
</pre>




<!--  SSB-AM  -->

<div class="innerheader">ssb-am</div>

<pre class="indented">
<em class=def id="make-ssb-am">make-ssb-am</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (order 40)
<em class=def id="ssb-am">ssb-am</em> gen &amp;optional (insig 0.0) (fm 0.0)
<em class=def id="ssb-am?">ssb-am?</em> gen
</pre>

<p><b>ssb-am</b> provides single sideband suppressed carrier amplitude modulation, normally used for frequency shifting.
</p>

<table class="method">
<tr><td colspan=2 class="title">ssb-am methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>   <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>       <td class="inner">phase (of embedded sin osc) in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>       <td class="inner">embedded delay line size</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>      <td class="inner">same as mus-order</td></tr>
<tr><td class="inner"><em class=gen>mus-interp-type</em></td> <td class="inner"><code>mus-interp-none</code></td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeff</em></td>      <td class="inner">FIR filter coeff</td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeffs</em></td>     <td class="inner">embedded Hilbert transform FIR filter coeffs</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>        <td class="inner">embedded filter state</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>   <td class="inner">frequency in radians per sample</td></tr>
</table>

<pre class="indented">
ssb-am is based on:
  cos(freq) * delay(insig) +/- sin(freq) * hilbert(insig) 
  which shifts insig spectrum by freq 
  and cancels upper/lower sidebands
</pre>

<p>See the instrument under <a href="#amplitude-modulate">amplitude-modulate</a> for
an explicit version of this generator.
Here's a complicated way to get a sine wave at 550 Hz:
</p>

<pre class="indented">
(definstrument shift-pitch (beg dur freq amp shift)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (am (<em class=red>make-ssb-am</em> shift)))
    (run
     (loop for i from start to end do
       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>ssb-am</em> am (<a class=quiet href="#oscil">oscil</a> os))))))))
</pre>




<!--  WAVE-TRAIN  -->

<div class="innerheader">wave-train</div>

<pre class="indented">
<em class=def id="make-wave-train">make-wave-train</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (initial-phase 0.0) wave size type
<em class=def id="wave-train">wave-train</em> w &amp;optional (fm 0.0)
<em class=def id="wave-train?">wave-train?</em> w
</pre>

<p><b>wave-train</b> produces a wave train (an extension of pulse-train and table-lookup).
Frequency is the repetition rate of the wave found in wave.
Successive waves can overlap.  With some simple envelopes, or filters, you can
use this for VOSIM and other related techniques.</p>

<table class="method">
<tr><td colspan=2 class="title">wave-train methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>      <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>       <td class="inner">wave array (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">length of wave array (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-interp-type</em></td><td class="inner">interpolation choice (no setf)</td></tr>
</table>

<p>Here is a FOF instrument based loosely on fof.c of Perry Cook and the article
"Synthesis of the Singing Voice" by Bennett and Rodet in 
"Current Directions in Computer Music Research".
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> fofins (beg dur frq amp vib f0 a0 f1 a1 f2 a2 &amp;optional ve ae)
  (let* ((start (floor (* beg *srate*)))
         (end (+ start (floor (* dur *srate*))))
         (ampf (<a class=quiet href="#make-env">make-env</a> (or ae (list 0 0 25 1 75 1 100 0)) :scaler amp :duration dur))
         (frq0 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> f0))
         (frq1 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> f1))
         (frq2 (<a class=quiet href="#hztoradians">hz-&gt;radians</a> f2))
         (foflen (if (= *srate* 22050) 100 200))
         (vibr (<a class=quiet href="#make-oscil">make-oscil</a> 6))
	 (vibenv (<a class=quiet href="#make-env">make-env</a> (or ve (list 0 1 100 1)) :scaler vib :duration dur))
         (win-freq (/ two-pi foflen))
         (foftab (make-double-float-array foflen))
         (wt0 (<em class=red>make-wave-train</em> :wave foftab :frequency frq)))
    (loop for i from 0 below foflen do
      (setf (aref foftab i) (double-float      
        ;; this is not the pulse shape used by B&amp;R
            (* (+ (* a0 (sin (* i frq0))) 
                  (* a1 (sin (* i frq1))) 
                  (* a2 (sin (* i frq2)))) 
               .5 (- 1.0 (cos (* i win-freq)))))))
    (run
     (loop for i from start below end do
       (<a class=quiet href="#outa">outa</a> i (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>wave-train</em> wt0 (* (<a class=quiet href="#env">env</a> vibenv) (<a class=quiet href="#oscil">oscil</a> vibr)))))))))

(<a class=quiet href="#with-sound">with-sound</a> () (fofins 0 1 270 .2 .001 730 .6 1090 .3 2440 .1)) ; "Ahh"

(<a class=quiet href="#with-sound">with-sound</a> () 
  (fofins 0 4 270 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 1 3 .5 10 .2 20 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 (* 6/5 540) .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 .5 .5 3 .25 6 .1 10 .1 50 .1 60 .2 85 1 100 0))
  (fofins 0 4 135 .2 0.005 730 .6 1090 .3 2440 .1 '(0 0 40 0 75 .2 100 1) 
          '(0 0 1 3 3 1 6 .2 10 .1 50 .1 60 .2 85 1 100 0)))
</pre>




<!--  RAND, RAND-INTERP  -->

<div class="innerheader">rand</div>

<pre class="indented">
<em class=def id="make-rand">make-rand</em> <a class=quiet href="#optional-key">&amp;optional-key</a> 
        (frequency 0.0)          ; freq at which new random numbers occur
        (amplitude 1.0)            ; numbers are between -amplitude and amplitude
        (envelope '(-1 1 1 1))     ; distribution envelope (uniform distribution between -1 and 1 is the default)
        distribution               ; pre-computed distribution
<em class=def id="rand">rand</em> r &amp;optional (sweep 0.0)
<em class=def id="rand?">rand?</em> r

<em class=def id="make-rand-interp">make-rand-interp</em> <a class=quiet href="#optional-key">&amp;optional-key</a> 
        (frequency 0.0) 
        (amplitude 1.0) 
        (envelope '(-1 1 1 1) 
        distribution)
<em class=def id="rand-interp">rand-interp</em> r &amp;optional (sweep 0.0)
<em class=def id="rand-interp?">rand-interp?</em> r

<em class=emdef>centered-random</em> amp 
<em class=def id="clm-random">clm-random</em> amp
<em class=def id="mus-random">mus-random</em> amp ; same as centered-random (for C-side compatibility)
<em class=def id="mus-set-rand-seed">mus-set-rand-seed</em> seed
</pre>


<p><b>rand</b> returns a sequence of random numbers between -amplitude and
amplitude (it produces a sort of step function).
<b>rand-interp</b> interpolates between successive
random numbers;
it could be defined as (<a class=quiet href="#moving-average">moving-average</a> agen (rand rgen)) where the
averager has the same period (length) as the rand.  
Lisp's function random returns a number between 0.0 and its argument.
In both cases, the envelope argument determines the random number distribution.
<b>centered-random</b> returns a number between -amp and amp.
<b>clm-random</b> returns a random number between 0 and amp. In the latter two cases,
mus-set-rand-seed sets the seed for the random number generator.  This provides a
way around Lisp's clumsy mechanism for repeating a random number sequence.
</p>

<table class="method">
<tr><td colspan=2 class="title">rand and rand-interp methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>      <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>     <td class="inner">amplitude arg used in make-&lt;gen&gt;</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">distribution table length</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>       <td class="inner">distribution table, if any</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">frequency in radians per sample</td></tr>
</table>

<pre class="indented">
rand:
  (if (&gt;= phase (* 2 pi))
      (setf output (<em class=red>centered-random</em> amplitude)))
  (incf phase (+ (<a class=quiet href="#hztoradians">hz-&gt;radians</a> frequency) sweep))
</pre>

<p>There are a variety of ways to change <b>rand</b>'s uniform distribution to
some other: <code>(random (random 1.0))</code> or <code>(sin (random 3.14159))</code> are simple examples. Exponential distribution could be:
</p>

<pre class="indented">
  (/ (log (max .01 (random 1.0))) (log .01))
</pre>

<p>where the ".01"'s affect how tightly the resultant values cluster toward 0.0 &mdash;
set it to .0001 for example to get most of the random values close to 0.0.
The central-limit theorem says that you can get closer and closer to gaussian
noise by adding rand's together.  Orfanidis in 
"Introduction to Signal Processing" says 12 calls on rand will
do perfectly well. 
We could define our own generator:
</p>

<pre class="indented">
(defmacro gaussian-noise (r)
  ;; r=a rand generator allocated via make-rand
  `(let ((val 0.0))
     (dotimes (i 12) (incf val (<em class=red>rand</em> ,r)))
     val))
</pre>

<p>
For a discussion of the central limit theorem, see
Korner "Fourier Analysis" and Miller Puckette's dissertation:
http://www-crca.ucsd.edu/~msp/Publications/thesis.ps.
Another method is the "rejection method" in which we generate random number
pairs until we get a pair that falls within the
desired distribution; see random-any in dsp.scm (Snd) for code to do this.
It is faster at run time, however, to use the "transformation method".
The make-rand and make-rand-interp envelope arguments specify
the desired distribution function; the generator takes the
inverse of the integral of the envelope, loads that into an array, and uses
<code>(array-interp (rand array-size))</code> at run time.  This gives
random numbers of any arbitrary distribution at a computational cost
equivalent to the polyshape generator (which is very similar).
The x axis sets the output range (before scaling by amplitude), and
the y axis sets the relative weight of the corresponding x axis value.
So, the default is <code>'(-1 1 1 1)</code> which says "output numbers between -1 and 1,
each number having the same chance of being chosen".
An envelope of <code>'(0 1 1 0)</code> outputs values between 0 and 1, denser toward 0.
If you already have the distribution table (the result of <code>(inverse-integrate envelope))</code>,
you can pass it through the distribution argument.
</p>

<p>
You can, of course, filter the output of rand to get a different
frequency distribution (as opposed to the "value distribution"
above, all of which are forms of white noise).
Orfanidis also mentions a clever way to get reasonably good 1/f noise:
sum together n rand's, where each rand is running an octave slower
than the preceding:
</p>

<pre class="indented">
(defun make-1f-noise (n)
  ;; returns an array of rand's ready for the 1f-noise generator
  (let ((rans (make-array n)))
    (dotimes (i n) (setf (aref rans i) (<em class=red>make-rand</em> :frequency (/ *srate* (expt 2 i)))))
    rans))

(defmacro 1f-noise (rans)
  `(let ((val 0.0)
         (len (length ,rans)))
     (dotimes (i len) (incf val (<em class=red>rand</em> (aref ,rans i))))
     (/ val len)))
</pre>

<p>See also <a href="green.cl">green.cl</a> (bounded brownian noise that can mimic 1/f noise in some cases).
And we can't talk about noise without mentioning fractals:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> fractal (start duration m x amp)
  ;; use formula of M J Feigenbaum
  (let* ((beg (floor (* *srate* start)))
	 (end (+ beg (floor (* *srate* duration)))))
    (run
     (loop for i from beg below end do
       (<a class=quiet href="#outa">outa</a> i (* amp x))
       (setf x (- 1.0 (* m x x)))))))

;;; quickly reaches a stable point for any m in[0,.75], so:
(<a class=quiet href="#with-sound">with-sound</a> () (fractal 0 1 .5 0 .5)) 
;;; is just a short "ftt"
(<a class=quiet href="#with-sound">with-sound</a> () (fractal 0 1 1.5 .20 .2))
</pre>

<p>With this instrument you can easily hear
the change over from the stable equilibria, to the period doublings,
and finally into the combination of noise and periodicity that
has made these curves famous. See appendix 2 to Ekeland's "Mathematics and the Unexpected" for more details.
Another instrument based on similar ideas is:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> attract (beg dur amp c) ; c from 1 to 10 or so
  ;; by James McCartney, from CMJ vol 21 no 3 p 6
  (let* ((st (floor (* beg *srate*)))
	 (nd (+ st (floor (* dur *srate*))))
	 (a .2) (b .2) (dt .04)
	 (scale (/ (* .5 amp) c))
	 (x1 0.0) (x -1.0) (y 0.0) (z 0.0))
    (run
     (loop for i from st below nd do
       (setf x1 (- x (* dt (+ y z))))
       (incf y (* dt (+ x (* a y))))
       (incf z (* dt (- (+ b (* x z)) (* c z))))
       (setf x x1)
       (<a class=quiet href="#outa">outa</a> i (* scale x))))))
</pre>

<p>which gives brass-like sounds!
</p>




<!--  SIMPLE FILTERS  -->

<div class="innerheader">one-pole and friends</div>
<!-- INDEX filters:Filters --><em class=def id="filters"></em>

<pre class="indented">
 <em class=def id="make-one-pole">make-one-pole</em> <a class=quiet href="#optional-key">&amp;optional-key</a> a0 b1    ; b1 &lt; 0.0 gives lowpass, b1 &gt; 0.0 gives highpass
 <em class=def id="one-pole">one-pole</em> f input 
 <em class=def id="one-pole?">one-pole?</em> f

 <em class=def id="make-one-zero">make-one-zero</em> <a class=quiet href="#optional-key">&amp;optional-key</a> a0 a1    ; a1 &gt; 0.0 gives weak lowpass, a1 &lt; 0.0 highpass
 <em class=def id="one-zero">one-zero</em> f input 
 <em class=def id="one-zero?">one-zero?</em> f

 <em class=def id="make-two-pole">make-two-pole</em> <a class=quiet href="#optional-key">&amp;optional-key</a> a0 b1 b2 frequency radius
 <em class=def id="two-pole">two-pole</em> f input 
 <em class=def id="two-pole?">two-pole?</em> f

 <em class=def id="make-two-zero">make-two-zero</em> <a class=quiet href="#optional-key">&amp;optional-key</a> a0 a1 a2 frequency radius
 <em class=def id="two-zero">two-zero</em> f input 
 <em class=def id="two-zero?">two-zero?</em> f
</pre>

<table class="method">
<tr><td colspan=2 class="title">simple filter methods</td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeff</em></td>    <td class="inner">a0, a1, a2 in equations</td></tr>
<tr><td class="inner"><em class=gen>mus-ycoeff</em></td>    <td class="inner">b1, b2 in equations</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>     <td class="inner">1 or 2 (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>    <td class="inner">two-pole and two-zero radius</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td> <td class="inner">two-pole and two-zero center frequency</td></tr>
</table>

<pre class="indented">
one-zero  y(n) = a0 x(n) + a1 x(n-1)
one-pole  y(n) = a0 x(n) - b1 y(n-1)
two-pole  y(n) = a0 x(n) - b1 y(n-1) - b2 y(n-2)
two-zero  y(n) = a0 x(n) + a1 x(n-1) + a2 x(n-2)
</pre>

<p>
The "a0, b1" nomenclature is taken from Julius Smith's "An Introduction to Digital
Filter Theory" in Strawn "Digital Audio Signal Processing", and is different
from that used in the more general filters such as <a href="#fir-filter">fir-filter</a>.
In <b>make-two-pole</b> and <b>make-two-zero</b> you can specify either the actual
desired coefficients (<b>a0</b> and friends), or the center frequency and radius of the
filter (<b>frequency</b> and <b>radius</b>).
radius should be between 0 and 1 (but less than 1), and
frequency should be between 0 and srate/2.  
</p>
<p>The bird instrument uses a one-pole filter for a distance cue:
</p>

<pre class="indented">
(definstrument bird (startime dur frequency freq-skew amplitude freq-envelope amp-envelope 
	             &amp;optional (lpfilt 1.0) (degree 0) (reverb-amount 0))
  (multiple-value-bind (beg end) (<a class=quiet href="#timestosamples">times-&gt;samples</a> startime dur)
    (let* ((amp-env (<a class=quiet href="#make-env">make-env</a> amp-envelope amplitude dur))
	   (gls-env (<a class=quiet href="#make-env">make-env</a> freq-envelope (<a class=quiet href="#hztoradians">hz-&gt;radians</a> freq-skew) dur))
	   (loc (<a class=quiet href="#make-locsig">make-locsig</a> :degree degree :distance 1.0 :reverb reverb-amount))
	   (fil (<em class=red>make-one-pole</em> lpfilt (- 1.0 lpfilt)))
	   (s (<a class=quiet href="#make-oscil">make-oscil</a> :frequency frequency)))
      (run
       (loop for i from beg to end do
	 (<a class=quiet href="#locsig">locsig</a> loc i (<em class=red>one-pole</em> fil (* (<a class=quiet href="#env">env</a> amp-env) 
                                        (<a class=quiet href="#oscil">oscil</a> s (<a class=quiet href="#env">env</a> gls-env))))))))))
</pre>




<!--  FORMANT  -->

<div class="innerheader">formant</div>

<pre class="indented">
<em class=def id="make-formant">make-formant</em> <a class=quiet href="#optional-key">&amp;optional-key</a> frequency radius
<em class=def id="formant">formant</em> f input       ; resonator centered at frequency, bandwidth set by radius above
<em class=def id="formant?">formant?</em> f

<em class=def id="make-firmant">make-firmant</em> <a class=quiet href="#optional-key">&amp;optional-key</a> frequency radius
<em class=def id="firmant">firmant</em> f input       ; resonator centered at frequency, bandwidth set by radius above
<em class=def id="firmant?">firmant?</em> f
</pre>

<table class="method">
<tr><td colspan=2 class="title">formant methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td> <td class="inner">formant center frequency</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>     <td class="inner">2 (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>    <td class="inner">gain</td></tr>
</table>

<pre class="indented">
formant:
    y(n) = x(n) - 
           r * x(n-2) + 
           2 * r * cos(frq) * y(n-1) - 
           r * r * y(n-2)

    firmant:
    x(n+1) = r * (x(n) - 2 * sin(frq/2) * y(n)) + input
    y(n+1) = r * (2 * sin(frq/2) * x(n+1) + y(n))
</pre>

<p>formant and firmant are resonators (two-pole, two-zero bandpass filters) centered at "frequency", with the bandwidth set by "radius".
The formant generator is described in "A Constant-gain Digital Resonator Tuned By a Single Coefficient" by Julius
O. Smith and James B. Angell in Computer Music Journal Vol. 6 No. 4 (winter
1982) and "A note on
Constant-Gain Digital Resonators" by Ken Steiglitz, CMJ vol 18 No. 4 pp.8-10
(winter 1994).
The formant bandwidth is a function of the "radius", and its center frequency is set by "frequency".
As the radius approaches 1.0 (the unit circle), the
resonance gets narrower.
Use <a href="sndclm.html#mus-frequency">mus-frequency</a> to change the center frequency, and <a href="sndclm.html#mus-scaler">mus-scaler</a> to change the radius.
The radius can be set in terms of desired bandwidth in Hz via:
</p>

<pre class="indented">
(exp (* -0.5 (hz-&gt;radians bandwidth)))
</pre>

<p>If you change the radius, the peak amplitude 
of the output changes.  
The firmant generator is the "modified coupled form" of the formant generator,
developed by Max Mathews and Julius Smith in "Methods for Synthesizing Very High Q Parametrically
Well Behaved Two Pole Filters".
grapheq.ins uses a bank of formant generators to implement a graphic equalizer,
and fade.ins uses it for frequency domain mixing. Here is an instrument
for cross-synthesis with a bank of 128 formants:
</p>

<!-- INDEX cross-synthesis:cross synthesis -->
<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> <em class=def id="cross-synthesis">cross-synthesis</em> (beg dur file1 file2 amp &amp;optional (fftsize 128) (r two-pi) (lo 2) (hi nil))
  ;; file1: input sound, file2: gives spectral shape
  ;; r: controls width of formants (1.0 is another good value here)
  ;; lo and hi: which of the formants are active (a sort of filter on top of the filter)
  ;; we use the on-going spectrum of file2 to scale the outputs of the formant array
  (let* ((fil1 (<a class=quiet href="#open-input*">open-input*</a> file1))
	 (fil2 (and fil1 (<a class=quiet href="#open-input*">open-input*</a> file2))))
    (when fil1
      (if (not fil2)
          (<a class=quiet href="#close-input">close-input</a> fil1)
        (unwind-protect
	  (let* ((start (floor (* beg *srate*)))
	         (end (+ start (floor (* dur *srate*))))
	         (freq-inc (floor fftsize 2))
	         (fdr (make-double-float-array fftsize))
	         (fdi (make-double-float-array fftsize))
	         (diffs (make-double-float-array freq-inc))
	         (<a class=quiet href="#spectrum">spectrum</a> (make-double-float-array freq-inc))
	         (filptr 0)
	         (ctr freq-inc)
	         (radius (- 1.0 (/ r fftsize)))
	         (bin (float (/ *srate* fftsize)))
	         (fs (make-array freq-inc)))
	    (if (null hi) (setf hi freq-inc))
	    (loop for k from lo below hi do 
              (setf (aref fs k) (<em class=red>make-formant</em> (* k bin) radius)))
	    (run
	     (loop for i from start below end do
	       (when (= ctr freq-inc)
	         (dotimes (k fftsize)
		   (setf (aref fdr k) (<a class=quiet href="#ina">ina</a> filptr fil2))
		   (incf filptr))
	         (<a class=quiet href="#clear-array">clear-array</a> fdi)
	         (decf filptr freq-inc)
	         (<a class=quiet href="#fft">fft</a> fdr fdi fftsize 1)
	         (<a class=quiet href="#rectangulartomagnitudes">rectangular-&gt;magnitudes</a> fdr fdi)
	         (dotimes (k freq-inc) 
                   (setf (aref diffs k) 
                     (/ (- (aref fdr k) (aref spectrum k)) freq-inc)))
	         (setf ctr 0))
	       (incf ctr)
	       (dotimes (k freq-inc) 
                 (incf (aref spectrum k) (aref diffs k)))
	       (let ((outval 0.0)
		     (inval (<a class=quiet href="#ina">ina</a> i fil1)))
	         (loop for k from lo below hi do 
                   (incf outval (* (aref spectrum k) (<em class=red>formant</em> (aref fs k) inval))))
	         (<a class=quiet href="#outa">outa</a> i (* amp outval))))))
        (progn
	  (<a class=quiet href="#close-input">close-input</a> fil1)
	  (<a class=quiet href="#close-input">close-input</a> fil2)))))))

(<a class=quiet href="#with-sound">with-sound</a> () (cross-synthesis 0 1 "oboe" "fyow" .5 256 1.0 3 100))
</pre>



<!--  FILTERS  -->

<div class="innerheader">filter, iir-filter, fir-filter</div>

<pre class="indented">
 <em class=def id="make-filter">make-filter</em> <a class=quiet href="#optional-key">&amp;optional-key</a> order xcoeffs ycoeffs
 <em class=def id="filter">filter</em> fl inp 
 <em class=def id="filter?">filter?</em> fl

 <em class=def id="make-fir-filter">make-fir-filter</em> <a class=quiet href="#optional-key">&amp;optional-key</a> order xcoeffs
 <em class=def id="fir-filter">fir-filter</em> fl inp 
 <em class=def id="fir-filter?">fir-filter?</em> fl

 <em class=def id="make-iir-filter">make-iir-filter</em> <a class=quiet href="#optional-key">&amp;optional-key</a> order ycoeffs
 <em class=def id="iir-filter">iir-filter</em> fl inp 
 <em class=def id="iir-filter?">iir-filter?</em> fl

 <em class=def id="envelopetocoeffs">envelope-&gt;coeffs</em> &amp;key order envelope dc
</pre>

<p>These are the general FIR/IIR filters of arbitrary order.
The order argument is one greater than the nominal filter
order (it is the size of the arrays).
</p>

<table class="method">
<tr><td colspan=2 class="title">general filter methods</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>     <td class="inner">filter order</td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeff</em></td>    <td class="inner">x (input) coeff</td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeffs</em></td>   <td class="inner">x (input) coeffs</td></tr>
<tr><td class="inner"><em class=gen>mus-ycoeff</em></td>    <td class="inner">y (output) coeff</td></tr>
<tr><td class="inner"><em class=gen>mus-ycoeffs</em></td>   <td class="inner">y (output) coeffs</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>      <td class="inner">current state (input values)</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>    <td class="inner">same as mus-order</td></tr>
</table>

<pre class="indented">
filter:
  (let ((xout 0.0))
    (setf (aref state 0) input)
    (loop for j from order downto 1 do
      (incf xout (* (aref state j) (aref xcoeffs j)))
      (decf (aref state 0) (* (aref ycoeffs j) (aref state j)))
      (setf (aref state j) (aref state (1- j))))
    (+ xout (* (aref state 0) (aref xcoeffs 0))))
</pre>

<p>dsp.scm in the Snd package has a number of filter design functions,
and various specializations of the filter generators, including such
perennial favorites as biquad, butterworth, hilbert transform, and
notch filters. Similarly, analog-filter.scm in the Snd tarball has
the usual IIR suspects: Butterworth, Chebyshev, Bessel, and Elliptic filters.
</p>

<p>Say we want to put a spectral envelope on a noise source.
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> filter-noise (beg dur amp &amp;key xcoeffs)
  (let* ((st (floor (* beg *srate*)))
         (noi (<a class=quiet href="#make-rand">make-rand</a> :frequency (* .5 *srate*) :amplitude amp))
         (flA (<em class=red>make-filter</em> :xcoeffs xcoeffs))
         (nd (+ st (floor (* *srate* dur)))))
    (run
      (loop for i from st below nd do
        (<a class=quiet href="#outa">outa</a> i (<em class=red>filter</em> flA (<a class=quiet href="#rand">rand</a> noi)))))))

(<a class=quiet href="#with-sound">with-sound</a> () 
  (filter-noise 0 1 .2 
    :xcoeffs (<a class=quiet href="#envelopetocoeffs">envelope-&gt;coeffs</a> :order 12 :envelope '(0 0.0 .125 0.5 .2 0.0 .3 1.0 .5 0.0 1.0 0.0))))
</pre>

<p><b>envelope-&gt;coeffs</b> translates a frequency response envelope into the corresponding FIR filter coefficients.
The order of the filter determines how close you
get to the envelope.</p>

<p>The Hilbert transform can be implemented with an fir-filter:</p>

<pre class="indented">
(defun make-hilbert (&amp;optional (len 30))
  ;; create the coefficients of the Hilbert transformer of length len
  (let* ((arrlen (1+ (* 2 len)))
	 (arr (make-array arrlen)))
    (do ((i (- len) (1+ i)))
	((= i len))
      (let* ((k (+ i len))
	     (denom (* pi i))
	     (num (- 1.0 (cos (* pi i)))))
	(if (= i 0)
	    (setf (aref arr k) 0.0)
	    (setf (aref arr k) (/ num denom)))))
    (<em class=red>make-fir-filter</em> arrlen (loop for i from 0 below arrlen collect (aref arr i)))))

(defmacro hilbert (f in) `(<em class=red>fir-filter</em> ,f ,in))
</pre>



<!--  DELAY  -->

<div class="innerheader">delay</div>

<pre class="indented">
<em class=def id="make-delay">make-delay</em> <a class=quiet href="#optional-key">&amp;optional-key</a> size initial-contents initial-element max-size type
<em class=def id="delay">delay</em> d input &amp;optional (pm 0.0)
<em class=def id="delay?">delay?</em> d
<em class=def id="tap">tap</em> d &amp;optional (offset 0)
<em class=def id="delaytick">delay-tick</em> d input
</pre>

<p><b>delay</b> is a delay line.  size is in samples.
Input fed into a delay line reappears at the output size samples
later.  initial-element defaults to 0.0. 
<b>tap</b> returns the
current value of the delay generator.  Its offset is the distance of the tap
from the current delay line sample.  If max-size is specified,
and larger than size, the delay line can provide fractional delays.
It should be large enough to accommodate the largest actual
delay requested at run-time.
pm determines how far from the normal index we are; that is,
it is difference between the nominal
delay length (size) and the current actual delay length (size
+ pm).  A positive pm corresponds to a longer
delay line.  The type argument sets the interpolation type:
mus-interp-none, mus-interp-linear, mus-interp-all-pass, 
mus-interp-lagrange, mus-interp-bezier, or mus-interp-hermite.
<b>delay-tick</b> just puts a sample in the delay line. 'ticks' the delay forward, and
returns its input argument.  This is aimed at physical modeling instruments
where a <b>tap</b> is doing the actual delay line read.
</p>

<table class="method">
<tr><td colspan=2 class="title">delay methods</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>      <td class="inner">length of delay</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>       <td class="inner">same as mus-length</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>        <td class="inner">delay line itself (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-interp-type</em></td> <td class="inner">interpolation choice (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>      <td class="inner">unused internally, but available for delay specializations</td></tr>
</table>

<pre class="indented">
delay:
(prog1
  (<a class=quiet href="#array-interp">array-interp</a> line (- loc pm))
  (setf (aref line loc) input)
  (incf loc)
  (if (&lt;= size loc) (setf loc 0)))
</pre>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> echo (beg dur scaler secs file)
  (let ((del (<em class=red>make-delay</em> (round (* secs *srate*))))
	(inf (<a class=quiet href="#open-input">open-input</a> file))
	(j 0))
    (run
     (loop for i from beg below (+ beg dur) do
       (let ((inval (<a class=quiet href="#ina">ina</a> j inf)))
	 (<a class=quiet href="#outa">outa</a> i (+ inval (<em class=red>delay</em> del (* scaler (+ (<em class=red>tap</em> del) inval)))))
	 (incf j))))
    (<a class=quiet href="#close-input">close-input</a> inf)))

;;; (<a class=quiet href="#with-sound">with-sound</a> () (echo 0 60000 .5 1.0 "pistol.snd"))
</pre>




<!--  COMB, NOTCH  -->

<div class="innerheader">comb and notch</div>

<pre class="indented">
<em class=def id="make-comb">make-comb</em> <a class=quiet href="#optional-key">&amp;optional-key</a> scaler size initial-contents initial-element max-size
<em class=def id="comb">comb</em> cflt input &amp;optional (pm 0.0)
<em class=def id="comb?">comb?</em> cflt

<em class=def id="make-filtered-comb">make-filtered-comb</em> <a class=quiet href="#optional-key">&amp;optional-key</a> scaler size initial-contents initial-element max-size filter
<em class=def id="filtered-comb">filtered-comb</em> cflt input &amp;optional (pm 0.0)
<em class=def id="filtered-comb?">filtered-comb?</em> cflt

<em class=def id="make-notch">make-notch</em> <a class=quiet href="#optional-key">&amp;optional-key</a> scaler size initial-contents initial-element max-size
<em class=def id="notch">notch</em> cflt input &amp;optional (pm 0.0)
<em class=def id="notch?">notch?</em> cflt
</pre>

<p><b>comb</b> is a delay line with a scaler on the feedback term.  <b>notch</b>
is a delay line with a scaler on the feedforward term.
size is the length
in samples of the delay line. 
Other arguments are handled as in <a href="#delay">delay</a>.
<b>filtered-comb</b> is a comb filter with a one-zero filter on the feedback.
</p>

<table class="method">
<tr><td colspan=2 class="title">comb, filtered-comb, and notch methods</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>        <td class="inner">length of delay</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>         <td class="inner">same as mus-length</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>          <td class="inner">delay line itself (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-feedback</em></td>      <td class="inner">scaler (comb only)</td></tr>
<tr><td class="inner"><em class=gen>mus-feedforward</em></td>   <td class="inner">scaler (notch only)</td></tr>
<tr><td class="inner"><em class=gen>mus-interp-type</em></td>   <td class="inner">interpolation choice (no setf)</td></tr>
</table>

<pre class="indented">
 comb:           y(n) = x(n - size) + scaler * y(n - size)
 notch:          y(n) = x(n) * scaler  + x(n - size)
 filtered-comb:  y(n) = x(n - size) + scaler * filter(y(n - size))
</pre>

<p>As a rule of thumb, the decay time of the feedback part is
7.0 * size / (1.0 - scaler) samples, so to get a decay of dur seconds,
scaler &lt;= 1.0 - 7.0 * size / (dur * *srate*).  The peak gain is 1.0 / (1.0 - (abs
scaler)).  The peaks (or valleys in notch's case) are evenly spaced
at *srate* / size. The height (or depth) thereof is determined by scaler &mdash;
the closer to 1.0, the more pronounced.
See Julius Smith's "An Introduction to Digital Filter Theory" in
Strawn "Digital Audio Signal Processing", or Smith's "Music Applications of
Digital Waveguides".
The following instrument sweeps the comb filter using the pm argument:
</p>

<pre class="indented">
(definstrument zc (time dur freq amp length1 length2 feedback)
  (multiple-value-bind
      (beg end) (times-&gt;samples time dur)
    (let ((s (<a class=quiet href="#make-pulse-train">make-pulse-train</a> :frequency freq))  ; some raspy input so we can hear the effect easily
          (d0 (<em class=red>make-comb</em> :size length1 :max-size (max length1 length2) :scaler feedback))
          (zenv (<a class=quiet href="#make-env">make-env</a> '(0 0 1 1) :scaler (- length2 length1) :duration dur)))
      (run
       (loop for i from beg to end do
	 (<a class=quiet href="#outa">outa</a> i (<em class=red>comb</em> d0 (* amp (<a class=quiet href="#pulse-train">pulse-train</a> s)) (<a class=quiet href="#env">env</a> zenv))))))))

(with-sound () (zc 0 3 100 .1 20 100 .5) (zc 3.5 3 100 .1 90 100 .95))
</pre>




<!--  ALL-PASS  -->

<div class="innerheader">all-pass</div>

<pre class="indented">
<em class=def id="make-all-pass">make-all-pass</em> <a class=quiet href="#optional-key">&amp;optional-key</a> feedback feedforward size initial-contents initial-element max-size
<em class=def id="all-pass">all-pass</em> f input &amp;optional (pm 0.0)
<em class=def id="all-pass?">all-pass?</em> f
</pre>

<p><b>all-pass</b> or moving average comb is just like <a href="#comb">comb</a> but with
an added feedforward term.  If feedforward = 0, we get a
comb filter.  If both scale terms = 0, we get a pure delay line. </p>

<table class="method">
<tr><td colspan=2 class="title">all-pass methods</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>       <td class="inner">length of delay</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>        <td class="inner">same as mus-length</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>         <td class="inner">delay line itself (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-feedback</em></td>     <td class="inner">feedback scaler</td></tr>
<tr><td class="inner"><em class=gen>mus-feedforward</em></td>  <td class="inner">feedforward scaler</td></tr>
<tr><td class="inner"><em class=gen>mus-interp-type</em></td>  <td class="inner">interpolation choice (no setf)</td></tr>
</table>

<pre class="indented">
 y(n) = feedforward * x(n) + x(n - size) + feedback * y(n - size)
</pre>

<p>all-pass filters are used extensively in reverberation; see jcrev.ins or nrev.ins for examples.
</p>



<!--  MOVING-AVERAGE  -->

<div class="innerheader">moving-average</div>

<pre class="indented">
<em class=def id="make-moving-average">make-moving-average</em> <a class=quiet href="#optional-key">&amp;optional-key</a> size initial-contents initial-element
<em class=def id="moving-average">moving-average</em> f input
<em class=def id="moving-average?">moving-average?</em> f
</pre>

<p><b>moving-average</b> or moving window average returns the average of the last 'size' values input to it.
This is used both to track rms values and to generate ramps between 0 and 1 in a "gate"
effect in new-effects.scm and in rms-envelope in env.scm (Snd).  It could also be viewed as a low-pass filter.
</p>

<table class="method">
<tr><td colspan=2 class="title">moving-average methods</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td> <td class="inner">length of table</td></tr>
<tr><td class="inner"><em class=gen>mus-order</em></td>  <td class="inner">same as mus-length</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>   <td class="inner">table of last 'size' values</td></tr>
</table>

<pre class="indented">
result = sum-of-last-n-inputs / n
</pre>

<p>moving-average is used in Snd's dsp.scm to implement several related functions:
moving-rms, moving-sum, and moving-length.  I might make these CLM generators someday.
</p>



<!--  SRC  -->

<div class="innerheader">src</div>
<!-- INDEX make-src:sampling-rate conversion -->

<pre class="indented">
<em class=def id="make-src">make-src</em> <a class=quiet href="#optional-key">&amp;optional-key</a> input (srate 1.0) (width 5)
<em class=def id="src">src</em> s &amp;optional (sr-change 0.0) input-function
<em class=def id="src?">src?</em> s
</pre>

<table class="method">
<tr><td colspan=2 class="title">src methods</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td><td class="inner">srate arg to make-src</td></tr>
</table>

<p><b>src</b> performs sampling rate conversion
by convolving its input with a sinc
function.
srate is the
ratio between the old sampling rate and the new; an srate of 2 causes the sound to be half as long, transposed up an octave.
width is how many neighboring samples to convolve with sinc.
If you hear high-frequency artifacts in the conversion, try increasing this number;
Perry Cook's default value is 40, and I've seen cases where it needs to be 100.
It can also be set as low as 2 in some cases.
The greater the width, the slower the src generator runs.
The sr-change
argument is the amount to add to the current srate on a sample by sample
basis (if it's 0.0 and the original make-src srate argument was also 0.0, you get a constant output because the generator is not moving at all).  Here's
an instrument that provides time-varying sampling rate conversion:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> simple-src (start-time duration amp srt srt-env filename)
  (let* ((senv (<a class=quiet href="#make-env">make-env</a> srt-env :duration duration))
         (beg (floor (* start-time *srate*)))
         (end (+ beg (floor (* duration *srate*))))
         (src-gen (<em class=red>make-src</em> :input filename :srate srt)))
    (run
      (loop for i from beg below end do
        (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>src</em> src-gen (<a class=quiet href="#env">env</a> senv))))))))
</pre>

<!-- here's a multichannel version:
(definstrument simple-src (start-time duration amp srt filename)
  (let* ((beg (floor (* start-time *srate*)))
         (end (+ beg (floor (* duration *srate*))))
	 (chans (min (mus-channels *output*) (mus-channels filename)))
	 (srcs (make-array chans)))
    (loop for i from 0 below chans do
      (setf (aref srcs i) (make-src :srate srt :input (make-file->sample :file filename :channel i))))
    (run
      (loop for i from beg below end do
        (loop for k from 0 below chans do
          (out-any i (* amp (src (aref srcs k))) k))))))


;(with-sound (:channels 2) (simple-src 0 2 .5 1.5 "/home/bil/cl/2.snd"))
-->

<p>src can provide an all-purpose "Forbidden Planet" sound effect:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> srcer (start-time duration amp srt fmamp fmfreq filename)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> :frequency fmfreq))
         (beg (floor (* start-time *srate*)))
         (end (+ beg (floor (* duration *srate*))))
         (src-gen (<em class=red>make-src</em> :input filename :srate srt)))
    (run
      (loop for i from beg below end do
        (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>src</em> src-gen (* fmamp (<a class=quiet href="#oscil">oscil</a> os)))))))))

(<a class=quiet href="#with-sound">with-sound</a> () (srcer 0 2 1.0   1 .3 20 "fyow.snd"))   
(<a class=quiet href="#with-sound">with-sound</a> () (srcer 0 25 10.0   .01 1 10 "fyow.snd"))
(<a class=quiet href="#with-sound">with-sound</a> () (srcer 0 2 1.0   .9 .05 60 "oboe.snd")) 
(<a class=quiet href="#with-sound">with-sound</a> () (srcer 0 2 1.0   1.0 .5 124 "oboe.snd"))
(<a class=quiet href="#with-sound">with-sound</a> () (srcer 0 10 10.0   .01 .2 8 "oboe.snd"))
(<a class=quiet href="#with-sound">with-sound</a> () (srcer 0 2 1.0   1 3 20 "oboe.snd"))    

(<a class=quiet href="#definstrument">definstrument</a> hello-dentist (beg dur file frq amp)
  (let ((rd (<em class=red>make-src</em> :input file))
        (rn (<a class=quiet href="#make-rand-interp">make-rand-interp</a> :frequency frq :amplitude amp))
        (end (+ beg dur)))
    (run
      (loop for i from beg below end do
        (<a class=quiet href="#outa">outa</a> i (<em class=red>src</em> rd (<a class=quiet href="#rand-interp">rand-interp</a> rn)))))))
</pre>

<p>The input argument to make-src and the input-function argument
to src provide the generator with input as it is needed. 
The input function
takes one argument (the desired read direction, if the reader can support it); it is funcall'd each time the src generator needs another
sample of input.  The input argument to src can also be an input file structure, as returned by
open-input, or as here, just the filename itself.
The simple-src instrument above could be written to use an input function instead:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> src-with-readin (start-time duration amp srt srt-env filename)
  (let* ((senv (<a class=quiet href="#make-env">make-env</a> srt-env :duration duration))
         (beg (floor (* start-time *srate*)))
	 (rd (<em class=red>make-readin</em> filename))
         (end (+ beg (floor (* duration *srate*))))
         (src-gen (<em class=red>make-src</em> :srate srt)))
    (run
      (loop for i from beg below end do
        (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>src</em> src-gen (<a class=quiet href="#env">env</a> senv) #'(lambda (dir) (<em class=red>readin</em> rd)))))))))
</pre>

<p>
If you jump around in the input (via <b>mus-location</b> for example), you can use the
<b>mus-reset</b> function to clear out any lingering state before starting to read at
the new position. (<b>src</b>, like many other generators, has an internal buffer
of recently read samples, so a sudden jump to a new location will otherwise cause
a click).
</p>




<!--  CONVOLVE  -->

<div class="innerheader">convolve</div>

<pre class="indented">
<em class=def id="make-convolve">make-convolve</em> <a class=quiet href="#optional-key">&amp;optional-key</a> input filter fft-size filter-size
 <em class=def id="convolve">convolve</em> ff &amp;optional input-function
 <em class=def id="convolve?">convolve?</em> ff
 <em class=def id="convolvefiles">convolve-files</em> file1 file2 &amp;optional (maxamp 1.0) (output-file "tmp.snd")
</pre>

<table class="method">
<tr><td colspan=2 class="title">convolve methods</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td><td class="inner">fft size used in the convolution</td></tr>
</table>

<p>
<b>convolve</b> convolves its input with the impulse response filter.
The filter argument 
can be
an array, the result of open-input, or a filename as a string.
When not file based,
input and input-function are functions of one argument (currently ignored) that are
funcall'd whenever convolve needs input.
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> convins (beg dur filter file &amp;optional (size 128))
  (let* ((start (floor (* beg *srate*)))
         (end (+ start (floor (* dur *srate*))))
         (ff (<em class=red>make-convolve</em> :input file :fft-size size :filter filter)))
    (run
      (loop for i from start below end do 
        (<a class=quiet href="#outa">outa</a> i (<em class=red>convolve</em> ff))))))
</pre>

<p><b>convolve-files</b> handles a very common special case: you often want to convolve
two files, normalizing the result to some maxamp.  The convolve generator does not
know in advance what its maxamp will be, and when the two files are more or less
the same size, there's no real computational savings to using overlap-add (i.e.
the generator), so a one-time giant FFT saved as a temporary sound file is much
handier.</p>



<!--  GRANULATE  -->

<div class="innerheader">granulate</div>
<!-- INDEX grains:Granular synthesis --><em class=def id="grains"></em>

<pre class="indented">
<em class=def id="make-granulate">make-granulate</em> <a class=quiet href="#optional-key">&amp;optional-key</a>   
        input
        (expansion 1.0)   ; how much to lengthen or compress the file
        (length .15)      ; length of file slices that are overlapped
        (scaler .6)       ; amplitude scaler on slices (to avoid overflows)
        (hop .05)         ; speed at which slices are repeated in output
        (ramp .4)         ; amount of slice-time spent ramping up/down
        (jitter 1.0)      ; affects spacing of successive grains
        max-size          ; internal buffer size
        edit              ; grain editing function (Scheme/Ruby, not CL)
<em class=def id="granulate">granulate</em> e &amp;optional input-function edit-function
<em class=def id="granulate?">granulate?</em> e
</pre>

<table class="method">
<tr><td colspan=2 class="title">granulate methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>   <td class="inner">time (seconds) between output grains (hop)</td></tr>
<tr><td class="inner"><em class=gen>mus-ramp</em></td>        <td class="inner">length (samples) of grain envelope ramp segment</td></tr>
<tr><td class="inner"><em class=gen>mus-hop</em></td>         <td class="inner">time (samples)  between output grains (hop)</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>      <td class="inner">grain amp (scaler)</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>   <td class="inner">expansion</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>      <td class="inner">grain length (samples)</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>        <td class="inner">grain samples (a vct)</td></tr>
<tr><td class="inner"><em class=gen>mus-location</em></td>    <td class="inner">granulate's local random number seed</td></tr>
</table>

<pre class="indented">
result = overlap add many tiny slices from input
</pre>

<p><b>granulate</b> "granulates" its input (normally a sound file).  It is the poor man's way
to change the speed at which things happen in a recorded sound without
changing the pitches.  It works by slicing the input file into short
pieces, then overlapping these slices to lengthen (or shorten) the
result; this process is sometimes known as granular synthesis, and is
similar to the freeze function.  
</p>

<p>The duration of each slice is
length &mdash; the longer the slice, the more like reverb the effect.  The
portion of the length (on a scale from 0 to 1.0) spent on each
ramp (up or down) is ramp.  This can control the smoothness of
the result of the overlaps. 
</p>

<p> 
jitter sets
the accuracy with which we hop.  If you set it to 0, you can get very strong
comb filter effects, or tremolo.
The more-or-less average time between
successive segments is hop.  
If jitter is 0.0, and hop is very small (say .01),
you're asking for trouble (a big comb filter).
If you're granulating more than one channel at a time, and want the channels to remain
in-sync, make each granulator use the same initial random number seed (via <b>mus-location</b>).
</p>

<p>The overall amplitude scaler on each segment is
scaler &mdash; this is used to try to avoid overflows as we add
all these zillions of segments together.  expansion
determines the input hop in relation to the output hop; an
expansion-amount of 2.0 should more or less double the length of the
original, whereas an expansion-amount of 1.0 should return something
close to the original speed.
input and input-function are the same as in src and convolve.
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> granulate-sound (file beg &amp;optional dur (orig-beg 0.0) (exp-amt 1.0))
  (let* ((f-srate (<a class=quiet href="#sound-srate">sound-srate</a> file))
	 (f-start (round (* f-srate orig-beg)))
         (f (<a class=quiet href="#open-input">open-input</a> file :start f-start))
	 (st (floor (* beg *srate*)))
	 (new-dur (or dur (- (<a class=quiet href="#sound-duration">sound-duration</a> file) orig-beg)))
	 (exA (<em class=red>make-granulate</em> :input f :expansion exp-amt))
	 (nd (+ st (floor (* *srate* new-dur)))))
    (run
     (loop for i from st below nd do
       (<a class=quiet href="#outa">outa</a> i (<em class=red>granulate</em> exA))))
    (<a class=quiet href="#close-input">close-input</a> f)))
</pre>

<p>See expsrc.ins.  Here's an instrument that uses the input-function
argument to granulate.  It cause the granulation to run backwards through the file:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> grev (beg dur exp-amt file file-beg)
  (let* ((exA (<em class=red>make-granulate</em> :expansion exp-amt))
	 (fil (<a class=quiet href="#open-input*">open-input*</a> file file-beg))
	 (ctr file-beg))
    (run
     (loop for i from beg to (+ beg dur) do
       (<a class=quiet href="#outa">outa</a> i (<em class=red>granulate</em> exA
			  #'(lambda (dir)
			      (let ((inval (<a class=quiet href="#ina">ina</a> ctr fil)))
				(if (&gt; ctr 0) (setf ctr (1- ctr)))
				inval))))))
    (<a class=quiet href="#close-input">close-input</a> fil)))

(<a class=quiet href="#with-sound">with-sound</a> () (grev 0 100000 2.0 "pistol.snd" 40000))
</pre>

<p>
The edit argument can
be a function of one argument, the current granulate generator.  It is called just before
a grain is added into the output buffer. The current grain is accessible via mus-data.
The edit function, if any, should return the length in samples of the grain, or 0.
</p>



<!--  PHASE-VOCODER  -->

<div class="innerheader">phase-vocoder</div>

<pre class="indented">
<em class=def id="make-phase-vocoder">make-phase-vocoder</em> <a class=quiet href="#optional-key">&amp;optional-key</a> input (fft-size 512) (overlap 4) interp (pitch 1.0) analyze edit synthesize
<em class=def id="phase-vocoder">phase-vocoder</em> pv input-function analyze-function edit-function synthesize-function
<em class=def id="phase-vocoder?">phase-vocoder?</em> pv
</pre>

<table class="method">
<tr><td colspan=2 class="title">phase-vocoder methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">pitch shift</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">fft-size</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">interp</td></tr>
<tr><td class="inner"><em class=gen>mus-hop</em></td>        <td class="inner">fft-size / overlap</td></tr>
<tr><td class="inner"><em class=gen>mus-location</em></td>   <td class="inner">outctr (counter to next fft)</td></tr>
</table>

<p>phase-vocoder provides a generator to perform phase-vocoder analysis and resynthesis.  The process is
split into three pieces, the analysis stage, editing of the amplitudes and phases, then the resynthesis.
Each stage has a default that is invoked if the analyze, edit, or synthesize
arguments are omitted from make-phase-vocoder or the phase-vocoder generator.  The edit and synthesize arguments are functions of one argument, the
phase-vocoder generator.  The analyze argument is a function of two arguments, the generator and
the input function. The default is to read the current input,
take an fft, get the new amplitudes and phases (as the edit
function default), then resynthesize using sines; so, the
default case returns a resynthesis of the original input.  interp sets the time between
ffts (for time stretching etc). 
</p>

<pre class="indented">
(definstrument simple-pvoc (beg dur amp size file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (sr (<em class=red>make-phase-vocoder</em> file :fft-size size)))
      (run
       (loop for i from start to end do
	 (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>phase-vocoder</em> sr)))))))
</pre>

<p>See ug3.ins for instruments that use the various function arguments.  In Snd, clm23.scm
has a variety of instruments calling the phase-vocoder generator, including pvoc-e that
specifies all of the functions with their default values (that is, it explicitly passes
in functions that do what the phase-vocoder would have done without any function arguments).
</p>



<!--  NRXYCOS, NRXYSIN  -->

<div class="innerheader">nrxycos and nrxysin</div>

<pre class="indented">
<em class=def id="make-nrxysin">make-nrxysin</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (ratio 1.0) (n 1) (r .5)
<em class=def id="nrxysin">nrxysin</em> s &amp;optional (fm 0.0)
<em class=def id="nrxysin?">nrxysin?</em> s

<em class=def id="make-nrxycos">make-nrxycos</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (ratio 1.0) (n 1) (r .5)
<em class=def id="nrxycos">nrxycos</em> s &amp;optional (fm 0.0)
<em class=def id="nrxycos?">nrxycos?</em> s
</pre>

<table class="method">
<tr><td colspan=2 class="title">nrxysin methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>      <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>     <td class="inner">"a" parameter; sideband scaler</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">"n" parameter</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">frequency in radians per sample</td></tr>
<tr><td class="inner"><em class=gen>mus-offset</em></td>     <td class="inner">"ratio" parameter</td></tr>
</table>

<pre class="indented">
(/ (- (sin phase) (* a (sin (- phase (* ratio phase))))
      (* (expt a (1+ n)) (- (sin (+ phase (* (+ N 1) (* ratio phase))))
			    (* a (sin (+ phase (* N (* ratio phase))))))))
   (- (+ 1 (* a a)) (* 2 a (cos (* ratio phase)))))
</pre>

<p>These three generators 
produce a kind of additive synthesis.
"n" is the number of sidebands (0 gives a sine wave), "r" is the amplitude
ratio between successive sidebands (don't set it to 1.0), and "ratio" is the ratio between the
carrier frequency and the spacing between successive sidebands.
A "ratio" of 2 gives odd-numbered harmonics for a (vaguely) clarinet-like sound.
The basic idea is very similar to that used in the
<a href="#ncos">ncos</a> generator, but you have control of the
fall-off of the spectrum and the spacing of the partials.
</p>

<p>The peak amplitude of the nrxysin is hard to predict.
I think nrxysin is close to the -1.0..1.0 ideal, and won't go over 1.0.
<a href="#nrxycos">nrxycos</a> is normalized correctly.
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> ss (beg dur freq amp &amp;optional (n 1) (r 0.5) (ratio 1.0))
  (let* ((st (floor (* *srate* beg)))
         (nd (+ st (floor (* *srate* dur))))
         (sgen (<em class=red>make-nrxycos</em> freq ratio n r)))
    (run
     (loop for i from st below nd do
       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>nrxycos</em> sgen)))))))
</pre>




<!--  ASYMMETRIC-FM  -->

<div class="innerheader">asymmetric-fm</div>

<pre class="indented">
<em class=def id="make-asymmetric-fm">make-asymmetric-fm</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (frequency 0.0) (initial-phase 0.0) (r 1.0) (ratio 1.0)
<em class=def id="asymmetric-fm">asymmetric-fm</em> af index &amp;optional (fm 0.0)
<em class=def id="asymmetric-fm?">asymmetric-fm?</em> af
</pre>

<table class="method">
<tr><td colspan=2 class="title">asymmetric-fm methods</td></tr>
<tr><td class="inner"><em class=gen>mus-frequency</em></td>  <td class="inner">frequency in Hz</td></tr>
<tr><td class="inner"><em class=gen>mus-phase</em></td>      <td class="inner">phase in radians</td></tr>
<tr><td class="inner"><em class=gen>mus-scaler</em></td>     <td class="inner">"r" parameter; sideband scaler</td></tr>
<tr><td class="inner"><em class=gen>mus-offset</em></td>     <td class="inner">"ratio" parameter</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">frequency in radians per sample</td></tr>
</table>

<pre class="indented">
(* (exp (* index (* 0.5 (- r (/ 1.0 r)))
	   (cos (* ratio phase))))
   (sin (+ phase (* index (* 0.5 (+ r (/ 1.0 r)))
		    (sin (* ratio phase))))))
</pre>

<p><b>asymmetric-fm</b> provides a way around the symmetric spectra normally produced by FM.
See  Palamin and Palamin, "A Method of Generating and Controlling Asymmetrical
Spectra" JAES vol 36, no 9, Sept 88, p671-685.
The generator's output amplitude is not always easy to predict.  r is the ratio between successive 
sideband amplitudes, r &gt; 1.0 pushes energy above the carrier, r &lt; 1.0 pushes it below. (r = 1.0
gives normal FM). ratio
is the ratio between the carrier and modulator (i.e. sideband spacing). It's somewhat inconsistent
that asymmetric-fm takes index (the fm-index) as its second argument, but otherwise it
would be tricky to get time-varying indices.
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> asy (beg dur freq amp index &amp;optional (r 1.0) (ratio 1.0))
  (let* ((st (floor (* beg *srate*)))
         (nd (+ st (floor (* dur *srate*))))
         (asyf (<em class=red>make-asymmetric-fm</em> :r r :ratio ratio :frequency freq)))
    (run
     (loop for i from st below nd do
       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>asymmetric-fm</em> asyf index 0.0)))))))
</pre>

<p>For the other kind of asymmetric-fm, and for asymmetric spectra via "single sideband FM", see dsp.scm in Snd.
</p>




<div class="innerheader">Other generators</div>

<p>There are a number of other generators in the CLM distribution that aren't
loaded by default.  Among these are:</p>

<pre class="indented">
  <a href="balance.html#rms">rms</a>         ; trace the rms of signal
  <a href="balance.html#gain">gain</a>        ; modify signal to match rms power
  <a href="balance.html#balance">balance</a>     ; combination of rms and gain
</pre>

<p>
green.cl defines several special purpose noise generators.
butterworth.cl has several Butterworth filters.  
(See analog-filter.scm in the Snd package for functions to design all the usual analog filters;
the output is compatible with the Scheme version of CLM's filter generator).
</p>

<div class="innerheader" id="generic-functions">generic functions</div>

<p>The generators have internal state that is sometimes of interest at run-time.  To get or
set this state, use these functions (they are described in conjunction with the associated generators):</p>

<table class="spaced">
<tr><td class="bluish"><em class=def id="mus-channel">mus-channel</em></td><td class="bluish">channel being read/written</td></tr>
<tr><td><em class=def id="mus-channels">mus-channels</em></td><td>channels open</td></tr>
<tr><td><em class=def id="mus-data">mus-data</em></td><td>array of data</td></tr>
<tr><td class="bluish"><em class=def id="mus-describe">mus-describe</em></td><td class="bluish">description of current state</td></tr>
<tr><td><em class=def id="mus-feedback">mus-feedback</em></td><td>feedback coefficient</td></tr>
<tr><td class="bluish"><em class=def id="mus-feedforward">mus-feedforward</em></td><td class="bluish">feedforward coefficient</td></tr>
<tr><td><em class=def id="mus-file-name">mus-file-name</em></td><td>file being read/written</td></tr>
<tr><td><em class=def id="mus-frequency">mus-frequency</em></td><td>frequency (Hz)</td></tr>
<tr><td class="bluish"><em class=def id="mus-hop">mus-hop</em></td><td class="bluish">hop size for block processing</td></tr>
<tr><td><em class=def id="mus-increment">mus-increment</em></td><td>various increments</td></tr>
<tr><td class="bluish"><em class=def id="mus-interp-type">mus-interp-type</em></td><td class="bluish">interpolation type (mus-interp-linear, etc)</td></tr>
<tr><td><em class=def id="mus-length">mus-length</em></td><td>data array length</td></tr>
<tr><td class="bluish"><em class=def id="mus-location">mus-location</em></td><td class="bluish">sample location for reads/writes</td></tr>
<tr><td><em class=def id="mus-name">mus-name</em></td><td>generator name ("oscil")</td></tr>
<tr><td class="bluish"><em class=def id="mus-offset">mus-offset</em></td><td class="bluish">envelope offset</td></tr>
<tr><td><em class=def id="mus-order">mus-order</em></td><td>filter order</td></tr>
<tr><td class="bluish"><em class=def id="mus-phase">mus-phase</em></td><td class="bluish">phase (radians)</td></tr>
<tr><td><em class=def id="mus-ramp">mus-ramp</em></td><td>granulate grain envelope ramp setting</td></tr>
<tr><td class="bluish"><em class=def id="mus-reset">mus-reset</em></td><td class="bluish">set gen to default starting state</td></tr>
<tr><td><em class=def id="mus-run">mus-run</em></td><td>run any generator</td></tr>
<tr><td class="bluish"><em class=def id="mus-scaler">mus-scaler</em></td><td class="bluish">scaler, normally on an amplitude</td></tr>
<tr><td><em class=def id="mus-width">mus-width</em></td><td>width of interpolation tables, etc</td></tr>
<tr><td class="bluish"><em class=def id="mus-xcoeff">mus-xcoeff</em></td><td class="bluish">x (input) coefficient</td></tr>
<tr><td><em class=def id="mus-xcoeffs">mus-xcoeffs</em></td><td>array of x (input) coefficients</td></tr>
<tr><td class="bluish"><em class=def id="mus-ycoeff">mus-ycoeff</em></td><td class="bluish">y (output, feedback) coefficient</td></tr>
<tr><td><em class=def id="mus-ycoeffs">mus-ycoeffs</em></td><td>array of y (feedback) coefficients</td></tr>
</table>

<p>Many of these are settable:
<code>(setf (mus-frequency osc1) 440.0)</code>
sets osc1's current frequency to (<a class=quiet href="#hztoradians">hz-&gt;radians</a> 440.0). 
</p>

<pre class="indented">
(definstrument backandforth (onset duration file src-ratio)
  ;; read file forwards and backwards until dur is used up
  ;; a slightly improved version is 'scratch' in ug1.ins
  (let* ((last-sample (<a class=quiet href="#sound-framples">sound-framples</a> file))
         (beg (floor (* *srate* onset)))
         (end (+ beg (floor (* *srate* duration))))
	 (input (<a class=quiet href="#make-readin">make-readin</a> file))
         (s (<a class=quiet href="#make-src">make-src</a> :srate src-ratio))
         (cs 0))
    (run
     (loop for i from beg below end do
       (declare (type :integer cs last-sample)
		(type :float src-ratio))
       (if (&gt;= cs last-sample) (setf (<em class=red>mus-increment</em> s) (- src-ratio)))
       (if (&lt;= cs 0) (setf (<em class=red>mus-increment</em> s) src-ratio))
       (<a class=quiet href="#outa">outa</a> i (<a class=quiet href="#src">src</a> s 0.0 #'(lambda (dir) 
			      (incf cs dir)
			      (setf (<em class=red>mus-increment</em> input) dir)
			      (<a class=quiet href="#readin">readin</a> input))))))))

;;; (with-sound () (backandforth 0 10 "pistol.snd" 2.0))
</pre>




<!--  IN-ANY/OUT-ANY  -->

<div class="innerheader" id="soundio">Sound IO</div>

<p>Sound file IO is supported by a variety of functions.  To read and write sound files into an
array, use <b>array-&gt;file</b> and <b>file-&gt;array</b>.  
Within the run-loop, <b>out-any</b>, <b>in-any</b>, and <b>readin</b>
are the simplest input and output generators; <b>locsig</b> provides a sort of sound placement; <b>dlocsig</b> provides
moving sound placement.  When you use with-sound, the variable <b>*output*</b> is bound to a <b>sample-&gt;file</b>
object, so output by default goes to with-sound's output file. You can open (for reading or
writing) any sound files via <b>make-file-&gt;sample</b> (or -&gt;frample), and <b>make-sample-&gt;file</b>
(or frample-&gt;).  These return an IO object which you subsequently pass to <b>file-&gt;sample</b>
(for input) and <b>sample-&gt;file</b> (for output).  To close the connection to the file system,
you can use <b>mus-close</b>, but it's also called automatically during garbage collection, if needed.
</p>

<table class="spaced">
<tr><td><em class=def id="mus-input?">mus-input?</em><code> obj</code></td><td>t if obj performs sound input</td></tr>
<tr><td><em class=def id="mus-output?">mus-output?</em><code> obj</code></td><td>t if obj performs sound output</td></tr>
<tr><td><em class=def id="filetosample?">file-&gt;sample?</em><code> obj</code></td><td>t if obj reads a sound file returning a sample</td></tr>
<tr><td><em class=def id="sampletofile?">sample-&gt;file?</em><code> obj</code></td><td>t if obj writes a sample to a sound file</td></tr>
<tr><td><em class=def id="frampletofile?">frample-&gt;file?</em><code> obj</code></td><td>t if obj writes a frample to a sound file</td></tr>
<tr><td><em class=def id="filetoframple?">file-&gt;frample?</em><code> obj</code></td><td>t if obj reads a sound file returning a frample</td></tr>
<tr><td></td><td></td></tr>
<tr><td><em class=def id="make-filetosample">make-file-&gt;sample</em><code> name buffer-size</code></td><td>return gen that reads samples from sound file name</td></tr>
<tr><td><em class=def id="make-sampletofile">make-sample-&gt;file</em><code> name &amp;optional chans format type comment</code></td><td>return gen that writes samples to sound file name</td></tr>
<tr><td><em class=def id="make-filetoframple">make-file-&gt;frample</em><code> name buffer-size</code></td><td>return gen that reads framples from sound file name</td></tr>
<tr><td><em class=def id="make-frampletofile">make-frample-&gt;file</em><code> name &amp;optional chans format type comment</code></td><td>return gen that writes framples to sound file name</td></tr>
<tr><td><em class=def id="filetosample">file-&gt;sample</em><code> obj samp &amp;optional chan</code></td><td>return sample at samp in channel chan</td></tr>
<tr><td><em class=def id="sampletofile">sample-&gt;file</em><code> obj samp chan val</code></td><td>write (add) sample val at samp in channel chan</td></tr>
<tr><td><em class=def id="filetoframple">file-&gt;frample</em><code> obj samp &amp;optional outf</code></td><td>return frample at samp</td></tr>
<tr><td><em class=def id="frampletofile">frample-&gt;file</em><code> obj samp val</code></td><td>write (add) frample val at samp</td></tr>
<tr><td></td><td></td></tr>
<tr><td><em class=def id="filetoarray">file-&gt;array</em><code> file channel beg dur array</code></td><td>read samples from file into array</td></tr>
<tr><td><em class=def id="arraytofile">array-&gt;file</em><code> file data len srate channels </code></td><td>write samples in array to file</td></tr>
<tr><td></td><td></td></tr>
<tr><td><em class=def id="continue-frampletofile">continue-frample-&gt;file</em><code> file</code></td><td>reopen file for more output</td></tr>
<tr><td><em class=def id="continue-sampletofile">continue-sample-&gt;file</em><code> file</code></td><td>reopen file for more output</td></tr>
<tr><td><em class=def id="mus-close">mus-close</em><code> obj</code></td><td>close the output file associated with obj</td></tr>
</table>


<!-- INDEX ina-outa:Input and output --><em class=def id="ina-outa"></em>
<div class="innerheader">out-any</div>

<pre class="indented">
<em class=def id="outa">outa</em> loc data
<em class=def id="out-any">out-any</em> loc data &amp;optional (channel 0) (o-stream *output*)
</pre>

<p><b>out-any</b> adds data into o-stream at sample
position loc.  O-stream defaults to the current output
file (it is a frample-&gt;file instance, not a file name).  The reverb stream, if any,
is named *reverb*; the direct output is *output*.
You can output anywhere at any time, but because of the way data is buffered internally, your
instrument will run much faster if it does sequential output.
<a href="#locsig">Locsig</a> is another output function.</p>

<p>Many of the CLM examples and instruments use <b>outa</b> and <b>outb</b>.
These are macros equivalent to <code>(out-any loc data 0 *output*)</code> etc.
</p>



<div class="innerheader">in-any</div>

<pre class="indented">
<em class=def id="in-any">in-any</em> loc channel i-stream
<em class=def id="ina">ina</em> loc
</pre>

<p><b>in-any</b> returns the sample at position loc in
i-stream as a float.
Many of the CLM examples and instruments use <b>ina</b> and <b>inb</b>; one example is
the digital zipper instrument <a href="zipper.ins">zipper.ins</a>.
</p>

<pre class="indented">
(definstrument simple-ina (beg dur amp file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (fil (<em class=red>open-input</em> file)))          ; actually make-file-&gt;sample
    (run
     (loop for i from start to end do
       (<a class=quiet href="#outa">outa</a> i (* amp (<em class=red>in-any</em> i 0 fil))))) ; actually file-&gt;sample
    (close-input fil)))
</pre>




<!--  READIN  -->

<div class="innerheader">readin</div>

<pre class="indented">
 <em class=def id="make-readin">make-readin</em> <a class=quiet href="#optional-key">&amp;optional-key</a> file (channel 0) start (direction 1)
 <em class=def id="readin">readin</em> rd
 <em class=def id="readin?">readin?</em> rd
</pre>

<table class="method">
<tr><td colspan=2 class="title">readin methods</td></tr>
<tr><td class="inner"><em class=gen>mus-channel</em></td>    <td class="inner">channel arg to make-readin (no setf)</td></tr>
<tr><td class="inner"><em class=gen>mus-location</em></td>   <td class="inner">current location in file</td></tr>
<tr><td class="inner"><em class=gen>mus-increment</em></td>  <td class="inner">sample increment (direction arg to make-readin)</td></tr>
<tr><td class="inner"><em class=gen>mus-file-name</em></td>  <td class="inner">name of file associated with gen</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>     <td class="inner">number of framples in file associated with gen</td></tr>
</table>

<p><b>readin</b> returns successive samples from file.
file should be either an IO instance, as returned by <a href="#open-input">open-input</a>, 
or a filename.
start is the frample at which to start reading file. 
channel is which channel to read (0-based).
size is the read buffer size in samples.  It defaults to <b>*clm-file-buffer-size*</b>.
Here is an instrument that applies an envelope to a sound file using
readin and <a href="#env">env</a> (see also the fullmix instrument in fullmix.ins):
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> env-sound (file beg &amp;optional (amp 1.0) (amp-env '(0 1 100 1)))
  (let* ((st (floor (* beg *srate*)))
         (dur (<a class=quiet href="#sound-duration">sound-duration</a> file))
         (rev-amount .01)
         (rdA (<em class=red>make-readin</em> file))
         (ampf (<a class=quiet href="#make-env">make-env</a> amp-env amp dur))
         (nd (+ st (floor (* *srate* dur)))))
    (run
      (loop for i from st below nd do
        (let ((outval (* (<a class=quiet href="#env">env</a> ampf) (<em class=red>readin</em> rdA))))
  	  (<a class=quiet href="#outa">outa</a> i outval)
	  (if *reverb* (<a class=quiet href="#outa">outa</a> i (* outval rev-amount) *reverb*)))))))
</pre>




<!--  LOCSIG  -->

<!-- INDEX make-locsig:Sound placement -->

<div class="innerheader">locsig</div>

<pre class="indented">
 <em class=def id="make-locsig">make-locsig</em> <a class=quiet href="#optional-key">&amp;optional-key</a> (degree 0.0) (distance 1.0) (reverb 0.0) channels (type *clm-locsig-type*)
 <em class=def id="locsig">locsig</em> loc i in-sig
 <em class=def id="locsig?">locsig?</em> loc
 <em class=def id="locsig-ref">locsig-ref</em> loc chan
 <em class=def id="locsig-set!">locsig-set!</em> loc chan val
 <em class=def id="locsig-reverb-ref">locsig-reverb-ref</em> loc chan
 <em class=def id="locsig-reverb-set!">locsig-reverb-set!</em> loc chan val
 <em class=def id="move-locsig">move-locsig</em> loc degree distance
 <em class=def id="locsig-type">locsig-type</em> ()
</pre>

<table class="method">
<tr><td colspan=2 class="title">locsig methods</td></tr>
<tr><td class="inner"><em class=gen>mus-data</em></td>     <td class="inner">output scalers (a vct)</td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeff</em></td>   <td class="inner">reverb scaler</td></tr>
<tr><td class="inner"><em class=gen>mus-xcoeffs</em></td>  <td class="inner">reverb scalers (a vct)</td></tr>
<tr><td class="inner"><em class=gen>mus-channels</em></td> <td class="inner">output channels</td></tr>
<tr><td class="inner"><em class=gen>mus-length</em></td>   <td class="inner">output channels</td></tr>
</table>

<p><b>locsig</b> normally takes the place of <a href="#outa">out-any</a> in an
instrument.  It tries to place a signal between channels 0 and 1 (or 4 channels placed in a circle) in
an extremely dumb manner: it just scales the respective amplitudes
("that old trick never works").  reverb determines how much of
the direct signal gets sent to the reverberator.  distance tries to
imitate a distance cue by fooling with the relative amounts of direct and
reverberated signal (independent of reverb).  distance should
be greater than or equal to 1.0.  
type (returned by the function <b>locsig-type</b>) can be <b>mus-interp-linear</b> (the default) or <b>mus-interp-sinusoidal</b>.
This parameter can be set globally via <b>*clm-locsig-type*</b>.  The mus-interp-sinusoidal
case uses sin and cos to set the respective channel amplitudes (this is reported to
help with the "hole-in-the-middle" problem).
</p>

<p>Locsig is a
kludge, but then so is any pretence of placement when you're piping the signal
out a loudspeaker.  It is my current belief that locsig does the right
thing for all the wrong reasons; a good concert hall provides auditory
spaciousness by interfering with the ear's attempt to localize a sound.
A diffuse sound source is the ideal!  By sending an arbitrary mix of
signal and reverberation to various speakers, locsig gives you a very
diffuse source; it does the opposite of what it claims to do, and by
some perversity of Mother Nature, that is what you want.  (See "Binaural
Phenomena" by J Blauert).
</p>

<p>Locsig can send output to any number of channels.
If channels &gt; 2, the speakers are assumed to be evenly spaced in
a circle.
You can use <b>locsig-set!</b> and <b>locsig-ref</b> to override the placement decisions.
To have full output to both channels,</p>

<pre class="indented">
(setf (locsig-ref loc 0) 1.0) ; or (<a class=quiet href="#locsig-set!">locsig-set!</a> loc 0 1.0)
(setf (locsig-ref loc 1) 1.0)
</pre>

<p>These locations can be set via envelopes and so on within the run
loop to pan between speakers (but see move-locsig below):</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> space (file onset duration &amp;key (distance-env '(0 1 100 10)) (amplitude-env '(0 1 100 1))
		     (degree-env '(0 45 50 0 100 90)) (reverb-amount .05))
  (let* ((beg (floor (* onset *srate*)))
	 (end (+ beg (floor (* *srate* duration))))
         (loc (<em class=red>make-locsig</em> :degree 0 :distance 1 :reverb reverb-amount))
         (rdA (<a class=quiet href="#make-readin">make-readin</a> :file file))
         (dist-env (<a class=quiet href="#make-env">make-env</a> distance-env :duration duration))
         (amp-env (<a class=quiet href="#make-env">make-env</a> amplitude-env :duration duration))
         (deg-env (<a class=quiet href="#make-env">make-env</a> (scale-envelope degree-env (/ 1.0 90.0)) :duration duration))
         (dist-scaler 0.0))
    (run
      (loop for i from beg below end do
        (let ((rdval (* (<a class=quiet href="#readin">readin</a> rdA) (<a class=quiet href="#env">env</a> amp-env)))
	      (degval (<a class=quiet href="#env">env</a> deg-env))
	      (distval (<a class=quiet href="#env">env</a> dist-env)))
          (setf dist-scaler (/ 1.0 distval))
          (setf (<em class=red>locsig-ref</em> loc 0) (* (- 1.0 degval) dist-scaler))
          (if (&gt; (<a class=quiet href="#mus-channels">mus-channels</a> *output*) 1) (setf (<em class=red>locsig-ref</em> loc 1) (* degval dist-scaler)))
          (when *reverb* (setf (<em class=red>locsig-reverb-ref</em> loc 0) (* reverb-amount (sqrt dist-scaler))))
          (<em class=red>locsig</em> loc i rdval))))))
</pre>

<p>For a moving sound
source, see either move-locsig, or Fernando Lopez Lezcano's <a class=def href="http://ccrma.stanford.edu/~nando/clm/dlocsig/index.html">dlocsig</a>.
Here is an example of move-locsig:
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> move-osc (start dur freq amp &amp;key (degree 0) (dist 1.0) (reverb 0))
  (let* ((beg (floor (* start *srate*)))
         (end (+ beg (floor (* dur *srate*))) )
         (car (<a class=quiet href="#make-oscil">make-oscil</a> :frequency freq))
         (loc (<a class=quiet href="#make-locsig">make-locsig</a> :degree degree :distance dist :channels 2))
	 (pan-env (<a class=quiet href="#make-env">make-env</a> '(0 0 1 90) :duration dur)))
    (run
     (loop for i from beg to end do
       (let ((ut (* amp (<a class=quiet href="#oscil">oscil</a> car))))
	 (<em class=red>move-locsig</em> loc (<a class=quiet href="#env">env</a> pan-env) dist)
         (<a class=quiet href="#locsig">locsig</a> loc i ut))))))
</pre>




<!--  MOVE-SOUND  -->

<div class="innerheader">move-sound</div>

<pre class="indented">
 <em class=def id="make-move-sound">make-move-sound</em> dlocs-list (output *output*) (revout *reverb*)
 <em class=def id="move-sound">move-sound</em> dloc i in-sig
 <em class=def id="move-sound?">move-sound?</em> dloc
</pre>

<p><b>move-sound</b> is intended as the run-time portion of dlocsig.  make-dlocsig (described in
<a href="dlocsig.html">dlocsig.html</a>) creates a move-sound structure, passing it to the move-sound generator inside the
dlocsig macro.  All the necessary data is packaged up in a list:
</p>

<pre class="indented">
(list
  (start 0)               ; absolute sample number at which samples first reach the listener
  (end 0)                 ; absolute sample number of end of input samples
  (out-channels 0)        ; number of output channels in soundfile
  (rev-channels 0)        ; number of reverb channels in soundfile
  path                    ; interpolated delay line for doppler
  delay                   ; tap doppler env
  rev                     ; reverberation amount
  out-delays              ; delay lines for output channels that have additional delays
  gains                   ; gain envelopes, one for each output channel
  rev-gains               ; reverb gain envelopes, one for each reverb channel
  out-map)                ; mapping of speakers to output channels
</pre>

<p>Here's an instrument that uses this generator to pan a sound through four channels:
</p>

<pre class="indented">
(definstrument simple-dloc (beg dur freq amp)
  (let* ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (loc (<em class=red>make-move-sound</em> (list start end 4 0
				     (<a class=quiet href="#make-delay">make-delay</a> 12) 
				     (<a class=quiet href="#make-env">make-env</a> '(0 0 10 1) :duration dur)
				     (<a class=quiet href="#make-env">make-env</a> '(0 0 1 0) :duration dur)
				     (make-array 4 :initial-element nil)
				     (make-array 4 :initial-contents 
				       (list
					(<a class=quiet href="#make-env">make-env</a> '(0 0 1 1 2 0 3 0 4 0) :duration dur)
					(<a class=quiet href="#make-env">make-env</a> '(0 0 1 0 2 1 3 0 4 0) :duration dur)
					(<a class=quiet href="#make-env">make-env</a> '(0 0 1 0 2 0 3 1 4 0) :duration dur)
					(<a class=quiet href="#make-env">make-env</a> '(0 0 1 0 2 0 3 0 4 1) :duration dur)))
				     nil
				     (make-integer-array 4 :initial-contents (list 0 1 2 3))))))
    (run
     (loop for i from start to end do
       (<em class=red>move-sound</em> loc i (* amp (<a class=quiet href="#oscil">oscil</a> os)))))))
</pre>



<div class="innerheader" id="functions">Useful functions</div>

<p>There are several commonly-used functions, some of which can occur in the run macro. These include
a few that look for all the world like generators.</p>

<table class="spaced">
<tr><td><em class=def id="hztoradians">hz-&gt;radians</em><code> freq</code></td><td>convert freq to radians per sample</td></tr>
<tr><td><em class=def id="radianstohz">radians-&gt;hz</em><code> rads</code></td><td>convert rads to Hz</td></tr>
<tr><td><em class=def id="dbtolinear">db-&gt;linear</em><code> dB</code></td><td>convert dB to linear value</td></tr>
<tr><td><em class=def id="lineartodb">linear-&gt;db</em><code> val</code></td><td>convert val to dB</td></tr>
<tr><td><em class=def id="timestosamples">times-&gt;samples</em><code> start duration</code></td><td>convert start and duration from seconds to samples (beg+dur in latter case)</td></tr>
<tr><td><em class=def id="samplestoseconds">samples-&gt;seconds</em><code> samps</code></td><td>convert samples to seconds</td></tr>
<tr><td><em class=def id="secondstosamples">seconds-&gt;samples</em><code> secs</code></td><td>convert seconds to samples</td></tr>
<tr><td><em class=def id="degreestoradians">degrees-&gt;radians</em><code> degs</code></td><td>convert degrees to radians</td></tr>
<tr><td><em class=def id="radianstodegrees">radians-&gt;degrees</em><code> rads</code></td><td>convert radians to degrees</td></tr>
<tr><td><em class=def id="clear-array">clear-array</em><code> arr</code></td><td>set all values in arr to 0.0</td></tr>
<tr><td><em class=def id="sound-samples">sound-samples</em><code> filename</code></td><td>samples of sound according to header (can be incorrect)</td></tr>
<tr><td><em class=def id="sound-framples">sound-framples</em><code> filename</code></td><td>number of framples (number of samples / channels)</td></tr>
<tr><td><em class=def id="sound-datum-size">sound-datum-size</em><code> filename</code></td><td>bytes per sample</td></tr>
<tr><td><em class=def id="sound-data-location">sound-data-location</em><code> filename</code></td><td>location of first sample (bytes)</td></tr>
<tr><td><em class=def id="sound-chans">sound-chans</em><code> filename</code></td><td>number of channels (samples are interleaved)</td></tr>
<tr><td><em class=def id="sound-srate">sound-srate</em><code> filename</code></td><td>sampling rate</td></tr>
<tr><td><em class=def id="sound-header-type">sound-header-type</em><code> filename</code></td><td>header type (aiff etc)</td></tr>
<tr><td><em class=def id="sound-data-format">sound-data-format</em><code> filename</code></td><td>data format (alaw etc)</td></tr>
<tr><td><em class=def id="sound-length">sound-length</em><code> filename</code></td><td>true file length (for error checks)</td></tr>
<tr><td><em class=def id="sound-duration">sound-duration</em><code> filename</code></td><td>file length in seconds</td></tr>
<tr><td><em class=def id="sound-maxamp">sound-maxamp</em><code> name vals</code></td><td>get max amp vals and times of file name</td></tr>
<tr><td><em class=def id="sound-loop-info">sound-loop-info</em><code> name vals</code></td><td>get loop info of file name in vals (make-integer-array 6)</td></tr>
</table>

<p>
<b>hz-&gt;radians</b>
converts its argument to radians/sample (for any situation where a
frequency is used as an amplitude, glissando or FM).  It
can be used within run. hz-&gt;radians is equivalent to 
</p>

<pre class="indented">
  freq-in-hz * 2 * pi / *srate*.  
</pre>

<blockquote>
<p>
Freq-in-hz * 2 * pi gives us the number of radians traversed per
second; we then divide by the number of samples per second to get the
radians per sample; in dimensional terms: (radians/sec) /
(sample/sec) = radians/sample.  We need this conversion whenever a
frequency-related value is actually being accessed on every sample, as
an increment of a phase variable.  (We are also assuming
our wave table size is 2 * pi). This conversion value was named "mag"
in Mus10 and "in-hz" in CLM-1.  The inverse is radians-&gt;hz.
</p></blockquote>

<p>These names are different from the underlying sndlib names mostly due
to confusion and inattention. Nearly all the sndlib constants and functions
are imported into clm under names that are the same as the C name except
"_" is replaced by "-". So <b>mus-sound-duration</b> exists,
and is the same as <b>sound-duration</b> mentioned above.  See <a href="sndlib.html">sndlib.html</a>
for some info.
<code>(mus-sound-srate (mus-file-name *output*))</code>
for example, returns the
current output sampling rate; this is the same as <code>*srate*</code>.
</p>



<!--  POLYNOMIAL  -->

<div class="innerheader">polynomial</div>

<pre class="indented">
<em class=def id="polynomial">polynomial</em> coeffs x
</pre>

<p><b>polynomial</b> evaluates a polynomial, defined by giving its coefficients,
at a particular point (x).
coeffs is an array of coefficients where
coeffs[0] is the constant term, and so on.  For
waveshaping, use the function <a href="#partialstopolynomial">partials-&gt;polynomial</a>.
Abramowitz and Stegun, "A Handbook of Mathematical Functions" is a
treasure-trove of interesting polynomials.
See also the <a href="#brighten">brighten</a> instrument.
</p>




<!--  ARRAY-INTERP  -->

<div class="innerheader">array-interp and dot-product</div>

<pre class="indented">
<em class=def id="array-interp">array-interp</em> fn x &amp;optional size
<em class=def id="dot-product">dot-product</em> in1 in2
<em class=def id="edot-product">edot-product</em> freq data [Scheme/C versions]
<em class=def id="mus-interpolate">mus-interpolate</em> type x v size y1
</pre>

<p>These functions underlie some of the generators, and can be
called within run.  See <a href="mus.lisp">mus.lisp</a> for
details. <b>array-interp</b> can be used for companding and similar functions &mdash;
load the array (call it "compander" below) with the positive half 
of the companding function, then:
</p>

<pre class="indented">
  (let ((in-val (<a class=quiet href="#readin">readin</a> rd))            ; in-coming signal
        (func-len (length compander)))  ; size of array
    (* (signum in-val) 
       (<em class=red>array-interp</em> compander (abs (* in-val (1- func-len))) func-len)))
</pre>

<p>
<b>dot-product</b> is the usual "inner product" or "scalar product".
</p>

<p>
<b>mus-interpolate</b> is the function used whenever table lookup interpolation is requested, as in
delay or wave-train. The type is one of the interpolation types (mus-interp-linear, for example).
</p>



<!--  CONTRAST-ENHANCEMENT  -->

<div class="innerheader">contrast-enhancement</div>

<pre class="indented">
 <em class=def id="contrast-enhancement">contrast-enhancement</em> in-samp &amp;optional (fm-index 1.0)
</pre>

<p><b>contrast-enhancement</b> phase-modulates a sound file.  It's like audio MSG.
The actual algorithm is sin(in-samp * pi/2 +
(fm-index * sin(in-samp * 2*pi))).  The result is to brighten the
sound, helping it cut through a huge mix.</p>

<p>
Waveshaping can provide a similar effect:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> <em class=def id="brighten">brighten</em> (start duration file file-maxamp partials)
  (multiple-value-bind (beg end) (<a class=quiet href="#timestosamples">times-&gt;samples</a> start duration)
    (let ((fil (<a class=quiet href="#open-input*">open-input*</a> file)))
      (when fil
        (unwind-protect
	  (let ((coeffs (<a class=quiet href="#partialstopolynomial">partials-&gt;polynomial</a> (normalize-partials partials)))
		(rd (<a class=quiet href="#make-readin">make-readin</a> fil)))
	    (run (loop for i from beg below end do
		   (<a class=quiet href="#outa">outa</a> i (* file-maxamp (<a class=quiet href="#polynomial">polynomial</a> coeffs (/ (<a class=quiet href="#readin">readin</a> rd) file-maxamp)))))))
	  (<a class=quiet href="#close-input">close-input</a> fil))))))

(<a class=quiet href="#with-sound">with-sound</a> () (brighten 0 3 "oboe" .15 '(1 1 3 .5 7 .1)))
</pre>

<p>In this case, it is important to scale the file input to the waveshaper to go from
-1.0 to 1.0 to get the full effect of the Chebyshev polynomials.  Unfortunately,
if you don't add an overall amplitude envelope to bring the output to 0, you'll
get clicks if you include even numbered partials.  These partials create a non-zero
constant term in the polynomial, so when the sound decays to 0, the polynomial
output decays to some (possibly large) non-zero value.  In the example above,
I've used only odd partials for this reason.  Another thing to note here is that
the process is not linear; that is the sinusoids that make up the input are not
independently expanded into the output spectrum, but instead you get sum and difference
tones, (not to mention phase cancellations) much as in FM with a complex wave.  
</p>




<!--  AMPLITUDE-MODULATE  -->

<div class="innerheader">ring-modulate and amplitude-modulate</div>

<pre class="indented">
<em class=def id="ring-modulate">ring-modulate</em> in1 in2
<em class=def id="amplitude-modulate">amplitude-modulate</em> am-carrier input1 input2
</pre>

<b>ring-modulate</b> returns (* in1 in2).
<b>amplitude-modulate</b> returns (* input1 (+ am-carrier input2))

<p>ring-modulation is sometimes called "double-sideband-suppressed-carrier" modulation &mdash;
that is, amplitude modulation with the carrier subtracted out (set to 0.0 above).
The nomenclature here is a bit confusing &mdash; I can't remember now why I used
these names; think of "carrier" as "carrier amplitude" and "input1" as "carrier". Normal amplitude modulation using this function would be:
</p>

<pre class="indented">
(defvar carrier (<a class=quiet href="#make-oscil">make-oscil</a> carrier-freq (* .5 pi)))
...
(amplitude-modulate 1.0 (<a class=quiet href="#oscil">oscil</a> carrier) signal)
</pre>

<p>
Since neither needs any state information, there are no associated make
functions.</p>

<p>Both of these take advantage of the "Modulation Theorem"; since
multiplying a signal by e^(iwt) translates its spectrum by w /
two-pi Hz, multiplying by a sinusoid splits its spectrum into two equal parts
translated up and down by w/two-pi Hz.  The simplest case is: </p>

<pre class="indented">
cos f1 * cos f2 = (cos (f1 + f2) + cos (f1 - f2)) / 2.
</pre>

<p>We can use these to shift all the components of a signal by the same
amount up or down ("single-sideband modulation").
</p>



<!--  FFT  -->

<!-- INDEX fft:Fourier transforms  -->
<div class="innerheader">FFT</div>

<pre class="indented">
<em class=def id="fft">fft</em> rdat idat fftsize &amp;optional sign
<em class=def id="make-fft-window">make-fft-window</em> <a class=quiet href="#optional-key">&amp;optional-key</a> type size (beta 0.0) (alpha 0.0)
<em class=def id="rectangulartopolar">rectangular-&gt;polar</em> rdat idat
<em class=def id="rectangulartomagnitudes">rectangular-&gt;magnitudes</em> rdat idat
<em class=def id="polartorectangular">polar-&gt;rectangular</em> rdat idat
<em class=def id="spectrum">spectrum</em> rdat idat window norm-type
<em class=def id="convolution">convolution</em> rdat idat size
<em class=def id="autocorrelate">autocorrelate</em> dat1 size
<em class=def id="correlate">correlate</em> dat1 dat2 size
</pre>

<p>These provide run-time access to the standard fft routines and their habitual companions.
<b>make-fft-window</b> can return many of the standard windows including:</p>

<pre class="indented">
  rectangular-window   ; no change in data
  bartlett-window      ; triangle
  parzen-window        ; raised triangle
  welch-window         ; parzen squared
  hann-window          ; cosine (sometimes known as "hanning-window" &mdash; a sort of in-joke)
  hamming-window       ; raised cosine
  blackman2-window     ; Blackman-Harris windows of various orders
  blackman3-window
  blackman4-window     ; also blackman5..10
  exponential-window
  kaiser-window        ; beta argument used here
</pre>

<p>The
magnitude of the spectrum is returned by <b>rectangular-&gt;polar</b>.
<b>spectrum</b> calls the fft, translates to polar coordinates,
then returns the results (in the lower half of "rdat") in dB (norm-type = 0), or linear normalized to 1.0 (norm-type = 1),
or linear unnormalized (norm-type not 0 or 1). 
</p>

<p>The following instrument implements fft overlap-add, but instead
of scaling the various spectral components to filter a sound, it reverses a portion
of the spectrum, a distortion that can be effective with speech sounds.</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> inside-out (beg dur file amp lo hi &amp;optional (fftsize 1024))
  ;; fft overlap-add (and buffer), but the fft bins between lo and hi are reversed
  (let ((fil (<a class=quiet href="#open-input*">open-input*</a> file)))
    (when fil
      (unwind-protect
        (let* ((start (floor (* beg *srate*)))
               (end (+ start (floor (* dur *srate*))))
               (fdr (make-double-float-array fftsize))
               (fdi (make-double-float-array fftsize))
               (wtb (make-double-float-array fftsize))
               (filptr 0)
               (fft2 (floor fftsize 2))
               (fft4 (floor fftsize 4))
               (ctr fft2)
               (fftn (/ 1.0 fftsize))
               (first-time 1)
               (mid (* .5 (+ hi lo))))
	  (when (zerop lo) (setf lo 1))
          (run
           (loop for i from start below end do
             (when (= ctr fft2)
               (<em class=red>clear-array</em> fdr)
               (<em class=red>clear-array</em> fdi)
               (dotimes (k fft2)
                 (setf (aref fdr (+ k fft4)) (* (<a class=quiet href="#ina">ina</a> filptr fil) fftn))
                 (incf filptr))
               (<em class=red>fft</em> fdr fdi fftsize 1)
               (let ((j1 hi) ; now reverse bins between lo and hi
                     (k0 (- fftsize lo))
                     (k1 (- fftsize hi)))
                 (loop for j0 from lo to mid do
                   (let ((tmprj (aref fdr j0))
                         (tmprk (aref fdr k0))
                         (tmpij (aref fdi j0))
                         (tmpik (aref fdi k0)))
                     (setf (aref fdr j0) (aref fdr j1))
                     (setf (aref fdr j1) tmprj)
                     (setf (aref fdr k0) (aref fdr k1))
                     (setf (aref fdr k1) tmprk)
                     (setf (aref fdi j0) (aref fdi j1))
                     (setf (aref fdi j1) tmpij)
                     (setf (aref fdi k0) (aref fdi k1))
                     (setf (aref fdi k1) tmpik)
                     (incf k1)
                     (decf k0)
                     (decf j1))))
               (<em class=red>fft</em> fdr fdi fftsize -1)
               (dotimes (k fft2)
                 (setf (aref wtb k) (aref wtb (+ k fft2)))
                 (setf (aref wtb (+ k fft2)) 0.0))
               (if (= first-time 1)
                   (progn
                     (dotimes (k fftsize) (setf (aref wtb k) (aref fdr k)))
                     (setf first-time 0)
		     (setf ctr fft4))
                 (progn
                   (dotimes (k fft2) (incf (aref wtb k) (aref fdr k)))
                   (dotimes (k fft2) (setf (aref wtb (+ k fft2)) (aref fdr (+ k fft2))))
		   (setf ctr 0))))
             (<a class=quiet href="#outa">outa</a> i (* amp (aref wtb ctr)))
             (incf ctr))))
        (<a class=quiet href="#close-input">close-input</a> fil)))))

(<a class=quiet href="#with-sound">with-sound</a> () (inside-out 0 1.0 "fyow" 1.0 3 8))
</pre>

<p>There are many other examples of run-time FFTs: 
the <a href="#cross-synthesis">cross-synthesis</a> instrument above, 
<a href="san.ins">san.ins</a>,
and <a href="anoi.ins">anoi.ins</a>.
</p>



<div class="innerheader" id="def-clm-struct">def-clm-struct</div>

<p><b>def-clm-struct</b> is syntactically like def-struct, but sets up
the struct field names for the run macro.  There are several examples in prc-toolkit95.lisp, and other instruments.
The fields can only be of a numerical type (no generators, for example).
</p>


<div class="innerheader" id="definstrument">Definstrument</div>

<!-- INDEX ins-files:Instruments --><em class=def id="ins-files"></em>
<p><b>definstrument</b> defines an instrument in CLM.
Its syntax is almost the same as defun; it has a few bizarre options (for miserable
historical reasons), but they should be resolutely ignored.
There are a bazillion example instruments included in CLM and Snd.
The following instruments live in *.ins files in the CLM
directory (see also the file <a href="ins">ins</a>), and in various
*.scm, *.rb, and *.fs files in the Snd tarball.  If you're reading this
file from outside ccrma, and the instrument url has snd/snd, change that
to clm/clm.
</p>

<table class="borderspaced">
<tr>
<th class="beige">instrument</th>
<th class="beige">function</th>
<th class="beige">CL</th>
<th class="beige">Scheme</th>
<th class="beige">Ruby</th>
<th class="beige">Forth</th>
</tr>
<tr><td class="br">complete-add</td>      
    <td class="br">additive synthesis</td>
    <td class="br">add.ins</td>
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">addflts</td>
    <td class="br">filters</td>
    <td class="br">addflt.ins</td> 
        <td class="br"><a href="dsp.scm">dsp.scm</a></td>
	<td class="br"><a href="dsp.rb">dsp.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">add-sound</td>
    <td class="br">mix in a sound file</td>
    <td class="br">addsnd.ins</td>
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">bullfrog et al</td>
    <td class="br">many animals (frogs, insects, birds)</td>
    <td class="br"></td>
    <td class="br"><a href="animals.scm">animals.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">anoi</td>
    <td class="br">noise reduction</td>
    <td class="br">anoi.ins</td>
        <td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
        <td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
        <td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">autoc</td>
    <td class="br">pitch estimation (Bret Battey)</td>
    <td class="br">autoc.ins</td>
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">badd</td>
    <td class="br">fancier additive synthesis (Doug Fulton)</td>
    <td class="br">badd.ins</td>
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">bandedwg</td>               
    <td class="br">Juan Reyes banded waveguide instrument</td>      
    <td class="br">bandedwg.ins</td>      
	<td class="br"><a href="bandedwg.cms">bandedwg.cms</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">fm-bell</td>
    <td class="br">fm bell sounds (Michael McNabb)</td>
    <td class="br">bell.ins</td>
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">bigbird</td>
    <td class="br">waveshaping</td>
    <td class="br">bigbird.ins</td>
	<td class="br"><a href="bird.scm">bird.scm</a></td>
	<td class="br"><a href="bird.rb">bird.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs, bird.fs</a></td>
    </tr>

<tr><td class="br">singbowl</td>               
    <td class="br">Juan Reyes Tibetan bowl instrument</td>      
    <td class="br">bowl.ins</td>      
	<td class="br"><a href="bowl.cms">bowl.cms</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">canter</td>            
    <td class="br">fm bagpipes (Peter Commons)</td>      
    <td class="br">canter.ins</td>
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">cellon</td>            
    <td class="br">feedback fm (Stanislaw Krupowicz)</td>      
    <td class="br">cellon.ins</td>    
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">cnvrev</td>            
    <td class="br">convolution (aimed at reverb)</td>      
    <td class="br">cnv.ins</td>
    <td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">moving sounds</td>     
    <td class="br">sound movement (Fernando Lopez-Lezcano)</td>      
    <td class="br">dlocsig.lisp</td> 
	<td class="br"><a href="dlocsig.scm">dlocsig.scm</a></td>
        <td class="br"><a href="dlocsig.rb">dlocsig.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">drone</td>             
    <td class="br">additive synthesis (bag.clm) (Peter Commons)</td>      
    <td class="br">drone.ins</td>      
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">expandn</td>             
    <td class="br">granular synthesis (Michael Klingbeil)</td>      
    <td class="br">expandn.ins</td>      
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">granulate-sound</td>   
    <td class="br">examples granular synthesis</td>      
    <td class="br">expsrc.ins</td>    
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">cross-fade</td>        
    <td class="br">cross-fades in the frequency domain</td>      
    <td class="br">fade.ins</td>        
	<td class="br"><a href="fade.scm">fade.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">filter-sound</td>      
    <td class="br">filter a sound file</td>      
    <td class="br">fltsnd.ins</td>    
	<td class="br"><a href="dsp.scm">dsp.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">stereo-flute</td>      
    <td class="br">physical model of a flute (Nicky Hind)</td>      
    <td class="br">flute.ins</td>      
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">fm examples</td>       
    <td class="br">fm bell, gong, drum (Paul Weineke, Jan Mattox)</td>      
    <td class="br">fmex.ins</td>        
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">Jezar's reverb</td>    
    <td class="br">fancy reverb (Jezar Wakefield)</td>      
    <td class="br">freeverb.ins</td> 
	<td class="br"><a href="freeverb.scm">freeverb.scm</a></td>
	<td class="br"><a href="freeverb.rb">freeverb.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">fofins</td>
    <td class="br">FOF synthesis</td>
    <td class="br"><a href="#wave-train">sndclm.html</a></td> 
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">fullmix</td>           
    <td class="br">a mixer</td>      
    <td class="br">fullmix.ins</td>  
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">grani</td>             
    <td class="br">granular synthesis (Fernando Lopez-Lezcano)</td>      
    <td class="br">grani.ins</td>      
	<td class="br"><a href="grani.scm">grani.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">grapheq</td>           
    <td class="br">graphic equalizer (Marco Trevisani)</td>      
    <td class="br">grapheq.ins</td>  
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">fm-insect</td>         
    <td class="br">fm</td>      
    <td class="br">insect.ins</td>    
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">jc-reverb</td>         
    <td class="br">a reverberator (see also jlrev)</td>      
    <td class="br">jcrev.ins</td>      
	<td class="br"><a href="jcrev.scm">jcrev.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">fm-voice</td>          
    <td class="br">fm voice (John Chowning)</td>      
    <td class="br">jcvoi.ins</td>     
    <td class="br"><a href="jcvoi.scm">jcvoi.scm </a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">kiprev</td>            
    <td class="br">a fancier reverberator (Kip Sheeline)</td>      
    <td class="br">kiprev.ins</td>    
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">lbj-piano</td>         
    <td class="br">additive synthesis piano (Doug Fulton)</td>      
    <td class="br">lbjPiano.ins</td> 
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">rotates</td>               
    <td class="br">Juan Reyes Leslie instrument</td>      
    <td class="br">leslie.ins</td>      
	<td class="br"><a href="leslie.cms">leslie.cms</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">maraca</td>            
    <td class="br">Perry Cook's maraca physical models</td>      
    <td class="br">maraca.ins</td>    
	<td class="br"><a href="maraca.scm">maraca.scm</a></td>
	<td class="br"><a href="maraca.rb">maraca.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">maxfilter</td>         
    <td class="br">Juan Reyes modular synthesis</td>      
    <td class="br">maxf.ins</td>        
	<td class="br"><a href="maxf.scm">maxf.scm</a></td>
	<td class="br"><a href="maxf.rb">maxf.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">mlb-voice</td>         
    <td class="br">fm voice (Marc LeBrun)</td>      
    <td class="br">mlbvoi.ins</td>
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">moog filters</td>      
    <td class="br">Moog filters (Fernando Lopez-Lezcano)</td>      
    <td class="br">moog.lisp</td>      
	<td class="br"><a href="moog.scm">moog.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">fm-noise</td>          
    <td class="br">noise maker</td>      
    <td class="br">noise.ins</td>      
	<td class="br"><a href="noise.scm">noise.scm</a></td>
	<td class="br"><a href="noise.rb">noise.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">nrev</td>              
    <td class="br">a popular reverberator (Michael McNabb)</td>      
    <td class="br">nrev.ins</td>        
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">one-cut</td>           
    <td class="br">"cut and paste" (Fernando Lopez-Lezcano)</td>      
    <td class="br">one-cut.ins</td>  
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">p</td>                 
    <td class="br">Scott van Duyne's piano physical model</td>      
    <td class="br">piano.ins</td>      
	<td class="br"><a href="piano.scm">piano.scm</a></td>
	<td class="br"><a href="piano.rb">piano.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">pluck</td>             
    <td class="br">Karplus-Strong synthesis (David Jaffe)</td>      
    <td class="br">pluck.ins</td>      
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">pqw</td>               
    <td class="br">waveshaping</td>      
    <td class="br">pqw.ins</td>          
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>	
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">pqw-vox</td>           
    <td class="br">waveshaping voice</td>      
    <td class="br">pqwvox.ins</td>    
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">physical models</td>   
    <td class="br">physical modelling (Perry Cook)</td>      
    <td class="br">prc-toolkit95.lisp</td>
	<td class="br"><a href="prc95.scm">prc95.scm</a></td>
	<td class="br"><a href="prc95.rb">prc95.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">various ins</td>       
    <td class="br">from Perry Cook's Synthesis Toolkit</td>      
    <td class="br">prc96.ins</td>      
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">pvoc</td>              
    <td class="br">phase vocoder (Michael Klingbeil)</td>      
    <td class="br">pvoc.ins</td>        
	<td class="br"><a href="pvoc.scm">pvoc.scm</a></td>
	<td class="br"><a href="pvoc.rb">pvoc.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">resflt</td>            
    <td class="br">filters (Xavier Serra, Richard Karpen)</td>      
    <td class="br">resflt.ins</td>    
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">reson</td>             
    <td class="br">fm formants (John Chowning)</td>      
    <td class="br">reson.ins</td>      
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">ring-modulate</td>     
    <td class="br">ring-modulation of sounds (Craig Sapp)</td>      
    <td class="br">ring-modulate.ins</td>
	<td class="br"><a href="examp.scm">examp.scm</a></td>
	<td class="br"><a href="examp.rb">examp.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">rmsenv</td>            
    <td class="br">rms envelope of sound (Bret Battey)</td>      
    <td class="br">rmsenv.ins</td>    
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">pins</td>              
    <td class="br">spectral modelling</td>      
    <td class="br">san.ins</td>          
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">scanned</td>           
    <td class="br">Juan Reyes scanned synthesis instrument</td>      
    <td class="br">scanned.ins</td>  
	<td class="br"><a href="dsp.scm">dsp.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">scentroid</td>         
    <td class="br">spectral scentroid envelope (Bret Battey)</td>      
    <td class="br">scentroid.ins</td> 
	<td class="br"><a href="dsp.scm">dsp.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">shepard</td>            
    <td class="br">Shepard tones (Juan Reyes)</td>      
    <td class="br">shepard.ins</td>    
	<td class="br"><a href="sndscm.html#wsdoc">sndscm.html</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">singer</td>            
    <td class="br">Perry Cook's vocal tract physical model</td>      
    <td class="br">singer.ins</td>    
	<td class="br"><a href="singer.scm">singer.scm</a></td>
	<td class="br"><a href="singer.rb">singer.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">sndwarp</td>           
    <td class="br">Csound-like sndwarp generator (Bret Battey)</td>      
    <td class="br">sndwarp.ins</td>   
	<td class="br"><a href="sndwarp.scm">sndwarp.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">stochastic</td>        
    <td class="br">Bill Sack's stochastic synthesis implementation</td>      
    <td class="br">stochastic.ins</td><td class="br"><a href="stochastic.scm">stochastic.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">bow</td>               
    <td class="br">Juan Reyes bowed string physical model</td>      
    <td class="br">strad.ins</td>      
	<td class="br"><a href="strad.scm">strad.scm</a></td>
	<td class="br"><a href="strad.rb">strad.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">track-rms</td>         
    <td class="br">rms envelope of sound file (Michael Edwards)</td>      
    <td class="br">track-rms.ins</td>        
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">fm-trumpet</td>        
    <td class="br">fm trumpet (Dexter Morrill)</td>      
    <td class="br">trp.ins</td>          
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">various ins</td>       
    <td class="br">granular synthesis, formants, etc</td>      
    <td class="br">ugex.ins</td>        
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
    <td></td>
    </tr>

<tr><td class="br">test ins</td>          
    <td class="br">CLM regression tests &mdash; see clm-test.lisp</td>      
    <td class="br">ug(1,2,3,4).ins</td>   
	<td class="br"><a href="clm23.scm">clm23.scm</a></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">fm-violin</td>         
    <td class="br">fm violin (fmviolin.clm, popi.clm)</td>      
    <td class="br">v.ins</td>              
	<td class="br"><a href="v.scm">v.scm</a></td>
	<td class="br"><a href="v.rb">v.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">vowel</td>             
    <td class="br">vowels (Michelle Daniels)</td>      
    <td class="br">vowel.ins</td>      
    <td></td>
    <td></td>
    <td></td>
    </tr>

<tr><td class="br">vox</td>               
    <td class="br">fm voice (cream.clm)</td>      
    <td class="br">vox.ins</td>          
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">zc, zn</td>            
    <td class="br">interpolating delays</td>      
    <td class="br">zd.ins</td>            
	<td class="br"><a href="clm-ins.scm">clm-ins.scm</a></td>
	<td class="br"><a href="clm-ins.rb">clm-ins.rb</a></td>
	<td class="br"><a href="clm-ins.fs">clm-ins.fs</a></td>
    </tr>

<tr><td class="br">zipper</td>            
    <td class="br">The 'digital zipper' effect.</td>      
    <td class="br">zipper.ins</td>    
	<td class="br"><a href="zip.scm">zip.scm</a></td>
	<td class="br"><a href="zip.rb">zip.rb</a></td>
    <td></td>
    </tr>

</table>

<p>The file <a href="clm-test.lisp">clm-test.lisp</a> exercises most of these instruments. 
If you develop
an interesting instrument that you're willing to share, please send it to me
(bil@ccrma.stanford.edu). </p>

<p>Although all the examples in this document use run followed by a loop,
you can use other constructs instead:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> no-loop-1 (beg dur)
  (let ((o (<a class=quiet href="#make-oscil">make-oscil</a> 660)))
    (run 
     (let ((j beg)) 
       (loop for i from 0 below dur do
	 (<a class=quiet href="#outa">outa</a> (+ i j) (* .1 (<a class=quiet href="#oscil">oscil</a> o))))))))

(<a class=quiet href="#definstrument">definstrument</a> no-loop-2 (beg dur)
  (let ((o (<a class=quiet href="#make-oscil">make-oscil</a> 440)))
    (run
     (dotimes (k dur)
       (<a class=quiet href="#outa">outa</a> (+ k beg) (* .1 (<a class=quiet href="#oscil">oscil</a> o)))))))
</pre>

<p>And, of course, <a href="#out-any">out-any</a> and <a href="#locsig">locsig</a> can be called any number of times
(including zero) per sample and at any output location.  Except in
extreme cases (spraying samples to random locations several seconds
apart), there is almost no speed penalty associated with such output,
so don't feel constrained to write an instrument as a sample-at-a-time loop.
That form was necessary in the old days, so nearly all current instruments
still use it (they are translations of older instruments), but there's no
good reason not to write an instrument such as:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> noisey (beg dur)
  (run
   (dotimes (i dur)
     (dotimes (k (random 10))
       (<a class=quiet href="#outa">outa</a> (+ beg (floor (random dur))) (centered-random .01))))))
</pre>



<!--  WITH-SOUND  -->

<div class="header" id="note-lists">Note lists</div>

<!-- INDEX note-lists:Note lists  -->

<p>A note list in CLM is any lisp expression that opens an output sound file and calls an instrument.  The simplest way to
do this is with with-sound or clm-load.
</p>


<div class="innerheader">with-sound</div>

<pre class="indented">
 <em class=def id="with-sound">with-sound</em> &amp;key 
   ;; "With-sound: check it out!" &mdash; Duane Kuiper, Giants broadcaster after Strawberry homer
   (output <a href="#*clm-file-name*">*clm-file-name*</a>)        ; name of output sound file ("test.snd" normally)
   (channels <a href="#*clm-channels*">*clm-channels*</a>)       ; can be any number (defaults to 1, see defaults.lisp)
   (srate <a href="#*clm-srate*">*clm-srate*</a>)             ; also 'sampling-rate' for backwards compatibility
   continue-old-file               ; open and continue old output file
   reverb                          ; name of the reverberator, if any.  The reverb
                                   ;   is a normal clm instrument (see <a href="nrev.ins">nrev.ins</a>)
   reverb-data                     ; arguments passed to the reverberator; an unquoted list
   (reverb-channels *clm-reverb-channels*) ; chans in temp reverb stream (input to reverb)
   revfile                         ; reverb file name
   (play *clm-play*)               ; play new sound automatically?
   (notehook *clm-notehook*)       ; function evaluated on each instrument call
   (statistics *clm-statistics*)   ; print out various fascinating numbers
   (decay-time 1.0)                ; ring time of reverb after end of piece
   comment                         ; comment placed in header (set to :none to squelch comment)
   info                            ; non-comment header string
   (header-type <a href="#*clm-header-type*">*clm-header-type*</a>) ; output file type (see also <a href="#header-types">header types</a>)
   (data-format <a href="#*clm-data-format*">*clm-data-format*</a>) ; output data format (see <a href="#header-types">header types</a>)
   save-body                       ; if t, copy the body (as a string) into the header
   scaled-to                       ; if a number, scale results to have that max amp
   scaled-by                       ; scale output by some number
   (clipped *clm-clipped*)         ; if t, clip output rather than allowing data to wrap-around
   (verbose <em class=emdef>*clm-verbose*</em>)         ; some instruments use this to display info during computation
   (force-recomputation nil)       ; if t, force with-mix calls to recompute
</pre>

<p><b>with-sound</b> is a macro that performs all the various services needed to
produce and play a sound file; it also wraps an unwind-protect around its body to
make sure that everything is cleaned up properly if you happen to interrupt
computation; at the end it returns the output file name.  with-sound opens an
output sound file, evaluates its body (normally a bunch of instrument calls),
applies reverb, if any, as a second pass, and plays the sound, if desired.
The sound file's name defaults to "test.snd" or something similar; use the
<b>output</b> argument to write some other file: 
</p>

<pre class="indented">
  (with-sound (:<em class=red>output</em> "new.wave") (fm-violin 0 1 440 .1))
</pre>

<p>
The <b>channels</b>, <b>srate</b>, <b>data-format</b>, and <b>header-type</b> arguments
set the sound characteristics.  The default values for these are set in defaults.lisp.
Reverberation is handled as a second pass through a reverb instrument (nrev.ins for
example).  The <b>reverb</b> argument sets the choice of reverberator.
</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> (:output "new.snd") (simp 0 1 440 .1))
(<a class=quiet href="#with-sound">with-sound</a> (:srate 44100 :channels 2) ...)
(<a class=quiet href="#with-sound">with-sound</a> (:reverb jc-reverb) ...)
(<a class=quiet href="#with-sound">with-sound</a> (:reverb nrev :reverb-data (:reverb-factor 1.2 :lp-coeff .95))...)
</pre>


<p>With-sound can be called within itself, so you can make an output sound file
for each section of a piece as well as the whole thing, all in one run.  Since it is the basis of <a href="#mix-and-with-mix">with-mix</a> and
<a href="#sound-let">sound-let</a>, all of these can be nested indefinitely:</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> () 
  (mix (<a class=quiet href="#with-sound">with-sound</a> (:output "hiho.snd") 
            (fm-violin 0 1 440 .1))))

(<a class=quiet href="#with-sound">with-sound</a> ()
  (<a class=quiet href="#with-mix">with-mix</a> () "s1" 0
    (<a class=quiet href="#sound-let">sound-let</a> ((tmp ()
                  (fm-violin 0 1 440 .1)))
      (mix tmp))))

(<a class=quiet href="#with-sound">with-sound</a> (:verbose t)
  (<a class=quiet href="#with-mix">with-mix</a> () "s6" 0
    (<a class=quiet href="#sound-let">sound-let</a> ((tmp ()
                  (fm-violin 0 1 440 .1))
                (tmp1 (:reverb nrev)
                  (mix "oboe.snd")))
      (mix tmp1)
      (mix tmp :output-frample *srate*))
    (fm-violin .5 .1 330 .1)))

(<a class=quiet href="#with-sound">with-sound</a> (:verbose t)
  (<a class=quiet href="#sound-let">sound-let</a> ((tmp ()
                (<a class=quiet href="#with-mix">with-mix</a> () "s7" 0
                  (<a class=quiet href="#sound-let">sound-let</a> ((tmp ()
                                (fm-violin 0 1 440 .1))
                              (tmp1 ()
                                (mix "oboe.snd")))
                   (mix tmp1)
                   (mix tmp :output-frample *srate*))
                 (fm-violin .5 .1 330 .1))))
    (mix tmp)))
</pre>

<p>You can call with-sound within an instrument:</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> msnd (beg dur freq amp)
  (let ((os (<a class=quiet href="#make-oscil">make-oscil</a> freq)))
    (run
     (loop for i from beg below (+ beg dur) do
       (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> os)))))))

(<a class=quiet href="#definstrument">definstrument</a> call-msnd (beg dur sr amp)
  (let* ((temp-file (<a class=quiet href="#with-sound">with-sound</a> (:output "temp.snd") (msnd 0 dur 440.0 .1)))
	 (tfile (<a class=quiet href="#open-input">open-input</a> temp-file))
	 (reader (<a class=quiet href="#make-src">make-src</a> :input tfile :srate sr))
	 (new-dur (/ dur sr)))
    (run
     (loop for i from beg below (+ beg new-dur) do
       (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#src">src</a> reader)))))
    (<a class=quiet href="#close-input">close-input</a> tfile)
    (delete-file temp-file)))
</pre>

<p>
Besides :channels, :reverb, and :srate, the most useful options are :scaled-to and
:statistics.
statistics, if t, causes clm
to keep track of a variety of interesting things and print them out at the end
of the computation.  scaled-to tells clm to make sure the final output
file has a maxamp of whatever the argument is to :scaled-to &mdash; that is,</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> (:scaled-to .5) 
  (dotimes (i 32) (mix "oboe.snd" :output-frample (* i *srate*))))
</pre>

<p>will produce test.snd with a maxamp of .5, no matter how loud the intermediate
mix actually is.
Similarly, the scaled-by argument causes all the output to
be scaled (in amplitude) by its value.</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> (:scaled-by 2.0) (fm-violin 0 1 440 .1)) 
</pre>

<p>produces a note that is .2 in amplitude.
</p>

<p>If revfile is specfied, but not reverb, the reverb stream is
written to revfile, but not mixed with the direct signal in any way. 
Normally the reverb output is not deleted by with-sound; you can set
<b>*clm-delete-reverb*</b> to t to have it deleted automatically.
</p>

<p>
The macro <b>scaled-by</b> scales its body by
its first argument (much like <a href="#with-offset">with-offset</a>):</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> () 
  (fm-violin 0 1 440 .1)
  (scaled-by 2.0
    (fm-violin 0 .25 660 .1)) ; actual amp is .2
  (fm-violin .5 440 .1))
</pre>

<p>There is also the parallel macro <b>scaled-to</b>.
These are built on the macro <em class=emdef>with-current-sound</em>
which sets up an embedded with-sound call with all the current with-sound arguments in place
except output, comment, scaled-to, and scaled-by.</p>

<p>Other with-sound options that might need explanation are :notehook and :continue-old-file.</p>

<p><em class="noem" id="notehook">Notehook</em> declares a function that is evaluated each time any instrument is called.
The arguments passed to the notehook function are the current instrument name (a string) and all its
arguments.  The following prints out the instrument arguments for any
calls on simp that are encountered:</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> (<em class=red>:notehook</em>
              #'(lambda (name &amp;rest args) 
		  (when (string-equal name "simp")
	            (print (format nil "(simp ~{~A ~})" args))
                    (force-output))))
  (simp 0 1 440 .1)
  (toot .5 .5 660 .2))
</pre>

<p>If the notehook function returns :done, the instrument exits immediately.
</p>

<p>Continue-old-file, if t, re-opens a previously existing file
for further processing.  Normally with-sound clobbers any existing file
of the same name as the output file (see output above).  By using
continue-old-file, you can both add new stuff to an existing file, or
(by subtracting) delete old stuff to any degree of selectivity.  When you erase
a previous note, remember that the subtraction has to be exact; you have
to create exactly the same note again, then subtract it.  By the same token,
you can make a selected portion louder or softer by adding or subtracting a
scaled version of the original.  
The option data-format underlies :scaled-to.
CLM can read and write sound data in all the currently popular formats,
leaving aside proprietary compression schemes.  The names used in
:data-format can be found in <a href="initmus.lisp">initmus.lisp</a>,
along with the headers CLM knows about.</p>

<p>You can make your own specialized versions of with-sound:
</p>

<pre class="indented">
(defmacro with-my-sound ((&amp;rest args) &amp;body body)
  `(let ((filename (<a class=quiet href="#with-sound">with-sound</a> ,args ,.body)))
     ;; any post-processing you like here
     filename))
</pre>

<p>One such specialization is <em class=def id="with-threaded-sound">with-threaded-sound</em>,
available in sbcl if you built sbcl with threads.
with-threaded-sound looks exactly like with-sound, but
each note (each separate expression in the with-sound body) is handled by a separate thread.
</p>

<pre class="indented">
(with-threaded-sound ()
  (fm-violin 0 1 440 .1)
  (fm-violin 0 1 660 .1))
</pre>

<p>If start a thread for each note, then join them all at once, the computation slows down a lot due to
all the thread overhead, so *clm-threads* sets the number of threads running
through the note list at any one time.  It defaults to 4.  You can speed up
with-threaded-sound if you set *clm-file-buffer-size* large enough to accommodate
the entire output, then pass :output-safety 1 to with-threaded-sound.
Even so, my tests indicate that 
it is sometimes faster to use with-sound; I need to figure out why...
</p>
 
<p><em class=def id="clm-load">clm-load</em> is the same as with-sound, but its first argument is the name
of a file containing clm instrument calls (i.e. the body of
with-sound), the reverb argument is the name of the reverb function,
and the reverb-data argument is the list; that is, clm-load's arguments
look like normal lisp, whereas with-sound's are unquoted in these two cases.</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> (:reverb jc-reverb :reverb-data (:volume .3)) ...)
(<a class=quiet href="#clm-load">clm-load</a> "test.clm" :reverb 'jc-reverb :reverb-data '(volume .3))
</pre>

<p>The with-sound output is normally sent to the speakers via the <b>play</b> function.
There are several associated functions:</p>

<pre class="indented">
<em class=emdef>play</em> &amp;optional file start end wait
<em class=def id="dac">dac</em> &amp;optional file start end wait
<em class=def id="sldac">sl-dac</em> file &amp;optional (output-device mus-audio-default)
<em class=emdef>stop-playing</em>
<em class=def id="stop-dac">stop-dac</em>
</pre>

<p><b>play</b> (or <b>dac</b>) starts playing file (or the last file played, if no
argument is given); in some cases (MCL and ACL) it then returns to the lisp listener;
to interrupt the dac in those cases, use <b>stop-playing</b> (or <b>stop-dac</b>). 
Currently, <b>play</b> calls the sndplay program if possible; <b>sl-dac</b> is
the same thing, but calls the sl_dac function.  The latter gives you control over the
output device (sndplay will also someday).  In some cases, sndplay's default buffer
size is not ideal; you can use <a href="#*clm-player*">*clm-player*</a> and sndplay's bufsize argument to
set it to the correct value for your audio system. play's start and end arguments are in seconds,
and default to playing the entire sound.  The wait argument in some cases causes
the play call to wait until the complete sound has been played before returning to the listener.
</p>

<p>The *clm-* variables (like *clm-srate*) set the default values.
The corresponding un-clm'd versions (*srate*) hold the current values.  So, if
with-sound doesn't include the :srate argument, *srate* is the same as *clm-srate*;
otherwise it reflects the :srate value for the duration of the with-sound call.
The local variables that are currently exported are:
*srate*, *safety*, and *debug*.  Unexported, but available in the clm package
are *channels*, *data-format*, *header-type*, *notehook*, *clipped*, *verbose*,
and *statistics*.  
</p>

<pre class="indented">
<em class=def id="musfloatequalfudgefactor">mus-float-equal-fudge-factor</em>     how far apart values can be and still be considered equal
<em class=def id="musarrayprintlength">mus-array-print-length</em> ()        how many array (vct) elements to print in mus-describe
<em class=def id="musfilebuffersize">mus-file-buffer-size</em> ()          size of input/ouput buffers (default 8192)
<em class=def id="makefircoeffs">make-fir-coeffs</em> (order spectr)
<em class=def id="mussrate">mus-srate</em> ()                     current sampling rate
</pre>



<!-- INDEX mix-and-with-mix:Checkpoints -->

<div class="innerheader" id="mix-and-with-mix">with-mix</div>

<pre class="indented">
<em class=def id="with-mix">with-mix</em> options file begin &amp;body body
</pre>

<p>With-mix is a macro, callable within <a href="#with-sound">with-sound</a> or <a href="#clm-load">clm-load</a>,
which saves the computation in its body in a separate file named file
(without the .snd extension), and can tell when that file's data is up to date
and does not need to be recomputed.
</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> () 
  (fm-violin 0 .1 440 .1)
  (<em class=red>with-mix</em> () "sec1" .5 
    (fm-violin 0 .1 550 .1)
    (fm-violin .1 .1 660 .1))
  (<em class=red>with-mix</em> (:reverb jc-reverb) "sec2" 1.0
    (fm-violin 0 .1 880 .1 :reverb-amount .2)
    (fm-violin .1 .1 1320 .1 :reverb-amount .2))
  (fm-violin 2 .1 220 .1)
  (<em class=red>mix</em> "/zap/slow.snd"))
</pre>

<p>Now, if we change just the first note in the with-mix call, the
second with-mix section will not be recomputed, but will be mixed in from the
saved file "sec2.snd".  By surrounding stable sections of a piece with calls on
mix or with-mix, you can save a huge amount of time that would
otherwise be spent waiting for these notes to be recomputed.  This check-point
or makefile capability is built on <a href="#open-input">open-input</a>.</p>

<blockquote>
With-mix performs a string comparison of its body to decide whether
it needs to recompute its note calls.  It then loads that body from
a separate saved file.  This can be confusing if global variables
are present.

<pre class="indented">
  &gt; USER(2): (let ((rstr .1)) (<a class=quiet href="#with-sound">with-sound</a> () (<a class=quiet href="#with-mix">with-mix</a> () "sec" 0 (fm-violin 0 1 440 rstr))))
  &gt; ; Loading /zap/sec.clm
  &gt; Error: Attempt to take the value of the unbound variable `RSTR'.
</pre>

Here the code evaluated is basically
<code>
(let ((rstr .1)) (load "/zap/sec.clm"))
</code>
where rstr has lexical scope.  To make rstr visible within the load,

<pre class="indented">
  (let ((rstr1 .1)) 
    (declare (special rstr1))
    (<a class=quiet href="#with-sound">with-sound</a> () (<a class=quiet href="#with-mix">with-mix</a> () "sec" 0 (fm-violin 0 1 440 rstr1))))
</pre>

but if you then evaluate the same form again, changing rstr1 to (say) .5,
with-mix does not notice that rstr1's value has changed, so
it does not recompute its body, leaving the resultant amplitude at .1.
</blockquote>

<p>The fastest way to mix sound files is with <b>mix</b>:</p>

<pre class="indented">
<em class=def id="mix">mix</em> &amp;optional-key filename (input-frample 0) (output-frample 0) framples output
</pre>




<div class="innerheader">c-level IO</div>

<!-- INDEX open-input:Sound file IO -->

<pre class="indented">
<em class=def id="open-input">open-input</em> &amp;optional name &amp;key start channel restartable
<em class=def id="close-input">close-input</em> i-stream
<em class=def id="open-input*">open-input*</em> name &amp;key start channel restartable
</pre>

<p>These functions open and close input sound files.  <b>open-input</b>
takes either a string or a pathname and returns an IO object.
Various clm
functions use that object as a handle on the file.  The variable
<b>*clm-file-name*</b>, used as the default name in most such calls, is "/zap/test.snd" at CCRMA.</p>

<p>Open-input normally opens the sound file name and returns a list or perhaps a structure
that other clm functions can use to access the file.  If you don't
give a complete file name (name without the .snd extension),
open-input checks to see if there's either no .snd file or a later .cm
or .clm file, and in that case, suspends the current computation, makes the
sound file from the sources, then resumes the old computation, opening the
(newly computed) sound file.  If you are working in sections, and keep the
sections in separate files, the various layers of mixing can automatically
notice when some section has changed, and update everything for you.
Similarly, if all your sound files get deleted, the whole piece can still
regenerate itself in one operation. 
If you want the convenience of the directory
search (see <a href="#*clm-search-list*">*clm-search-list*</a>) <b>open-input*</b>.
Normally if open-input* can't find a file, it prints a warning and returns
nil.  If you would rather that it drop into the debugger with an option
to specify a new file name at that time, set the restartable argument to t.
</p>

<p>Open-input's &amp;key parameters are patterned after Lisp's load
function:
verbose (the default is nil) turns on some informational printout;
element-type can be nil (the default), or :sound.  In the latter case, the file passed to
open-input is assumed to contain sound data, no matter what extension it has, providing
a way to override the check for out of date sound files and so on;
if-does-not-exist can be nil or :error (the default).  In the latter case, if no sound file
associated with name can be found or created, you get an error message.
start is the sample to start at when reading the first data buffer.
end is the sample to stop at when reading the initial buffer (it defaults to buffer-size).
If you are reading only a small portion of a file many times, you can save some
time by setting explicitly the bounds of the initial read via start and end.
The implicit load triggered by open-input with a non-specific file name
sets 
<em class=def id="*open-input-pathname*">*open-input-pathname*</em> and 
<em class=def id="*open-input-truename*">*open-input-truename*</em> and notices
<em class=def id="*open-input-verbose*">*open-input-verbose*</em> (if t, print out informational
messages).</p>




<div class="innerheader" id="sound-let">sound-let</div>

<p><b>sound-let</b> is a form of let* that creates temporary sound streams
within with-sound.  Its syntax is like that of let and
with-sound:</p>

<pre class="indented">
(<em class=red>sound-let</em> ((temp-1 () (fm-violin 0 1 440 .1))
            (temp-2 () (fm-violin 0 2 660 .1)
                       (fm-violin .125 .5 880 .1)))
  (granulate-sound temp-1 0 2 0 2);temp-1's value is the name of the temp file
  (granulate-sound temp-2 1 1 0 2))
</pre>

<p>This creates two temporary files and passes them along to the subsequent calls
on granulate-sound.  The first list after the sound file identifier (i.e. after
"temp-1" in the example) is the list of <a href="#with-sound">with-sound</a> options to be passed
along when creating this temporary file.  These default to :output
with a unique name generated internally, and all other variables are taken from
the overall (enclosing) output file.  The rest of the list is the body of the
associated <a href="#with-sound">with-sound</a>, which can contain embedded sound-lets.
The difference between sound-let and a simple embedded with-sound is primarily that
sound-let names and later deletes the temporary files it creates, whereas with-sound leaves
its output intact.
</p>



<div class="innerheader">clm defaults</div>

<p>These default values are set in defaults.lisp. Generally, the default value is *clm-&lt;var&gt;, and the
current dynamic value of that variable is *&lt;var&gt;*.
</p>

<table class="spaced">
<tr><td><em class=def id="*clm-array-print-length*">*clm-array-print-length*</em></td><td>number of IO data buffer elements printed</td></tr>
<tr><td class="bluish"><em class=def id="*clm-channels*">*clm-channels*</em></td><td class="bluish">default output channels (1)</td></tr>
<tr><td><em class=def id="*clm-clipped*">*clm-clipped*</em></td><td>default for clipped arg in with-sound</td></tr>
<tr><td class="bluish"><em class=def id="*clm-dac-wait-default*">*clm-dac-wait-default*</em></td><td class="bluish">default choice of whether play function should wait for completion</td></tr>
<tr><td><em class=def id="*clm-data-format*">*clm-data-format*</em></td><td>default output sound file data format</td></tr>
<tr><td class="bluish"><em class=def id="*clm-date*">*clm-date*</em></td><td class="bluish">creation date of the current version</td></tr>
<tr><td><em class=def id="*clm-delete-reverb*">*clm-delete-reverb*</em></td><td>should with-sound delete the temporary reverb output (default nil)</td></tr>
<tr><td class="bluish"><em class=def id="*clm-file-buffer-size*">*clm-file-buffer-size*</em></td><td class="bluish">IO buffer sizes (in samples)</td></tr>
<tr><td><em class=def id="*clm-file-name*">*clm-file-name*</em></td><td>default sound file name</td></tr>
<tr><td class="bluish"><em class=def id="*clm-header-type*">*clm-header-type*</em></td><td class="bluish">default output sound file header type</td></tr>
<tr><td><em class=def id="*clm-init*">*clm-init*</em></td><td>name of site-specific initializations (see <a href="#clm-init.lisp">clm-init.lisp</a>)</td></tr>
<tr><td class="bluish"><em class=def id="*clm-instruments*">*clm-instruments*</em></td><td class="bluish">list of the currently loaded clm instruments</td></tr>
<tr><td><em class=def id="*clm-locsig-type*">*clm-locsig-type*</em></td><td>locsig interpolation choice (<b>mus-interp-linear</b> or <b>mus-interp-sinusoidal</b>)</td></tr>
<tr><td class="bluish"><em class=def id="*clm-news*">*clm-news*</em></td><td class="bluish">brief list of recent changes (HISTORY.clm)</td></tr>
<tr><td><em class=def id="*clm-notehook*">*clm-notehook*</em></td><td>default for notehook arg in with-sound</td></tr>
<tr><td class="bluish"><em class=def id="*clm-play*">*clm-play*</em></td><td class="bluish">default for play arg in with-sound</td></tr>
<tr><td><em class=def id="*clm-player*">*clm-player*</em></td><td>user-supplied DAC function</td></tr>
<tr><td class="bluish"><em class=def id="*clm-reverb-channels*">*clm-reverb-channels*</em></td><td class="bluish">reverb stream chans in with-sound</td></tr>
<tr><td><em class=def id="*clm-safety*">*clm-safety*</em></td><td>default safety setting (run loop debugging choices)</td></tr>
<tr><td class="bluish"><em class=def id="*clm-search-list*">*clm-search-list*</em></td><td class="bluish">pathname list for file searches (open-input*)</td></tr>
<tr><td><em class=def id="*clm-srate*">*clm-srate*</em></td><td>default sampling rate (44100)</td></tr>
<tr><td class="bluish"><em class=def id="*clm-statistics*">*clm-statistics*</em></td><td class="bluish">default statistics arg in with-sound</td></tr>
<tr><td><em class=def id="*clm-table-size*">*clm-table-size*</em></td><td>default table-lookup table size (in Scheme, the associated function is <b>clm-table-size</b>)</td></tr>
<tr><td class="bluish"><em class=def id="*clm-tempfile-data-format*">*clm-tempfile-data-format*</em></td><td class="bluish">intermediate with-sound file data format</td></tr>
<tr><td><em class=def id="*clm-tempfile-header-type*">*clm-tempfile-header-type*</em></td><td>intermediate with-sound file header type</td></tr>
<tr><td class="bluish"><em class=def id="*clm-version*">*clm-version*</em></td><td class="bluish">version identifier (a number &mdash; also *clm-revision*)</td></tr>
<tr><td><em class=def id="*output*">*output*</em></td><td>current output stream (for outa and friends)</td></tr>
<tr><td class="bluish"><em class=def id="*reverb*">*reverb*</em></td><td class="bluish">current reverb stream</td></tr>
<tr><td><em class=def id="two-pi">two-pi</em></td><td>2*pi</td></tr>
</table>

<p><b>*clm-player*</b> can be used to override CLM's normal play routine (which
calls sndplay in most cases).
</p>

<pre class="indented">
(setf *clm-player* (lambda (name) (clm::run-in-shell "sndplay" (format nil "~A -bufsize 1024" name))))
</pre>

<p>On machines with plenty of memory and slow disks, you can speed up CLM
computations by setting <b>*clm-file-buffer-size*</b> to some number larger
than its default (65536):
</p>

<pre class="indented">
  (let ((*clm-file-buffer-size* (* 1024 1024))) (<a class=quiet href="#with-sound">with-sound</a> ...) <!-- ) -->
</pre>

<p>The macro <em class=def id="with-offset">with-offset</em> can be used to set local
begin time offsets.  Its argument is in seconds:</p>

<pre class="indented">
(<a class=quiet href="#with-sound">with-sound</a> () 
  (fm-violin 0 1 440 .1)
  (<em class=red>with-offset</em> 1.0
    (fm-violin 0 .25 660 .1)) ; actually starts at 1.0
  (fm-violin .5 440 .1))
</pre>




<div class="innerheader">examples</div>

<p>The file <a href="files">files</a> describes briefly each of the files in the clm
directory;  <a href="clm-example.lisp">clm-example.lisp</a> shows one way to write notelists;  
<a href="cm-clm.lisp">cm-clm.lisp</a> is
a brief example of using Rick Taube's Common Music to drive CLM.  There are several
*.clm files included in the clm distribution.  clm-test.lisp runs my standard
set of regression tests, exercising many of the instruments. <a href="pitches.cl">pitches.cl</a>
provides the standard pitch names as lisp variables (a4 = 440.0 and so on).
</p>



<div class="innerheader" id="run*">run*</div>

<p><b>run*</b> takes two arguments, a list of variables, and the usual
run macro body.  The run body is executed (in C normally) and then
the variables are set to the values they had when the run loop
exited. 
This extension of <a href="#run">run</a> is
needed because in C
instruments, everything that happens within the run loop is normally hidden
from the lisp interpreter; if you set a global variable's value, for example,
only the run-specific version of that variable is affected.  You need <b>run*</b>
to return such values back to Lisp.
</p>

<pre class="indented">
(<a class=quiet href="#definstrument">definstrument</a> p (beg dur frq amp)
  (let* ((s (<a class=quiet href="#make-oscil">make-oscil</a> frq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (hi 0.0))
    (<em class=red>run*</em> (amp hi)
      (loop for i from start below end do
	(incf hi .001)
	(<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> s)))))
    (print (format nil "~A ~A" hi amp))))
</pre>

<p>A more useful instrument is Michael Edwards' <a href="track-rms.ins">track-rms.ins</a>; see also
the sr3 instrument in ug.ins.
Here's another instrument that implements legato between notes by using the previous note's phases:
</p>

<pre class="indented">
(defstruct fmins carrier modulator)
(<a class=quiet href="#definstrument">definstrument</a> fmsimp (beg dur frq amp ind &amp;optional previous-oscils)
  (let* ((start (floor (* *srate* beg)))
	 (end (+ start (floor (* *srate* dur))))
	 (carrier (if previous-oscils
		      (fmins-carrier previous-oscils)
		    (<a class=quiet href="#make-oscil">make-oscil</a>)))
	 (modulator (if previous-oscils
			(fmins-modulator previous-oscils)
		      (<a class=quiet href="#make-oscil">make-oscil</a>))))
    (setf (<a class=quiet href="#mus-frequency">mus-frequency</a> carrier) frq)
    (setf (<a class=quiet href="#mus-frequency">mus-frequency</a> modulator) frq)
    (<em class=red>run*</em> (carrier modulator)
     (loop for i from start below end do
       (<a class=quiet href="#outa">outa</a> i (* amp (<a class=quiet href="#oscil">oscil</a> carrier (* ind (<a class=quiet href="#oscil">oscil</a> modulator)))))))
    (if previous-oscils
	(progn
	  (setf (fmins-carrier previous-oscils) carrier)
	  (setf (fmins-modulator previous-oscils) modulator)))))

;;; (defvar oscs (make-fmins :carrier (<a class=quiet href="#make-oscil">make-oscil</a>) :modulator (<a class=quiet href="#make-oscil">make-oscil</a>)))
;;; (<a class=quiet href="#with-sound">with-sound</a> () (fmsimp 0 1.01 440 .1 0.0 oscs) (fmsimp 1.01 1 660 .1 0.0 oscs))
;;; (<a class=quiet href="#with-sound">with-sound</a> () (fmsimp 0 1.01 440 .1 0.0) (fmsimp 1.01 1 660 .1 0.0))
;;;     the 1.01 (as opposed to 1.0) is needed because the phases line up just by chance in the 1.0 case
;;;     for portamento, the instrument could notice an in-coming osc set and
;;;     change the frequency envelope accordingly
</pre>



<div class="header" id="debugging-aids">Debugging</div>

<!-- INDEX debugging-aids:Debugging  -->

<p>CLM provides several built-in data display and instrument debugging aids.
But debugging an instrument is still too much pain.  I suggest that you
develop the algorithm in Snd/Scheme where there are elaborate and
robust debugging tools. 
</p>

<p>The optimize safety option can be used to check for array index and null
generator problems (these will be reported as bus errors and segmentation
faults, sigh).  <code>(pushnew :debug *features*)</code> before loading CLM to see what it
is sending to the C compiler.
</p>



<div class="innerheader">The error handler</div>

<p>When you hit an error within with-sound, depending on the context of the error and
the lisp you're running, you'll see a variety of restart options:</p>

<pre class="indented">
  Restart actions (select using :continue):
   0: return from break.
   1: try to exit current note cleanly and go on.
   2: abort current note.
   3: close files and return to top-level.
   4: jump past remaining notes.
</pre>

<p>The last four are provided by CLM.  The first tries to jump to the end of the
current instrument, allowing open input files to be closed and so forth.
The second jumps out of the current note, but tries to continue processing
the body of with-sound.  The third closes all files and jumps out of with-sound.
The fourth jumps to the end of the body of with-sound and tries to handle 
all the usual with-sound closing options such as reverb, statistics, and
scaling.
</p>

<p>If you hit a C error (segfault, etc), start gdb with lisp ('gdb /usr/local/lisp/acl'),
'run', load clm, run your instrument, then when the error drops you into the gdb debugger, 'where'.  This
should give you some idea where the problem is.  In the worst case, trace clm::run-in-shell and compile/load
the instrument to find out what the C compilation sequence is on your machine; next, make whatever changes
you like to the instrument C code (produced by the run macro, named clm_INSNAME.c); to add a print
statement that will send its output to the lisp listener, use the function mus_error with a first argument
of 0; next run the C compiler and loader, making a new instrument object file, start gdb with lisp, run
lisp loading clm, load your instrument, and run it.
</p>

<p>In Windows using ACL, you can get into the debugger via:
</p>

<pre class="indented">
c:\program files\acl80\mlisp.exe -! -I mlisp.dxl 
</pre>

<p>or some facsimile thereof.  When you hit a segfault, get a call stack (stack trace).
I don't know how to print out function arguments in this case.
In ACL, you can maximize the lisp-level information at an error with:
</p>

<pre class="indented">
:zoom :all t :verbose t :count t
</pre>

<p>ffi-test.lisp has a bunch of FFI calls outside the with-sound/definstrument context.
The base CLM test suite is clm-test.lisp, but it's more of a "regression" test &mdash; I run
it in the various lisps whenever I make some code change.
</p>



<div class="header" id="appendices">Appendices</div>

<div class="innerheader" id="header-types">header and data types</div>

<!-- INDEX header-types:Sound file formats  -->
<!-- INDEX header-types:Data formats  -->
<!-- INDEX header-types:Headers  -->

<p>CLM can write NeXT/Sun, AIFF/AIFC, RIFF ("wave"), RF64, CAFF, raw (no header), NIST-sphere, and "old-style" IRCAM headers.
The default choice is set by <a href="#*clm-header-type*">*clm-header-type*</a>
set in <a href="defaults.lisp">defaults.lisp</a>. The output data format is normally
16-bit signed (2's complement) integer; the default is set by 
<a href="#*clm-data-format*">*clm-data-format*</a>.
CLM can read most standard headers, and can read and write most uncompressed
data formats.</p>

<pre class="indented">
read/write (many data formats):

    NeXT/Sun/DEC/AFsp
    AIFF/AIFC
    RIFF (Microsoft wave)
    RF64
    IRCAM (old style)
    NIST-sphere
    CAFF
    no header ("raw")

read-only (in selected data formats):

    8SVX (IFF), EBICSF, INRS, ESPS, SPPACK, ADC (OGI), AVR, VOC, PVF,
    Sound Tools, Turtle Beach SMP, SoundFont 2.0, Sound Designer I, PSION, MAUD, Kurzweil 2000,
    Gravis Ultrasound, ASF, PAF, CSL, Comdisco SPW, Goldwave sample, omf, quicktime, sox,
    Sonic Foundry, SBStudio II, Delusion digital, Digiplayer ST3, Farandole Composer WaveSample,
    Ultratracker WaveSample, Sample Dump exchange, Yamaha SY85, SY99, and TX16, Covox v8, AVI, 
    Impulse tracker, Korg, Akai, Turtle Beach, Matlab-5

automatically translated to a readable format:

    IEEE text, Mus10, SAM 16-bit (modes 1 and 4), AVI, NIST shortpack, HCOM, Intel, 
    IBM, and Oki (Dialogic) ADPCM, G721, G723_24, G723_40, MIDI sample dump, Ogg, Speex, 
    Flac, Midi, Mpeg, Shorten, Wavepack (via external programs)
</pre>

<p>I am willing to add almost anything to this list.
See <a href="headers.c">headers.c</a> for all the gory details.  In
<a href="#with-sound">with-sound</a>, you can set the output header type with
the keyword :header-type, and the data type with the :data-format keyword.</p>

<p>The CLM names for the output header types, as used with the :header-type argument to with-sound, are
<em class="noem" id="mus-aiff">mus-aiff</em>, <em class="noem" id="mus-aifc">mus-aifc</em>, <em class="noem" id="mus-next">mus-next</em>, 
<em class="noem" id="mus-riff">mus-riff</em>, <em class="noem" id="mus-rf64">mus-rf64</em>, and <em class="noem" id="mus-ircam">mus-ircam</em>.
The data-formats
that are exported from the clm package are <em class="noem" id="mus-bshort">mus-bshort</em>, mus-lshort, mus-bint, mus-lint,
mus-bfloat, mus-lfloat, mus-mulaw, mus-alaw, mus-byte, mus-ubyte, mus-b24int, mus-l24int, mus-bdouble,
and mus-ldouble.  The "b" stands for big-endian, "l" for little-endian, "u" for unsigned.
The other header and data format possibilities are listed in initmus.lisp.</p>

<em class="noem" id="raw-data"></em>
<!-- INDEX raw-data:raw data  -->

<p>If you are trying to read raw (no header) sound files, CLM's default settings for
the sampling rate, channels, and data format are 44100, 2, and mus-bshort
respectively.  To change these, call (<em class="noem" id="mus-set-raw-header-defaults">mus-set-raw-header-defaults</em> srate chans format):
</p>

<pre class="indented">
(<a class=quiet href="#mus-set-raw-header-defaults">mus-set-raw-header-defaults</a> 8012 1 mus-mulaw)
(<a class=quiet href="#open-input">open-input</a> "raw.snd")
</pre>

<p>treats "raw.snd" as mono &micro;law data at 8012 Hz.</p>



<div class="innerheader" id="clm-init.lisp">clm-init.lisp</div>

<!-- INDEX clm-init.lisp:CLM Initialization  -->

<p>If the file clm-init.lisp exists in the same directory as <a href="all.lisp">all.lisp,</a> or
if you set the clm variable *clm-init* to point to some file, then CLM
loads that file upon initialization.  
Here is my clm-init.lisp:</p>

<pre class="indented">
(compile-and-load "v")
(compile-and-load "jcrev")
;;; my two favorite instruments

(setf *clm-search-list* 
  (append *clm-search-list* 
	  (list "/home/bil/cl/oboe.snd"
		"/home/bil/test/sounds/test.snd")))
;;; these are my standard sound file directories &mdash; by including 
;;; these in the search list I don't need to remember where each 
;;; file happens to be.  The file names are just fillers &mdash;
;;; the important part of the path is the directory.
</pre>



<div class="innerheader" id="savedimages">saved images</div>

<!-- INDEX savedimages:saved images -->

<p>Many lisps have some mechanism to dump the current lisp image as an
executable file.  In ACL or MCL, some of CLM's state at run-time is handled in C-based
foreign-function modules that are opaque to Lisp, so there are cases where the naive use
of dumplisp (acl), or save-application (mcl)
can fail with a segmentation fault or some other equally
un-informative error message.  This should only be a problem when the saved image
has called clm-initialize-links (within with-sound or dac or some such function);
if you build a clm image and immediately save it, everything
should work without problem.  Once clm-initialize-links has been called,
the C modules assume they have been initialized; if code in the saved version of
a module is then executed, the un-initialized variables may be accessed.
To get around this problem, call
<em class=def id="restart-clm">restart-clm</em> before doing anything in the newly executed image.
</p>


</body>
</html>
