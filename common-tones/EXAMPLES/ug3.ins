(definstrument sample-desc (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (start (floor (* beg *srate*)))
	 (printed nil)
	 (end (+ start (floor (* dur *srate*)))))
    (run
     (loop for i from start to end do
       (if (not printed)
	   (progn
	     (if (not (string= (mus-describe os) "oscil freq: 440.000Hz, phase: 0.000"))
		 (clm-print "describe oscil: ~A~%" (mus-describe os)))
	     (if (> (abs (- (mus-frequency os) freq)) .001)
		 (clm-print "osc freq: ~A (~A)~%" (mus-frequency os) freq))
	     (setf printed t)))
       (outa i (* amp (oscil os)))))))

(definstrument sample-mdat (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (table-size 256)
	 (j 0)
	 (table (make-double-array table-size))
	 (buf (make-table-lookup freq 0.0 table table-size)))
    (do ((i 0 (1+ i)))
	((= i table-size))
      (setf (aref table i) (double (/ i table-size))))
    (run
     (loop for i from start to end do
       (outa i (* amp (aref (mus-data buf) j) (table-lookup buf)))
       (setf j (1+ j))
       (if (>= j table-size) (setf j 0))))))

(definstrument sample-xtab (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (flt (make-filter 8))
	 (os (make-oscil freq)))
    (do ((i 0 (1+ i)))
	((= i 8))
      (setf (aref (mus-xcoeffs flt) i) (double (/ i 16)))
      (setf (aref (mus-ycoeffs flt) i) (- 0.5 (double (/ i 16)))))
    (run
     (loop for i from start to end do
       (outa i (* amp
		  (+ (aref (mus-xcoeffs flt) 4)
		     (aref (mus-ycoeffs flt) 4))
		  (filter flt (oscil os))))))))

(definstrument sample-xts (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (flt (make-filter 8))
	 (os (make-oscil freq)))
    (do ((i 0 (1+ i)))
	((= i 8))
      (setf (aref (mus-xcoeffs flt) i) (double (/ i 16)))
      (setf (aref (mus-ycoeffs flt) i) (- 0.5 (double (/ i 16)))))
    (run
     (loop for i from start to end do
       (setf (aref (mus-xcoeffs flt) 0) .5)
       (setf (aref (mus-ycoeffs flt) 0) .5)       
       (outa i (* amp
		  (+ (aref (mus-xcoeffs flt) 0)
		     (mus-ycoeff flt 0))
		  (filter flt (oscil os))))))))

(definstrument sample-srl2 (beg dur amp speed freq)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (os1 (make-oscil freq))
	 (os2 (make-oscil (* freq 2)))
	 (sr1 (make-src :srate speed))
	 (sr2 (make-src :srate speed)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (+ (src sr1 0.0 #'(lambda (dir) (oscil os1)))
			   (src sr2 0.0 #'(lambda (dir) (oscil os2))))))))))

(definstrument sample-srll (beg dur amp speed freq)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (os (make-oscil freq))
	 (sr1 (make-src :srate speed))
	 (sr2 (make-src :srate speed)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (src sr1 0.0 #'(lambda (dir)
					 (src sr2 0.0
					      #'(lambda (dir)
						  (oscil os)))))))))))

(definstrument sample-srl3 (beg dur amp speed freq)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (os1 (make-oscil freq))
	 (os2 (make-oscil freq))
	 (sr1 (make-src :srate speed))
	 (sr2 (make-src :srate speed))
	 (sr3 (make-src :srate speed)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (+ (src sr1 0.0 #'(lambda (dir)
					    (src sr2 0.0
						 #'(lambda (dir)
						     (oscil os1)))))
			   (src sr3 0.0 #'(lambda (dir)
					    (oscil os2))))))))))

(definstrument sample-grn2 (beg dur amp speed freq)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (os (make-oscil freq))
	 (sr (make-granulate :expansion speed)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (granulate sr
				   #'(lambda (dir) (oscil os))
				   #'(lambda (g) 0))))))))

(definstrument sample-grn3 (beg dur amp speed file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (rd (make-readin file))
	 (sr (make-src :srate speed))
	 (gr (make-granulate :expansion speed)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (granulate gr #'(lambda (dir)
					  (src sr 0.0 #'(lambda (dir)
							  (readin rd)))))))))))

(definstrument sample-cnv (beg dur amp speed file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (rd (make-readin file))
	 (sr (make-src :srate speed))	 
	 (filt (make-double-array 8)))
    (do ((i 0 (1+ i))) ((= i 8)) (setf (aref filt i) (double 0.0)))
    (setf (aref filt 4) (double 1.0))
    (let ((ff (make-convolve :filter filt)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (convolve ff #'(lambda (dir)
					 (src sr 0.0 #'(lambda (dir)
							 (readin rd))))))))))))

(definstrument sample-cnv1 (beg dur amp speed file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (rd (make-readin file))
	 (sr (make-src :srate speed :input rd))	 
	 (filt (make-double-array 8)))
    (do ((i 0 (1+ i))) ((= i 8)) (setf (aref filt i) (double 0.0)))
    (setf (aref filt 4) (double 1.0))
    (let ((ff (make-convolve :filter filt)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (convolve ff #'(lambda (dir)
					 (src sr))))))))))

(definstrument sample-cnv2 (beg dur filter file &optional (amp 1.0) (chan 0))
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (fil (open-input file :channel chan))
	 (filt (open-input filter))
	 (ff (make-convolve :input fil :filter filt :filter-scaler 0.5)))
    (run
     (loop for i from start to end do (outa i (* amp (convolve ff)))))
    (close-input filt)
    (close-input fil)))

(definstrument sample-pvoc1 (beg dur amp size file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (fil (make-readin file))
	 (sr (make-phase-vocoder :fft-size size)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (phase-vocoder sr
				       #'(lambda (dir)
					   (readin fil)))))))))

(definstrument sample-pvoc2 (beg dur amp size file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (fil (make-readin file))
	 (sr (make-phase-vocoder :fft-size size)))
      (run
       (loop for i from start to end do
	 (outa i (* amp (phase-vocoder sr
				       #'(lambda (dir)
					   (readin fil))
				       nil
				       #'(lambda (closure)
					   (if (not (= (mus-location sr) 0))
					       (clm-print "outctr: ~A" (mus-location sr)))
					   t)
				       nil)))))))

(definstrument test-power-env (dur env)
  (let* ((pe (make-power-env :envelope env :duration dur :scaler .5))
	 (envs (first pe))
	 (total-envs (second pe))
	 (current-env (third pe))
	 (current-pass (fourth pe))
	 (nd (floor (* dur *srate*))))
    (run
     (loop for i from 0 below nd do
       (declare (type :mus-any* envs)
		(type :integer total-envs current-env current-pass))
       (outa i (power-env envs total-envs current-env current-pass))))))

(definstrument sample-osc (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (arr (make-array 20))
	 (arrfrq (make-double-array 20 :initial-element (double 0.0))))
    (do ((i 0 (1+ i)))
	((= i 20))
      (setf (aref arrfrq i) (double (* (1+ i) 100.0)))
      (setf (aref arr i) (make-oscil (* (1+ i) 100))))
    (run
     (loop for i from start to end do
       (let ((sum 0.0))
	 (do ((i 0 (1+ i)))
	     ((= i (length arr)))
	   (when (oscil? (aref arr i))
	     (setf (mus-frequency (aref arr i)) (aref arrfrq i))
	     (if (> (abs (- (mus-frequency (aref arr i)) (aref arrfrq i))) .001)
		 (clm-print "oops ~A ~A" (mus-frequency (aref arr i)) (aref arrfrq i)))
	     (incf sum (oscil (aref arr i)))))
	 (outa i (* amp .05 sum)))))))

(definstrument sample-strs (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (os (make-oscil freq))
	 (filename "oboe.snd"))
    (run
     (loop for i from start to end do
       (if (not (string= "oscil" (mus-name os))) (clm-print "oscil name: ~A" (mus-name os)))
       (if (> (abs (- (sound-duration filename) 2.305)) .001) (clm-print "sound-duration: ~A" (sound-duration filename)))
       (if (and (not (string-equal (mus-header-type-name (sound-header-type "oboe.snd")) "Sun"))
		(not (string-equal (mus-header-type-name (sound-header-type "oboe.snd")) "Sun/Next")))
	   (clm-print "header type: ~A" (mus-header-type-name (sound-header-type "oboe.snd"))))
       (if (not (string-equal (mus-data-format-name (sound-data-format "oboe.snd")) "big endian short (16 bits)"))
	   (clm-print "data format: ~A" (mus-data-format-name (sound-data-format "oboe.snd"))))
       (if (not (= (sound-datum-size "oboe.snd") 2)) (clm-print ";datum size: ~A" (sound-datum-size filename)))
       (if (not (= (sound-chans "oboe.snd") 1)) (clm-print ";chans: ~A" (sound-chans filename)))
       (if (not (= (sound-data-location filename) 28)) (clm-print ";data-location: ~A" (sound-data-location filename)))
       (if (not (= (sound-length filename) 101684)) (clm-print ";length: ~A" (sound-length filename)))
       (if (not (= (sound-samples filename) 50828)) (clm-print ";samples: ~A" (sound-samples filename)))              
       (if (not (= (sound-framples filename) 50828)) (clm-print ";framples: ~A" (sound-samples filename)))
       (if (not (= (sound-srate filename) 22050)) (clm-print ";srate: ~A" (sound-srate filename)))       
       (outa i (oscil os))))))

(definstrument sample-flt (beg dur freq amp)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (fltdat (make-double-array 3 :initial-element (double 3.14)))
	 (intdat (make-integer-array 3 :initial-element 3))
	 (flt (make-filter 8))
	 (os (make-oscil freq)))
    (do ((i 0 (1+ i)))
	((= i 8))
      (setf (aref (mus-xcoeffs flt) i) (double (/ i 16)))
      (setf (aref (mus-ycoeffs flt) i) (- 0.5 (double (/ i 16)))))
    (run
     (loop for i from start to end do
       (declare (type :int* intdat)
		(type :double* fltdat))
       (let ((xs (mus-xcoeffs flt)))
	 (if (or (> (abs (- (aref xs 1) (mus-xcoeff flt 1))) .001)
		 (> (abs (- (aref xs 1) 0.0625)) .001))
	      (clm-print "~A ~A~%" (aref xs 1) (mus-xcoeff flt 1))))
       (let ((data (mus-data flt)))
	 (if (> (aref data 0) 1.0) (clm-print "data overflow? ~A~%" (aref data 0))))
       (if (not (= (aref intdat 1) 3)) (clm-print "intdat let: ~A~%" (aref intdat 1)))
       (if (> (abs (- (aref fltdat 1) 3.14)) .001) (clm-print "fltdat let: ~A~%" (aref fltdat 1)))
       (outa i (* amp (filter flt (oscil os))))))))

(definstrument sample-arrintp (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (arr (make-double-array 101))
	 (start (floor (* beg *srate*)))
	 (len (floor (* dur *srate*)))
	 (end (+ start len))
	 (loc 0.0)
	 (loc-incr (/ 100.0 len)))
    (do ((i 0 (1+ i))
	 (x 0.0 (+ x .01)))
	((= i 100))
      (setf (aref arr i) (double x)))
    (run
     (loop for i from start to end do
       (outa i (* amp (array-interp arr loc) (oscil os)))
       (setf loc (+ loc loc-incr))))))

(definstrument sample-if (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (k -123)
	 (j 0)
	 (bool t))
    (run
     (loop for i from start to end do
       (declare (type :integer j k)
		(type :boolean bool))
       (if (and (= i start) (not (= k -123))) (clm-print "init k: ~A~%" k))
       (if (not bool) (clm-print "bool: ~A~%" bool))
       (setf j (if bool 1 2))
       (if (not (= j 1)) (clm-print "if expr: ~A~%" j))
       (if bool (setf j 3) (setf j 4))
       (if (not (= j 3)) (clm-print "if statement: ~A~%" j))
       (if (integerp k) (setf j 5))
       (if (not (= j 5)) (clm-print "int k? ~A ~A" (integerp k) j))
       (if (= j k) (setf j 6))
       (if (= j 6) (clm-print "j if false: ~A" j))
       (setf j (if (= j k) (+ k 7) (+ k 8)))
       (if (not (= j (+ k 8))) (clm-print "if false expr: ~A ~A" j k))
       (setf j (if (> j -1234) (if (> k -1234) 9 10) 11))
       (if (not (= j 9)) (clm-print "if 2 expr: ~A" j))
       (setf j (if (> j -1234) (progn (setf k 0) 12) 13))
       (if (not (= j 12)) (clm-print "if progn expr: ~A" j))
       (if (> j -1234) (progn (setf j 1234) (setf j 14)) (setf j 15))
       (if (not (= j 14)) (clm-print "if progn: ~A" j))
       (if (> j -1234) (setf j (prog1 16 (setf k 0))))
       (if (not (= j 16)) (clm-print "if prog1: ~A" j))
       (if (> j -1234) (setf j (prog2 (setf k 0) 17 (setf k 0))))
       (if (not (= j 17)) (clm-print "if prog2: ~A" j))
       #-clisp (setf k (loop for j from 1 to 4 sum j))
       #-clisp (if (not (= k 10)) (clm-print "loop sum: ~A~%" k))
       (if (> j -1234) (setf j (prog2 (setf k 0) (if (> j -1234) (progn (setf k 123) 18) 19) (setf k 0))))
       (if (not (= j 18)) (clm-print "if nested prog2: ~A" j))
       (setf j 123)
       (cond ((= j 0) (setf k -1))
	     ((= j 12) (setf k -2))
	     ((= j 123) (setf k -3))
	     (t (setf k -4)))
       (if (not (= k -3)) (clm-print "cond: ~A ~A" j k))
       (setf k (cond ((= j 0) -4)
		     ((= j 12) -5)
		     (t -6)))
       (if (not (= k -6)) (clm-print "cond expr: ~A ~A" j k))
       (setf k (let ((a 123))
		 (if (> a 0)
		     20
		   32)))
       (if (not (= k 20)) (clm-print "let expr: ~A ~A" j k))
       (let ((a 123))
	 (setf k a))
       (if (not (= k 123)) (clm-print "let: ~A ~A" j k))
       (setf k 123)
       (setf bool (= k 123))
       (if (not bool) (clm-print "bool expr: ~A" bool))
       (setf bool (if (= k 123) (> k 0) (< k 0)))
       (if (not bool) (clm-print "if bool expr: ~A" bool))
       (setf j 0)
       (setf k (do ((m 0 (1+ m)))
		   ((= m 3) j)
		 (incf j)))
       (if (not (= k 3)) (clm-print "do expr: ~A" k))
       (dotimes (m 2)
	 (decf k))
       (if (not (= k 1)) (clm-print "dotimes: ~A" k))
       (outa i (* amp (oscil os)))))))

(definstrument sample-arrfile (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (arr (make-double-array 100 :initial-element (double 0.0)))
	 (ctr 0)
	 (dir 1))
    (do ((i 0 (1+ i)))
	((= i 100))
      (setf (aref arr i) (double (* amp (+ -.5 (* i .01))))))
    (array->file "test.data" arr 100 22050 1)
    (do ((i 0 (1+ i)))
	((= i 100))
      (setf (aref arr i) (double 0.0)))
    (file->array "test.data" 0 0 100 arr)
    (run
     (loop for i from start to end do
       (declare (type :integer ctr dir)
		(type :double* arr))
       (outa i (* (aref arr ctr) (oscil os)))
       (setf ctr (+ ctr dir))
       (if (>= ctr 99) (setf dir -1)
	 (if (<= ctr 0) (setf dir 1)))))))

(definstrument sample-write ()
  (let ((file (c-create-file "test.data"))
	(arr (make-array 16 :initial-element 0.0)))
    (run
     (loop for i from 0 to 10 do
       (setf (aref arr i) (* i .1))
       (if (= i 9) (clm-write-floats file arr 10))))
    (c-close file)))

(definstrument sample-read ()
  (let ((file (c-open-input-file "test.data"))
	(arr (make-array 16 :initial-element 0.0)))
    (run
     (loop for i from 0 to 10 do
       (if (= i 0) (clm-read-floats file arr 10))      
       (if (and (< i 10)
		(> (abs (- (aref arr i) (* i .1))) .001))
	   (clm-print "arr[~D] = ~F~%" i (aref arr i)))))
    (c-close file)))

(definstrument sample-iwrite ()
  (if (mus-file-probe "testi.data") (delete-file "testi.data"))
  (let ((file (c-open-output-file "testi.data"))
	(arr (make-integer-array 16 :initial-element 0)))
    (run
     (loop for i from 0 to 10 do
       (declare (type :int* arr))
       (setf (aref arr i) i)
       (if (= i 9) (clm-write-ints file arr 10))))
    (c-close file)))

(definstrument sample-iread ()
  (let ((file (c-open-input-file "testi.data"))
	(arr (make-integer-array 16 :initial-element 0)))
    (run
     (loop for i from 0 to 10 do
       (declare (type :int* arr))
       (if (= i 0) (clm-read-ints file arr 10))      
       (if (and (< i 10)
		(not (= (aref arr i) i)))
	   (clm-print "i arr[~D] = ~D~%" i (aref arr i)))))
    (c-close file)))

(defvar glb-int 123)
(defvar glb-flt 3.14)
(defvar glb-farr (make-double-float-array 32 :initial-element 1.0))
(defvar glb-iarr (make-integer-array 32 :initial-element 3))
(defvar glb-osc (make-oscil 440.0))

#-clisp
(definstrument test-reflect ()
  (let* ((arr (make-double-float-array 32))
	 (iarr (make-integer-array 32))
	 (flt 1.0)
	 (int 1)
	 (osc (make-oscil 440.0 0.0))
	 (dly (make-delay 30))
	 (cmb (make-comb .7 30))
	 (noc (make-notch .7 30))
	 (allp (make-all-pass .4 .5 30))
	 (ave (make-moving-average 30))
	 (sq (make-square-wave 440.0))
	 (tr (make-triangle-wave 440.0))
	 (pu (make-pulse-train 440.0))
	 (sw (make-sawtooth-wave 440.0))
	 (p1 (make-one-pole 1.0 0.9))
	 (z1 (make-one-zero 1.0 0.9))
	 (p2 (make-two-pole 1.0 0.0 0.1))
	 (z2 (make-two-zero 1.0 0.9 0.1))
	 (rn (make-rand 440.0))
	 (rni (make-rand-interp 440.0))
	 (tbl (make-table-lookup 440.0))
	 (wt (make-wave-train 440.0))
	 (wt-data (mus-data wt))
	 (asy (make-asymmetric-fm 440.0 :ratio 0.8))
	 (frm (make-formant 440.0 .5))
	 (fir (let ((coeffs (make-double-float-array 8)))
		(do ((i 0 (1+ i)))
		    ((= i 8))
		  (setf (aref coeffs i) (double (* i .03))))
		(make-fir-filter 8 coeffs)))
	 (iir (let ((coeffs (make-double-float-array 8)))
		(do ((i 0 (1+ i)))
		    ((= i 8))
		  (setf (aref coeffs i) (double (* i .01))))
		(make-iir-filter 8 coeffs)))
	 (fiir (let ((xcoeffs (make-double-float-array 8))
		     (ycoeffs (make-double-float-array 8)))
		 (do ((i 0 (1+ i)))
		     ((= i 8))
		   (setf (aref xcoeffs i) (double (* i .01)))
		   (setf (aref ycoeffs i) (double (* i .02))))
		 (make-filter 8 xcoeffs ycoeffs)))
	 (ssb (make-ssb-am 440.0 20))
	 (e (make-env '(0 0 1 1) :length 11))
	 (temp-file (let ((data (make-double-float-array 32)))
		      (do ((i 0 (1+ i)))
			  ((= i 32))
			(setf (aref data i) (double (* i .01))))
		      (array->file "temp.snd" data 32 22050 1)
		      "temp.snd"))
	 (reader (make-src :input temp-file :srate 2.0))
	 (rdin (make-readin temp-file))
	 (pvoc (make-phase-vocoder :fft-size 128))
	 (loc (make-locsig :channels 1 :degree 23 :distance 2.5))
	 (grn (make-granulate :expansion 1.4))
	 (cnv (make-convolve :filter (make-double-float-array 16 :initial-element .1)))
	 (f2s (make-file->sample temp-file))
	 (f2f (make-file->frample temp-file))
	 (f2f-frample (make-double-array 1)))
    (setf (aref wt-data 0) (double .1))
    (setf glb-int 123)
    (setf glb-flt 3.14)
    (setf glb-farr (make-double-float-array 32 :initial-element 1.0))
    (setf glb-iarr (make-integer-array 32 :initial-element 3))
    (setf glb-osc (make-oscil 440.0))
    
    (run* (int flt arr iarr osc dly cmb noc allp sw tr pu sq
	   p1 z1 p2 z2 rn rni tbl asy frm fir iir fiir e ave reader
	   wt ssb pvoc loc rdin grn cnv f2s f2f glb-int glb-flt glb-osc glb-iarr glb-farr)
	  
      (loop for i from 0 below 10 do
	(declare (type :int* iarr)
		 (type :double* arr))
	(setf (aref arr i) (* i .5))
	(setf (aref iarr i) (* i 2))
	(setf flt 2.0)
	(setf int 2)
	(setf (aref glb-farr i) (* i .5))
	(setf (aref glb-iarr i) (* i 2))
	(setf (mus-frequency osc) 220.0)
	(oscil osc (aref arr i))
	(if (= i 0)
	    (progn
	      (setf (mus-feedback cmb) .9)
	      (setf (mus-feedforward noc) .8)
	      (setf (mus-feedback allp) .66)
	      (setf (mus-feedforward allp) .55)
	      (setf (mus-scaler sq) 0.5)
	      (setf (mus-scaler tr) 0.55)
	      (setf (mus-scaler pu) 0.6)
	      (setf (mus-scaler sw) 0.65)
	      (setf (mus-frequency sw) 220.0)
	      (setf (mus-frequency tr) 220.0)
	      (setf (mus-frequency sq) 220.0)
	      (setf (mus-frequency pu) 220.0)
	      (setf (mus-xcoeff z1 0) 0.0)
	      (setf (mus-xcoeff z2 1) 0.2)
	      (setf (mus-ycoeff p1 1) 0.8)
	      (setf (mus-ycoeff p2 1) 0.3)
	      (setf (mus-scaler rn) 0.5)
	      (setf (mus-frequency rn) 220.0)	      
	      (setf (mus-scaler rni) 0.5)
	      (setf (mus-frequency rni) 220.0)
	      (setf (mus-frequency tbl) 220.0)
	      (setf (mus-frequency wt) 220.0)
	      (setf (aref (mus-data tbl) 1) .1)
	      (setf (mus-frequency asy) 220.0)
	      (setf (mus-scaler asy) 0.5)
	      (setf (mus-frequency frm) 220.0)
	      (setf (mus-scaler frm) 0.75)
	      (setf (mus-xcoeff fir 0) .123)
	      (setf (mus-ycoeff iir 0) .321)
	      (setf (mus-xcoeff fiir 0) .231)
	      (setf (aref (mus-xcoeffs fir) 1) .345)
	      (setf (aref (mus-ycoeffs iir) 1) .543)
	      (setf (aref (mus-ycoeffs fiir) 1) .435)
	      (setf (aref (mus-xcoeffs fiir) 1) .534)
	      (setf (mus-frequency ssb) 220.0)
	      (setf (mus-frequency pvoc) 2.0)
	      (setf (mus-location rdin) 12)
	      (setf glb-int 4)
	      (setf glb-flt 64.0)
	      (setf (mus-frequency glb-osc) 220.0)

	      ;; other rdin? pvoc? grn? cnv?

	      ))
	(delay dly (* i .1))
	(comb cmb (* i .02))
	(notch noc (* i .03))
	(all-pass allp (* i .04))
	(sawtooth-wave sw (* i .1))
	(triangle-wave tr (* i .15))
	(pulse-train pu (* i .2))
	(ssb-am ssb (moving-average ave (* i .5)))
	(src reader)
	(readin rdin)
	(oscil glb-osc (aref glb-farr i))
	(file->sample f2s i 0)
	(file->frample f2f i f2f-frample)
	(granulate grn #'(lambda (dir) 0.2))
	(convolve cnv #'(lambda (dir) 0.01))
	(phase-vocoder pvoc #'(lambda (dir) 1.0))
	(filter fiir (fir-filter fir (iir-filter iir (table-lookup tbl (asymmetric-fm asy 1.0)))))
	(locsig loc i (* (env e) (formant frm (one-pole p1 (one-zero z1 (two-pole p2 (two-zero z2 (rand rn (rand-interp rni)))))))))
	))

    ;; INT
    (if (not (= int 2))
	(format t ";reflect int: ~A~%" int))
    ;; FLT
    (if (> (abs (- flt 2.0)) .001)
	(format t ";reflect float: ~A~%" flt))
    ;; FLT ARR
    (do ((i 0 (1+ i)))
	((= i 10))
      (if (> (abs (- (aref arr i) (* i 0.5))) .001)
	  (format t ";reflect arr[~D]: ~A~%" i (aref arr i))))
    ;; INT ARR
    (do ((i 0 (1+ i)))
	((= i 10))
      (if (not (= (aref iarr i) (* i 2)))
	  (format t ";reflect int arr[~D]: ~A~%" i (aref iarr i))))
    ;; OSCIL
    (if (> (abs (- (mus-frequency osc) 220.0)) .001)
	(format t ";reflect osc freq: ~A~%" (mus-frequency osc)))
    (if (> (abs (- (mus-phase osc) 4.277)) .01)
	(format t ";reflect osc phase: ~A~%" (mus-phase osc)))
    ;; DELAY
    (if (not (= (mus-length dly) 30))
	(format t ";reflect delay size: ~A~%" (mus-length dly)))
    (let ((data (mus-data dly)))
      (do ((i 0 (1+ i)))
	  ((= i 10))
	(if (> (abs (- (aref data i) (* i 0.1))) .001)
	    (format t ";reflect delay data[~D]: ~A~%" i (aref data i)))))
    ;; COMB
    (if (not (= (mus-length cmb) 30))
	(format t ";reflect comb size: ~A~%" (mus-length cmb)))
    (if (> (abs (- (mus-feedback cmb) .9)) .001)
	(format t ";reflect cmb feedback: ~A~%" (mus-feedback cmb)))
    (let ((data (mus-data cmb)))
      (do ((i 0 (1+ i)))
	  ((= i 10))
	(if (> (abs (- (aref data i) (* i 0.02))) .001)
	    (format t ";reflect comb data[~D]: ~A~%" i (aref data i)))))
    ;; NOTCH
    (if (not (= (mus-length noc) 30))
	(format t ";reflect notch size: ~A~%" (mus-length noc)))
    (if (> (abs (- (mus-feedforward noc) .8)) .001)
	(format t ";reflect notch feedforward: ~A~%" (mus-feedforward noc)))
    (let ((data (mus-data noc)))
      (do ((i 0 (1+ i)))
	  ((= i 10))
	(if (> (abs (- (aref data i) (* i 0.03))) .001)
	    (format t ";reflect notch data[~D]: ~A~%" i (aref data i)))))
    ;; ALL-PASS
    (if (not (= (mus-length allp) 30))
	(format t ";reflect all-pass size: ~A~%" (mus-length allp)))
    (if (> (abs (- (mus-feedback allp) .66)) .001)
	(format t ";reflect all-pass feedback: ~A~%" (mus-feedback allp)))
    (if (> (abs (- (mus-feedforward allp) .55)) .001)
	(format t ";reflect all-pass feedforward: ~A~%" (mus-feedforward allp)))
    (let ((data (mus-data allp)))
      (do ((i 0 (1+ i)))
	  ((= i 10))
	(if (> (abs (- (aref data i) (* i 0.04))) .001)
	    (format t ";reflect all-pass data[~D]: ~A~%" i (aref data i)))))
    ;; SQUARE-WAVE
    (if (> (abs (- (mus-frequency sq) 220.0)) .001)
	(format t ";reflect square freq: ~A~%" (mus-frequency sq)))
    (if (> (abs (- (mus-phase sq) 5.593)) .01)
	(format t ";reflect square phase: ~A~%" (mus-phase sq)))
    (if (> (abs (- (mus-scaler sq) 0.5)) .001)
	(format t ";reflect square amp: ~A~%" (mus-scaler sq)))
    ;; SAWTOOTH-WAVE
    (if (> (abs (- (mus-frequency sw) 220.0)) .001)
	(format t ";reflect saw freq: ~A~%" (mus-frequency sw)))
    (if (> (abs (- (mus-phase sw) 1.985)) .01)
	(format t ";reflect saw phase: ~A~%" (mus-phase sw)))
    (if (> (abs (- (mus-scaler sw) 0.65)) .001)
	(format t ";reflect saw amp: ~A~%" (mus-scaler sw)))
    ;; TRIANGLE-WAVE
    (if (> (abs (- (mus-frequency tr) 220.0)) .001)
	(format t ";reflect tri freq: ~A~%" (mus-frequency tr)))
    (if (> (abs (- (mus-phase tr) 1.093)) .01)
	(format t ";reflect tri phase: ~A~%" (mus-phase tr)))
    (if (> (abs (- (mus-scaler tr) 0.55)) .001)
	(format t ";reflect tri amp: ~A~%" (mus-scaler tr)))
    ;; PULSE-TRAIN
    (if (> (abs (- (mus-frequency pu) 220.0)) .001)
	(format t ";reflect pulse freq: ~A~%" (mus-frequency pu)))
    (if (> (abs (- (mus-phase pu) 3.343)) .01)
	(format t ";reflect pulse phase: ~A~%" (mus-phase pu)))
    (if (> (abs (- (mus-scaler pu) 0.6)) .001)
	(format t ";reflect pulse amp: ~A~%" (mus-scaler pu)))
    ;; ONE-ZERO
    (if (> (abs (mus-xcoeff z1 0)) .001)
	(format t ";reflect one-zero x0: ~A~%" (mus-xcoeff z1 0)))
    (if (> (abs (- (mus-xcoeff z1 1) 0.9)) .001)
	(format t ";reflect one-zero x1: ~A~%" (mus-xcoeff z1 1)))
    ;; ONE-POLE
    (if (> (abs (- (mus-xcoeff p1 0) 1.0)) .001)
	(format t ";reflect one-pole x0: ~A~%" (mus-xcoeff p1 0)))
    (if (> (abs (- (mus-ycoeff p1 1) 0.8)) .001)
	(format t ";reflect one-pole y1: ~A~%" (mus-ycoeff p1 1)))
    ;; TWO-ZERO
    (if (> (abs (- (mus-xcoeff z2 0) 1.0)) .001)
	(format t ";reflect two-zero x0: ~A~%" (mus-xcoeff z2 0)))
    (if (> (abs (- (mus-xcoeff z2 1) 0.2)) .001)
	(format t ";reflect two-zero x1: ~A~%" (mus-xcoeff z2 1)))
    (if (> (abs (- (mus-xcoeff z2 2) 0.1)) .001)
	(format t ";reflect two-zero x2: ~A~%" (mus-xcoeff z2 2)))
    ;; TWO-POLE
    (if (> (abs (- (mus-xcoeff p2 0) 1.0)) .001)
	(format t ";reflect two-pole x0: ~A~%" (mus-xcoeff p2 0)))
    (if (> (abs (- (mus-ycoeff p2 1) 0.3)) .001)
	(format t ";reflect two-pole y1: ~A~%" (mus-ycoeff p2 1)))
    (if (> (abs (- (mus-ycoeff p2 2) 0.1)) .001)
	(format t ";reflect two-pole y2: ~A~%" (mus-ycoeff p2 2)))
    ;; RAND
    (if (> (abs (- (mus-frequency rn) 220.0)) .001)
	(format t ";reflect rand freq: ~A~%" (mus-frequency rn)))
    (if (> (abs (- (mus-scaler rn) 0.5)) .001)
	(format t ";reflect rand amp: ~A~%" (mus-scaler rn)))
    ;; RAND-INTERP
    (if (> (abs (- (mus-frequency rni) 220.0)) .001)
	(format t ";reflect rand-interp freq: ~A~%" (mus-frequency rni)))
    (if (> (abs (- (mus-scaler rni) 0.5)) .001)
	(format t ";reflect rand-interp amp: ~A~%" (mus-scaler rni)))
    ;; TABLE-LOOKUP
    (if (> (abs (- (mus-frequency tbl) 220.0)) .001)
	(format t ";reflect table-lookup freq: ~A~%" (mus-frequency tbl)))
    (if (> (abs (- (mus-phase tbl) 3.074)) .01)
	(format t ";reflect table-lookup phase: ~A~%" (mus-phase tbl)))
    (if (not (= (mus-length tbl) 512))
	(format t ";reflect table-lookup length: ~A~%" (mus-length tbl)))
    (let ((wave (mus-data tbl)))
      (if (> (abs (- (aref wave 1) .1)) .001)
	  (format t ";reflect table-lookup wave 1: ~A~%" (aref wave 1))))
    ;; ASYMMETRIC-FM
    (if (> (abs (- (mus-frequency asy) 220.0)) .001)
	(format t ";reflect asyfm freq: ~A~%" (mus-frequency asy)))
    (if (> (abs (- (mus-phase asy) 0.626)) .01)
	(format t ";reflect asyfm phase: ~A~%" (mus-phase asy)))
    (if (> (abs (- (mus-scaler asy) 0.5)) .001)
	(format t ";reflect asyfm scaler: ~A~%" (mus-scaler asy)))
    (if (> (abs (- (mus-increment asy) 0.8)) .001)
	(format t ";reflect asyfm incr: ~A~%" (mus-increment asy)))
    ;; FORMANT
    (if (> (abs (- (mus-frequency frm) 220.0)) .001)
	(format t ";reflect formant freq: ~A~%" (mus-frequency frm)))
    ;; FIR-FILTER
    (if (not (= (mus-order fir) 8))
	(format t ";reflect fir order: ~A~%" (mus-order fir)))
    (if (> (abs (- (mus-xcoeff fir 0) .123)) .001)
	(format t ";reflect fir x0: ~A~%" (mus-xcoeff fir 0)))
    (if (> (abs (- (mus-xcoeff fir 1) .345)) .001)
	(format t ";reflect fir x1: ~A~%" (mus-xcoeff fir 1)))
    (let ((xs (mus-xcoeffs fir)))
      (do ((i 2 (1+ i)))
	  ((= i 8))
	(if (> (abs (- (aref xs i) (* i .03))) .001)
	    (format t ";reflect fir x[~D]: ~A~%" i (aref xs i)))))
    ;; IIR-FILTER
    (if (not (= (mus-order iir) 8))
	(format t ";reflect iir order: ~A~%" (mus-order iir)))
    (if (> (abs (- (mus-ycoeff iir 0) .321)) .001)
	(format t ";reflect iir y0: ~A~%" (mus-ycoeff iir 0)))
    (if (> (abs (- (mus-ycoeff iir 1) .543)) .001)
	(format t ";reflect iir y1: ~A~%" (mus-ycoeff iir 1)))
    (let ((ys (mus-ycoeffs iir)))
      (do ((i 2 (1+ i)))
	  ((= i 8))
	(if (> (abs (- (aref ys i) (* i .01))) .001)
	    (format t ";reflect iir y[~D]: ~A~%" i (aref ys i)))))
    ;; FILTER
    (if (not (= (mus-order fiir) 8))
	(format t ";reflect direct order: ~A~%" (mus-order fiir)))
    (if (> (abs (- (mus-xcoeff fiir 0) .231)) .001)
	(format t ";reflect fiir x0: ~A~%" (mus-xcoeff fiir 0)))
    (if (> (abs (- (mus-xcoeff fiir 1) .534)) .001)
	(format t ";reflect fiir x1: ~A~%" (mus-xcoeff fiir 1)))
    (if (> (abs (- (mus-ycoeff fiir 1) .435)) .001)
	(format t ";reflect fiir y1: ~A~%" (mus-ycoeff fiir 1)))
    (let ((xs (mus-xcoeffs fiir)))
      (do ((i 2 (1+ i)))
	  ((= i 8))
	(if (> (abs (- (aref xs i) (* i .01))) .001)
	    (format t ";reflect fiir x[~D]: ~A~%" i (aref xs i)))))
    (let ((ys (mus-ycoeffs fiir)))
      (do ((i 2 (1+ i)))
	  ((= i 8))
	(if (> (abs (- (aref ys i) (* i .02))) .001)
	    (format t ";reflect fiir y[~D]: ~A~%" i (aref ys i)))))
    ;; ENV
    (if (> (abs (- (mus-scaler e) 1.0)) .001)
	(format t ";reflect env scaler: ~A~%" (mus-scaler e)))
    (if (> (abs (- (mus-offset e) 0.0)) .001)
	(format t ";reflect env offset: ~A~%" (mus-offset e)))
    ;; AVERAGE
    (if (not (= (mus-length ave) 30))
	(format t ";reflect average size: ~A~%" (mus-length ave)))
    (let ((data (mus-data ave)))
      (if (> (abs (aref data 1)) .001)
	  (format t ";reflect average data[1]: ~A~%" (aref data 1))))
    ;; SRC
    (if (> (abs (- (mus-increment reader) 2.0)) .001)
	(format t ";reflect src increment (rate): ~A~%" (mus-increment reader)))
    ;; WAVE-TRAIN
    (if (> (abs (- (mus-frequency wt) 220.0)) .001)
	(format t ";reflect wave-train freq: ~A~%" (mus-frequency wt)))
    (if (> (abs (- (mus-phase wt) 0.0)) .01)
	(format t ";reflect wave-train phase: ~A~%" (mus-phase wt)))
    (if (not (= (mus-length wt) 512))
	(format t ";reflect wave-train length: ~A~%" (mus-length wt)))
    (let ((wave (mus-data wt)))
      (if (> (abs (- (aref wave 0) .1)) .001)
	  (format t ";reflect wave-train wave 0: ~A~%" (aref wave 0))))
    ;; SSB-AM
    (if (not (= (mus-order ssb) 20))
	(format t ";reflect ssb-am order: ~A~%" (mus-order ssb)))

    ;; PHASE-VOCODER
    (if (not (= (mus-length pvoc) 128))
	(format t ";reflect pvoc size: ~A~%" (mus-length pvoc)))
    (if (not (= (mus-hop pvoc) 32))
	(format t ";reflect pvoc hop: ~A~%" (mus-hop pvoc)))

    ;; LOCSIG
    (if (not (= (mus-channels loc) 1))
	(format t ";reflect loc chans: ~A~%" (mus-channels loc)))
    
    ;; READIN
    (if (not (= (mus-channel rdin) 0))
	(format t ";reflect rdin chan: ~A~%" (mus-channel rdin)))
    
    ;; GRANULATE
    (if (not (= (mus-length grn) 3308))
	(format t ";reflect grn len: ~A~%" (mus-length grn)))
    (if (not (= (mus-hop grn) 1102))
	(format t ";reflect grn hop: ~A~%" (mus-hop grn)))
    (if (> (abs (- (mus-scaler grn) 0.6)) .001)
	(format t ";reflect grn scaler: ~A~%" (mus-scaler grn)))

    ;; CONVOLVE
    (if (not (= (mus-length cnv) 32))
	(format t ";reflect cnv len: ~A~%" (mus-length cnv)))
    
    ;; FILE->SAMPLE
    (if (not (string-equal (mus-file-name f2s) "temp.snd"))
	(format t ";reflect file->sample name: ~A~%" (mus-file-name f2s)))
    (if (not (= (mus-channel f2s) 0))
	(format t ";reflect file->sample channel: ~A~%" (mus-channel f2s)))

    ;; FILE->FRAMPLE
    (if (not (string-equal (mus-file-name f2f) "temp.snd"))
	(format t ";reflect file->frample name: ~A~%" (mus-file-name f2f)))
    (if (not (= (mus-channel f2f) 0))
	(format t ";reflect file->frample channel: ~A~%" (mus-channel f2f)))
    (if (not (= (mus-channels f2f) 1))
	(format t ";reflect file->frample channels: ~A~%" (mus-channels f2f)))

    ;; GLOBALS
    (if (not (= glb-int 4))
	(format t ";reflect glb-int: ~A~%" glb-int))
    (if (> (abs (- glb-flt 64.0)) .001)
	(format t ";reflect glb-flt: ~A~%" glb-flt))
    (if (> (abs (- (mus-frequency glb-osc) 220.0)) .001)
	(format t ";reflect glb-osc freq: ~A~%" (mus-frequency glb-osc)))
    (if (> (abs (- (mus-phase glb-osc) 4.277)) .01)
	(format t ";reflect glb-osc phase: ~A~%" (mus-phase glb-osc)))
    (do ((i 0 (1+ i)))
	((= i 10))
      (if (> (abs (- (aref glb-farr i) (* i 0.5))) .001)
	  (format t ";reflect glb-farr[~D]: ~A~%" i (aref glb-farr i))))
    (do ((i 0 (1+ i)))
	((= i 10))
      (if (not (= (aref glb-iarr i) (* i 2)))
	  (format t ";reflect glb-iarr[~D]: ~A~%" i (aref glb-iarr i))))
    ))

(definstrument test-mus-method-declaration ()
  (let* ((arr (make-array 3)))
    (do ((i 0 (1+ i)))
	((= i 3))
      (setf (aref arr i) (make-oscil (* (1+ i) 220.0))))
    (run
      (loop for i from 0 below 10 do
	(declare (type :mus-any* arr))
	(do ((k 0 (1+ k)))
	    ((= k 3))
	  (setf (mus-frequency (aref arr k)) 100.0)
	  (setf (mus-phase (aref arr k)) 1.0)
	  (outa i (* .1 (oscil (aref arr 0)))))))))


#-clisp
(definstrument expandn1 (time duration filename amplitude
                             &key (expand 1.0)
                             (matrix nil)
                             (ramp 0.4)
                             (seglen 0.15)
                             (srate 1.0)
                             (hop .05)
                             (amp-env '(0 0 50 1 100 0))
                             (input-start 0.0)
                             (grain-amp 0.8)
                             (reverb nil))
  (let* ((beg (floor (* time *srate*)))
         (end (+ beg (floor (* duration *srate*))))
         
         (in-chans (sound-chans filename))
	 (out-chans (mus-channels *output*))
	 (inframple (make-double-array in-chans))
	 (outframple (make-double-array out-chans))
	 (mx-chans (max in-chans out-chans))
         (mx (make-double-array (* mx-chans mx-chans)))
         (rev-chans (if *reverb* (mus-channels *reverb*) 0))
	 (rev-mx-chans (max out-chans rev-chans))
         (rev-mx (if (and *reverb* reverb (> reverb 0.0))
                   (let ((rmx (make-double-array (* rev-mx-chans rev-mx-chans))))
                     (loop for i from 0 below rev-mx-chans do
			   (setf (aref rmx (+ (* i rev-mx-chans) i)) (double reverb)))
                     rmx)))
         (revframple (if rev-mx (make-double-array rev-mx-chans)))
         (update-env (or (listp expand) (listp seglen) (listp ramp) (listp hop)))
         (update-rate 100)
         (expenv (make-env :envelope (if (listp expand) expand `(0 ,expand 1 ,expand))
                           :duration (/ duration update-rate)))
         (lenenv (make-env :envelope (if (listp seglen) seglen `(0 ,seglen 1 ,seglen))
                           :duration (/ duration update-rate)))
         (max-seg-len (if (listp seglen) (max-envelope seglen) seglen))
         (segment-scaler (if (> max-seg-len .15) (/ (* grain-amp .15) max-seg-len) grain-amp))
         (srenv (if (listp srate) (make-env :envelope srate
				            :duration duration)))
         (resa (if (listp srate) (second srate) srate))
         (rampdata (if (listp ramp) ramp `(0 ,ramp 1 ,ramp)))
         (rampenv (make-env :envelope rampdata
                            :duration (/ duration update-rate)))
         (minramp-bug (<= (min-envelope rampdata) 0.0))
         (maxramp-bug (>= (max-envelope rampdata) 0.5))
         (hopenv (make-env :envelope (if (listp hop) hop `(0 ,hop 1 ,hop))
                           :duration (/ duration update-rate)))
         (ampenv (make-env :envelope amp-env
                           :duration duration
                           :scaler amplitude))
         (ex-array (make-array in-chans))
         (start (floor (* input-start (sound-srate filename))))
         (max-out-hop (if (listp hop) (max-envelope hop) hop))
         (min-exp-amt (if (listp expand) (min-envelope expand) expand))
         (max-in-hop (/ max-out-hop min-exp-amt))
         (max-len (ceiling (* *srate* (+ (max max-out-hop max-in-hop) max-seg-len))))
         (input-array (make-array in-chans :initial-element nil))
         (ex-samp -1.0)	;these vars used for in-line resampling (rather than use resample generator)
         (next-samp 0.0)
         (samples-0 (make-double-float-array in-chans :initial-element 0.0))
         (samples-1 (make-double-float-array in-chans :initial-element 0.0))
         (gen nil))
    (if (or minramp-bug maxramp-bug)
      (warn "ramp argument to expsnd must always be ~A"
            (if (and minramp-bug maxramp-bug) "between 0.0 and 0.5"
                (if minramp-bug "greater than 0.0"
                    "less than 0.5"))))
    ;; setup granulate generators
    (loop for i from 0 below in-chans do
          (setf (aref input-array i) (open-input filename :start start :channel i))
          (setf (aref ex-array i)
                (make-granulate :input (aref input-array i)
                                :expansion (if (listp expand) (second expand) expand)
                                :max-size max-len
                                :ramp (if (listp ramp) (second ramp) ramp)
                                :hop (if (listp hop) (second hop) hop)
                                :length (if (listp seglen) (second seglen) seglen)
                                :scaler segment-scaler)))
    (if matrix
	(loop for inp from 0 below in-chans
	      for inlist in matrix do
	      (loop for outp from 0 below out-chans
		    for outn in inlist do
		    (setf (aref mx (+ (* mx-chans inp) outp)) (double outn))))
      (loop for inp from 0 below in-chans do
	(loop for outp from 0 below out-chans do
          (setf (aref mx (+ (* mx-chans inp) outp)) 1.0d0))))
    
    (run
     (loop for i from beg to end do
       (declare (type (:mus-any* granulate) ex-array)
		(type :mus-any gen))
       (let ((vol (env ampenv)))
	 (if srenv (setf resa (env srenv)))
	 (if (and update-env (= 0 (mod (- i beg) update-rate)))
	     (let* ((expa (env expenv)) ;current expansion amount
		    (segl (env lenenv)) ;current segment length
		    (rmpl (env rampenv)) ;current ramp length (0 to .5)
		    (hp (env hopenv)) ;current hop size
		    ;; now we set the granulate generator internal state to reflect all these envelopes
		    (sl (floor (* segl *srate*)))
		    (rl (floor (* rmpl sl))))
	       ;; declare types
	       (loop for ix from 0 below in-chans do
		 (progn 
		   (setf gen (aref ex-array ix))
		   (setf (mus-length gen) sl)
		   (setf (mus-ramp gen) rl)
		   (setf (mus-frequency gen) hp)
		   (setf (mus-increment gen) expa)))))
	 (if (minusp ex-samp)
	     (progn
	       (loop for ix from 0 below in-chans do
		 (progn
		   (setf gen (aref ex-array ix))
		   (setf (aref samples-0 ix) (* vol (granulate gen)))
		   (setf (aref samples-1 ix) (* vol (granulate gen)))))
	       (incf ex-samp)
	       (setf next-samp ex-samp))
	   (progn
	     (incf next-samp resa)
	     (when (> next-samp (1+ ex-samp))
	       (let ((samps (floor (- next-samp ex-samp))))
		 (dotimes (k samps)
		   (loop for ix from 0 below in-chans do
		     (progn
		       (setf gen (aref ex-array ix))
		       (setf (aref samples-0 ix) (aref samples-1 ix))
		       (setf (aref samples-1 ix) (* vol (granulate gen)))))
		   (incf ex-samp))))))
	 (if (= next-samp ex-samp)
	     ;; output actual samples
	     (loop for ix from 0 below in-chans do
	       (let ((samp (aref samples-0 ix)))
		 (setf (aref inframple ix) samp)))
	   ;; output interpolated samples
	   (loop for ix from 0 below in-chans do
	     (let* ((v0 (aref samples-0 ix))
		    (v1 (aref samples-1 ix))
		    (samp (+ v0 (* (- next-samp ex-samp) (- v1 v0)))))
	       (setf (aref inframple ix) samp))))
	 ;; output mixed result
	 (frample->file *output* i (frample->frample mx inframple outframple))
	 ;; if reverb is turned on, output to the reverb streams
	 (if rev-mx (frample->file *reverb* i (frample->frample rev-mx outframple revframple))))))))

(definstrument simple-dloc (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (loc (make-move-sound (list start end 1 0
				     (make-delay 32) 
				     (make-env '(0 0 1 1) :length 1001)
				     (make-env '(0 0 1 1) :length 1001)
				     (make-array 1 :initial-contents (list (make-delay 32)))
				     (make-array 1 :initial-contents (list (make-env '(0 0 1 1) :length 1001)))
				     (make-array 1 :initial-contents (list (make-delay 32)))
				     (make-integer-array 1 :initial-contents (list 0))))))
    (run
     (loop for i from start to end do
       (move-sound loc i (* amp (oscil os)))))))

(definstrument sd2 (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (loc (make-move-sound (list start end 2 1
				     (make-delay 32) 
				     (make-env '(0 0 1 1) :length 1001)
				     (make-env '(0 0 1 1) :length 1001)
				     (make-array 2 :initial-contents (list (make-delay 32) (make-delay 16)))
				     (make-array 2 :initial-contents (list (make-env '(0 0 1 1) :length 1001) (make-env '(0 1 1 0) :length 101)))
				     (make-array 2 :initial-contents (list (make-env '(0 1 1 1) :length 1001) (make-env '(0 1 1 0.5) :length 101)))
				     (make-integer-array 2 :initial-contents (list 0 1))))))
    (run
     (loop for i from start to end do
       (move-sound loc i (* amp (oscil os)))))))

;(with-sound (:channels 2 :reverb jc-reverb) (sd2 0 1 330 .1))

(definstrument sd4 (beg dur freq amp)
  (let* ((os (make-oscil freq))
	 (start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (loc (make-move-sound (list start end 4 1
				     (make-delay 32) 
				     (make-env '(0 0 1 1) :length 1001)
				     (make-env '(0 0 1 1) :length 1001)
				     (make-array 4 :initial-contents (list (make-delay 32) (make-delay 16) (make-delay 32) (make-delay 16)))
				     (make-array 4 :initial-contents (list (make-env '(0 0 1 1) :length 1001) (make-env '(0 1 1 0) :length 101)
									   (make-env '(0 0 1 1) :length 1001) (make-env '(0 1 1 0) :length 101)))
				     (make-array 4 :initial-contents (list (make-env '(0 1 1 1) :length 1001) (make-env '(0 1 1 0.5) :length 101)
									   (make-env '(0 1 1 1) :length 1001) (make-env '(0 1 1 0.5) :length 101)))
				     (make-integer-array 4 :initial-contents (list 0 1 3 2))))))
    (run
     (loop for i from start to end do
       (move-sound loc i (* amp (oscil os)))))))

;(with-sound (:channels 4 :reverb jc-reverb) (sd4 0 1 330 .1))

(definstrument f2s-incr (beg dur amp file)
  (let* ((start (floor (* beg *srate*)))
	 (end (+ start (floor (* dur *srate*))))
	 (fil (make-file->sample file))
	 (ctr 0))
    (run
     (loop for i from start to end do
       (setf (mus-increment fil) 1)
       (out-any i (* amp (file->sample fil ctr 0)) 0 *output*)
       (setf ctr (1+ ctr))))))

