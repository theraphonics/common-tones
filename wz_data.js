var extsnd_addmark_tip = "(add-mark samp :optional snd chn name (sync 0)): add a mark at sample samp returning the mark id.";
var extsnd_addsoundfileextension_tip = "(add-sound-file-extension ext):  add the file extension 'ext' to the list of sound file extensions";
var extsnd_addtomenu_tip = "(add-to-menu menu label func :optional position): adds label to menu (a main menu index), invokes func (a function of no args) when the new menu is activated. Returns the new menu label widget.";
var extsnd_addtransform_tip = "(add-transform name x-label low high func): add the transform func to the transform lists; func should be a function of two arguments, the length of the transform and a sample-reader to get the data, and should return a vct containing the transform results. name is the transform's name, x-label is its x-axis label, and the relevant returned data to be displayed goes from low to high (normally 0.0 to 1.0)";
var extsnd_afterapplycontrolshook_tip = "after-apply-controls-hook (snd): called when apply-controls finishes.";
var extsnd_aftergraphhook_tip = "after-graph-hook (snd chn): called after a graph is updated.";
var extsnd_afteropenhook_tip = "after-open-hook (snd): called just before the new file's window is displayed. This provides a way to set various sound-specific defaults. <pre>  (add-hook! after-open-hook<br>    (lambda (snd) <br>      (if (> (channels snd) 1) <br>          (set! (channel-style snd) channels-combined))))</pre>";
var extsnd_aftersaveashook_tip = "after-save-as-hook (saved-sound-index save-as-full-filename from-save-as-dialog): called upon File:Save as or save-sound-as completion.";
var extsnd_aftersavestatehook_tip = "after-save-state-hook (filename): called after Snd state has been saved; filename is the save state file.";
var extsnd_aftertransformhook_tip = "after-transform-hook (snd chn scaler): called just after a spectrum is calculated.";
var extsnd_ampcontrol_tip = "(amp-control :optional snd chn): current amp slider setting";
var extsnd_applycontrols_tip = "(apply-controls :optional snd (choice 0) (beg 0) (dur len)): applies the current control panel state as an edit. The 'choices' are 0 (apply to sound), 1 (apply to channel), and 2 (apply to selection).  If 'beg' is given, the apply starts there.";
var extsnd_asoneedit_tip = "(as-one-edit thunk :optional origin): evaluate thunk, collecting all edits into one from the edit historys' point of view";
var extsnd_axisinfo_tip = "(axis-info :optional snd chn (ax time-graph)): info about axis: (list losamp hisamp x0 y0 x1 y1 xmin ymin xmax ymax pix_x0 pix_y0 pix_x1 pix_y1 y_offset xscale yscale xlabel ylabel new-peaks)";
var extsnd_axislabelfont_tip = "(axis-label-font): font used for axis labels";
var extsnd_axisnumbersfont_tip = "(axis-numbers-font): font used for axis numbers";
var extsnd_badheaderhook_tip = "bad-header-hook (filename): called if a file has some bogus-looking header. Return #t to give up on that file.";
var extsnd_basiccolor_tip = "(basic-color): Snd's basic color";
var extsnd_beatsperminute_tip = "(beats-per-minute :optional snd chn): beats per minute if x-axis-style is x-axis-in-beats";
var extsnd_beforeclosehook_tip = "before-close-hook (snd): called each time a file is closed (before the close). If it returns #t, the file is not closed.";
var extsnd_beforeexithook_tip = "before-exit-hook (): called upon exit. If it returns #t, Snd does not exit.  This can be used to check for unsaved edits.";
var extsnd_beforesaveashook_tip = "before-save-as-hook (index filename selection srate type format comment): called before File:Save as or save-sound-as. Provides a way to fixup a sound just before it is saved.";
var extsnd_beforesavestatehook_tip = "before-save-state-hook (filename): called before Snd state is saved. If the hook functions return #t, the save state process opens 'filename' for appending, rather than truncating.";
var extsnd_bindkey_tip = "(bind-key key modifiers func :optional extended origin prefs-info: causes 'key' (an integer, character, or string) when typed with 'modifiers' (0:none, 4:control, 8:meta) (and C-x if extended) to invoke 'func', a function of zero or one arguments. If the function takes one argument, it is passed the preceding C-u number, if any. The function should return one of the cursor choices (e.g. keyboard-no-action).  'origin' is the name reported if an error occurs. The 'key' argument can be the X/Gtk name of the key (e.g. \"plus\" for \"+\" or \"Home\"), the character on the key (#\x07), or the integer corresponding to that character: (\"(char->integer #\x07)\" in Scheme, or \"?a\" in Ruby.";
var extsnd_boldpeaksfont_tip = "(bold-peaks-font): bold font used by fft peak display";
var extsnd_cgp_tip = "(c-g?): allow pending user interface events to occur, returning #t if C-g was typed";
var extsnd_channels_tip = "(channels :optional snd): how many channels snd has";
var extsnd_channelstyle_tip = "(channel-style :optional snd): how multichannel sounds lay out the channels. The default is channels-combined; other values are channels-separate and channels-superimposed. As a global (if the 'snd' arg is omitted), it is the default setting for each sound's 'unite' button.";
var extsnd_channelwidgets_tip = "(channel-widgets :optional snd chn): a list of widgets: ((0)graph (1)w (2)f (3)sx (4)sy (5)zx (6)zy (7)edhist)";
var extsnd_chans_tip = "(channels :optional snd): how many channels snd has";
var extsnd_clearminibuffer_tip = "(clear-minibuffer :optional snd) clears snd's minibuffer (erasing any error message as well).";
var extsnd_cliphook_tip = "clip-hook (clipping-value) is called each time a sample is about to be clipped upon being written to a sound file.  The hook function can return the new vallue to be written, or rely on the default (-1.0 or 1.0 depending on the sign of 'clipping-value').";
var extsnd_clmchannel_tip = "(clm-channel gen :optional (beg 0) (dur len) snd chn edpos (overlap 0) origin): apply gen to snd's channel chn starting at beg for dur samples. overlap is the 'ring' time, if any.";
var extsnd_closehook_tip = "close-hook (snd): called each time a file is closed (before the close).";
var extsnd_closesound_tip = "(close-sound :optional snd): close snd";
var extsnd_comment_tip = "(comment :optional snd): snd's comment (in its header)";
var extsnd_countmatches_tip = "(count-matches func :optional (start-samp 0) snd chn edpos): return how many samples satisfy func (a function of one argument, the current sample, returning #t upon match): (count-matches (lambda (y) (> y .1)))";
var extsnd_currentfont_tip = "(current-font :optional snd chn (ax time-graph)): current font id";
var extsnd_cursor_tip = "(cursor :optional snd chn edpos): current cursor location in snd's channel chn";
var extsnd_cursorcontext_tip = "graphics context for the cursor";
var extsnd_dachook_tip = "dac-hook (sdobj): called just before data is sent to DAC passing data as sound-data object";
var extsnd_dacsize_tip = "(dac-size): the current DAC buffer size in frames (256)";
var extsnd_datacolor_tip = "(data-color): color used to draw unselected data";
var extsnd_dataformat_tip = "(data-format :optional snd): snd's data format (e.g. mus-bshort)";
var extsnd_datalocation_tip = "(data-location :optional snd): snd's data location (bytes)";
var extsnd_declare_tip = "no help";
var extsnd_defineenvelope_tip = "define-envelope is defined, but has no help string; it is documented at extsnd.html#defineenvelope";
var extsnd_defvar_tip = "defvar is defined, but has no help string; it is documented at extsnd.html#defvar";
var extsnd_deletesamples_tip = "(delete-samples start-samp samps :optional snd chn edpos): delete 'samps' samples from snd's channel chn starting at 'start-samp'";
var extsnd_dialogwidgets_tip = "(dialog-widgets): dialog widgets (each #f if not yet created): (list  (0 color-dialog) (1 orientation-dialog) (2 enved-dialog) (3 #f) (4 #f) (5 transform-dialog)  (6 open-file-dialog) (7 save-sound-dialog) (8 view-files-dialog) (9 raw data dialog) (10 new file dialog)  (11 mix-file-dialog) (12 edit-header-dialog) (13 find-dialog) (14 help-dialog) (15 listener completion)  (16 view-mixes-dialog) (17 print-dialog) (18 recorder-dialog) (19 view-regions-dialog)  (20 info-dialog) (21 #f) (22 save-selection-dialog) (23 insert-file-dialog)  (24 save-region-dialog) (25 preferences-dialog))";
var extsnd_dotsize_tip = "(dot-size :optional snd chn): size in pixels of dots when graphing with dots (1)";
var extsnd_drawline_tip = "(draw-line x0 y0 x1 y1 :optional snd chn (ax time-graph)): draw a line";
var extsnd_drawstring_tip = "(draw-string text x0 y0 :optional snd chn (ax time-graph)): draw a string";
var extsnd_duringopenhook_tip = "during-open-hook (fd name reason): called after file is opened, but before data has been read. <pre>  (add-hook! during-open-hook<br>    (lambda (fd name reason) <br>      (if (= (mus-sound-header-type name) mus-raw)<br>          (set! (mus-file-prescaler fd) 500.0))))</pre>";
var extsnd_editfragment_tip = "(edit-fragment :optional (ctr current-edit-position) snd chn): edit history entry at ctr associated with snd's channel chn; the returned value is a list (origin type start-sample samps)";
var extsnd_editposition_tip = "(edit-position :optional snd chn): current edit history position in snd's channel chn";
var extsnd_edits_tip = "(edits :optional snd chn): -> (list undoable-edits redoable-edits) in snd's channel chn";
var extsnd_emarks_tip = "(marks :optional snd chn edpos): list of marks (ids) in snd/chn at edit history position pos. mark list is: channel given: (id id ...), snd given: ((id id) (id id ...)), neither given: (((id ...) ...) ...).";
var extsnd_envchannel_tip = "(env-channel clm-env-gen-or-envelope :optional (beg 0) (dur len) snd chn edpos): apply amplitude envelope to snd's channel chn starting at beg for dur samples.";
var extsnd_envedtarget_tip = "(enved-target): where (amplitude, frequency, etc) the envelope is applied in the envelope editor; choices are enved-amplitude, enved-srate, and enved-spectrum";
var extsnd_envedwaving_tip = "(enved-wave?): #t if the envelope editor is displaying the waveform to be edited";
var extsnd_envsound_tip = "(env-sound env :optional (start-samp 0) (samps len) (env-base 1.0) snd chn edpos): apply amplitude envelope (a list of breakpoints or a CLM env) to snd's channel chn starting at start-samp, going either to the end of the sound or for samps samples, with segments interpolating according to env-base";
var extsnd_envsoundselection_tip = "(env-selection env :optional (env-base 1.0)): apply envelope to the selection using env-base to determine how breakpoints are connected";
var extsnd_eregions_tip = "(regions): current active regions (a list of region ids)";
var extsnd_exit_tip = "(exit): exit Snd";
var extsnd_exithook_tip = "exit-hook (): called upon exit.  This can be used to perform cleanup activities.";
var extsnd_expandcontrol_tip = "(expand-control :optional snd): current expand slider setting";
var extsnd_expandcontrolp_tip = "(expand-control? :optional snd): snd's control panel expand button state";
var extsnd_filename_tip = "(file-name :optional snd): snd's full filename";
var extsnd_fillrectangle_tip = "(fill-rectangle x0 y0 width height :optional snd chn (ax time-graph) erase): draw a filled rectangle";
var extsnd_filterchannel_tip = "(filter-channel env :optional order beg dur snd chn edpos (truncate #t) origin): applies an FIR filter to snd's channel chn. 'env' is the frequency response envelope, or a vct with the coefficients.";
var extsnd_filterselection_tip = "(filter-selection filter :optional order (truncate #t)): apply filter to selection. If truncate, cut off filter output at end of selection, else mix";
var extsnd_filtersound_tip = "(filter-sound filter :optional order snd chn edpos origin): applies FIR filter to snd's channel chn. 'filter' is either the frequency response envelope, a CLM filter, or a vct with the actual coefficients";
var extsnd_findchannel_tip = "(find-channel func :optional (start-samp 0) snd chn edpos): apply func, a function of one argument, the current sample, to each sample in snd's channel chn, starting at 'start-samp' until func returns something other than #f: (find-channel (lambda (y) (> y .1)))";
var extsnd_findmark_tip = "(find-mark samp-or-name :optional snd chn edpos): find the mark in snd's channel chn at samp (if a number) or with the given name (if a string); return the mark id or #f if no mark found.";
var extsnd_focuswidget_tip = "(focus-widget widget): cause widget to receive input focus";
var extsnd_foregroundcolor_tip = "(foreground-color :optional snd chn (ax time-graph)): current drawing color";
var extsnd_frames_tip = "(frames :optional snd chn edpos): number of frames of data in snd's channel chn";
var extsnd_freesamplereader_tip = "(free-sample-reader reader): free a sample reader (of any kind)";
var extsnd_gin_tip = "(in msecs thunk): invoke thunk in msecs milliseconds (named call_in in Ruby)";
var extsnd_graph_tip = "(graph data :optional xlabel (x0 0.0) (x1 1.0) y0 y1 snd chn (force-display #t) show-axes): displays 'data' as a graph with x axis label 'xlabel', axis units going from x0 to x1 and y0 to y1; 'data' can be a list or a vct. If 'data' is a list of numbers, it is treated as an envelope.";
var extsnd_graphhook_tip = "graph-hook (snd chn y0 y1): called each time a graph is about to be updated. If it returns #t, the display is not updated.";
var extsnd_graphshorizontal_tip = "(graphs-horizontal :optional snd chn): #t if the time domain, fft, and lisp graphs are layed out horizontally";
var extsnd_graphstyle_tip = "(graph-style :optional snd chn): graph style, one of '(graph-lines graph-dots graph-dots-and-lines graph-lollipops graph-filled)";
var extsnd_headertype_tip = "(header-type :optional snd): snd's header type (e.g. mus-aiff)";
var extsnd_helpdialog_tip = "(help-dialog subject message xrefs urls): start the Help window with subject and message";
var extsnd_hidewidget_tip = "(hide-widget widget): hide or undisplay widget";
var extsnd_highlightcolor_tip = "(highlight-color): color of highlighted text or buttons";
var extsnd_infodialog_tip = "(info-dialog subject message): start the Info window with subject and message";
var extsnd_initialgraphhook_tip = "initial-graph-hook (snd chn dur): called when a sound is displayed for the first time";
var extsnd_insertregion_tip = "(insert-region :optional (start-samp 0) (region-id 0) snd chn): insert region data into snd's channel chn starting at start-samp";
var extsnd_insertsamples_tip = "(insert-samples start-samp samps data :optional snd chn edpos auto-delete origin): insert data (either a vct, a list of samples, or a filename) into snd's channel chn starting at 'start-samp' for 'samps' samples";
var extsnd_insertselection_tip = "(insert-selection :optional (beg 0) snd chn): insert the currently selected portion starting at beg";
var extsnd_insertsound_tip = "(insert-sound file :optional (beg 0) (file-chan 0) snd chn edpos auto-delete): insert channel file-chan of file (or all chans if file-chan is not given) into snd's channel chn at beg or at the cursor position.  (insert-sound \"oboe.snd\" 1000) inserts all of oboe.snd starting at sample 1000.";
var extsnd_justsounds_tip = "(just-sounds): the 'just sounds' choice in the file chooser dialog";
var extsnd_leftsample_tip = "(left-sample :optional snd chn): left sample number in time domain window";
var extsnd_lispgraphhook_tip = "lisp-graph-hook (snd chn): called just before the lisp graph is updated. If it returns a list of pixels, these are used in order by the list of graphs (if any), rather than Snd's default set; this makes it possible to use different colors for the various graphs. If it returns a function (of no arguments), that function is called rather than the standard graph routine.";
var extsnd_listenerfont_tip = "(listener-font): font used by the lisp listener";
var extsnd_listenerprompt_tip = "(listener-prompt): the current lisp listener prompt character ('>') ";
var extsnd_listenertextcolor_tip = "(listener-text-color): text color in the lisp listener";
var extsnd_listtovct_tip = "(list->vct lst): returns a new vct filled with elements of list lst";
var extsnd_mainwidgets_tip = "(main-widgets): top level widgets (list (0)main-app (1)main-shell (2)main-pane (3)sound-pane (4)listener-pane (5)notebook-outer-pane)";
var extsnd_makecolor_tip = "(make-color r g b): return a color object with the indicated rgb values";
var extsnd_makegraphdata_tip = "(make-graph-data :optional snd chn edpos low high): return either a vct (if the graph has one trace), or a list of two vcts (the two sides of the envelope graph). 'edpos' defaults to the current-edit-position, 'low' defaults to the current window left sample, and 'high' defaults to the current rightmost sample. (graph-data (make-graph-data)) reimplements the time domain graph.";
var extsnd_makemixsamplereader_tip = "(make-mix-sample-reader id :optional (beg 0)): return a reader ready to access mix id";
var extsnd_makesamplereader_tip = "(make-sample-reader :optional (start-samp 0) snd chn (dir 1) edpos): return a reader ready to access snd's channel chn's data starting at start-samp, going in direction dir (1 = forward, -1 = backward), reading the version of the data indicated by edpos which defaults to the current version. snd can be a filename, or a sound index number.";
var extsnd_makesounddata_tip = "(make-sound-data chans frames): return a new sound-data object with 'chans' channels, each having 'frames' samples";
var extsnd_makevct_tip = "(make-vct len :optional (initial-element 0)): returns a new vct of length len filled with initial-element:  (define v (make-vct 32 1.0))";
var extsnd_mapchannel_tip = "(map-channel func :optional (start 0) (dur len) snd chn edpos edname): apply func to samples in current channel; edname is the edit history name for this editing operation.  (map-channel (lambda (y) (* y 2.0)))";
var extsnd_markclickhook_tip = "mark-click-hook (id): called when a mark is clicked; return #t to squelch the default message.";
var extsnd_markdraghook_tip = "mark-drag-hook (id): called when a mark is dragged";
var extsnd_markhome_tip = "(mark-home :optional id): the sound (index) and channel that hold mark id";
var extsnd_markname_tip = "(mark-name :optional id snd chn): mark's name";
var extsnd_marksample_tip = "(mark-sample :optional id pos): mark's location (sample number) at edit history pos";
var extsnd_marksync_tip = "(mark-sync :optional id): mark's sync value (default: 0)";
var extsnd_marksyncmax_tip = "(mark-sync-max): max mark sync value seen so far";
var extsnd_maxamp_tip = "(maxamp :optional snd chn edpos): maxamp of data in snd's channel chn";
var extsnd_mix_tip = "(mix file :optional (beg 0) (file-chan 0) snd chn (with-tag with-mix-tags) auto-delete): mix channel file-chan of file into snd's channel chn starting at beg (in the output), returning the new mix's id.  if with-tag is #f, no draggable tag is created.  If auto-delete is #t, the input file is deleted when it is no longer needed.";
var extsnd_mixamp_tip = "(mix-amp id): mix's scaler";
var extsnd_mixcolor_tip = "(mix-color :optional mix-id): color of all mix tags (if mix-id is omitted), or of mix-id's tag";
var extsnd_mixposition_tip = "(mix-position id): mix's begin time in the output in samples";
var extsnd_mixregion_tip = "(mix-region :optional (chn-samp 0) (region 0) snd chn (region-chan #t)): mix region's channel region-chan (or all chans if region-chan is #t) into snd's channel chn starting at chn-samp; return new mix id, if any.";
var extsnd_mixreleasehook_tip = "mix-release-hook (mix-id samps): called after the mouse has dragged a mix to some new position. 'samps' = samples moved in the course of the drag. If it returns #t, the actual remix is the hook's responsibility.";
var extsnd_mixsamplereaderQ_tip = "(mix-sample-reader? obj): #t if obj is a mix-sample-reader";
var extsnd_mixselection_tip = "(mix-selection :optional (beg 0) snd chn (selection-channel #t)): mix the currently selected portion starting at beg";
var extsnd_mixsync_tip = "(mix-sync id): mix sync field (an integer)";
var extsnd_mixsyncmax_tip = "(mix-sync-max): max mix sync value seen so far";
var extsnd_mixtagy_tip = "(mix-tag-y id): height of mix's tag";
var extsnd_musaudioclose_tip = "(mus-audio-close line): close the audio hardware line";
var extsnd_musaudiomixerread_tip = "(mus-audio-mixer-read device field channel vals): read some portion of the sound card mixer state.The device is the nominal audio device, normally mus-audio-default. The field describes what info we are requesting: to get the devices max available chans, the field would be mus-audio-channel. The channel arg, when relevant, specifies which channel we want info on or the 'vals' vct length. The requested info will be written into 'vals': <pre>  (let ((vals (make-vct 32)))<br>    (mus-audio-mixer-read mus-audio-default mus-audio-format 32 vals))<pre><br> sets (vct-ref vals 0) to the default device's desired audio sample data format.";
var extsnd_musaudiomixerwrite_tip = "(mus-audio-mixer-write device field channel vals): change some portion of the sound card mixer state";
var extsnd_musaudioopenoutput_tip = "(mus-audio-open-output device srate chans format bytes): open the audio device ready for output at the given srate and so on; return the audio line number:  (mus-audio-open-output mus-audio-default 22050 1 mus-lshort 256)";
var extsnd_musaudiowrite_tip = "(mus-audio-write line sdata frames): write frames of data (channels * frames = samples) to the audio line from sound-data sdata.";
var extsnd_musdataformatname_tip = "(mus-data-format-name format): data format (e.g. mus-bshort) as a string";
var extsnd_musheadertypename_tip = "(mus-header-type-name type): header type (e.g. mus-aiff) as a string";
var extsnd_musosssetbuffers_tip = "(mus-oss-set-buffers num size): set Linux OSS 'fragment' number and size. If Snd's controls seem sluggish, try (mus-oss-set-buffers 4 12) or even (mus-oss-set-buffers 2 12). This reduces the on-card buffering, but may introduce clicks.";
var extsnd_mussoundchans_tip = "(mus-sound-chans filename): channels of data in sound file";
var extsnd_mussoundcloseinput_tip = "(mus-sound-close-input fd): close (low-level) file fd that was opened by mus-sound-open-input.";
var extsnd_mussoundcomment_tip = "(mus-sound-comment filename): comment (a string) found in sound file's header";
var extsnd_mussounddataformat_tip = "(mus-sound-data-format filename): data format (e.g. mus-bshort) of data in sound file";
var extsnd_mussoundduration_tip = "(mus-sound-duration filename): duration (in seconds) of sound file";
var extsnd_mussoundframes_tip = "(mus-sound-frames filename): frames (samples / channel) in sound file";
var extsnd_mussoundheadertype_tip = "(mus-sound-header-type filename): header type (e.g. mus-aifc) of sound file";
var extsnd_mussoundloopinfo_tip = "(mus-sound-loop-info filename): synth loop info for sound as a list: (start1 end1 start2 end2 base-note base-detune mode1 mode2)";
var extsnd_mussoundmaxamp_tip = "(mus-sound-maxamp filename): maxamps in sound (a list of paired amps (floats) and locations (samples))";
var extsnd_mussoundmaxampexists_tip = "(mus-sound-maxamp-exists? filename): #t if sound's maxamp data is available in the sound cache; if it isn't, a call on mus-sound-maxamp has to open and read the data to get the maxamp.";
var extsnd_mussoundopeninput_tip = "(mus-sound-open-input filename): open filename for (low-level) sound input, return file descriptor (an integer)";
var extsnd_mussoundread_tip = "(mus-sound-read fd beg end chans sdata): read sound data from file fd, filling sound-data sdata's buffers starting at beg (buffer location), going to end";
var extsnd_mussoundsamples_tip = "(mus-sound-samples filename): samples (frames * channels) in sound file";
var extsnd_mussoundsrate_tip = "(mus-sound-srate filename): sampling rate of sound file";
var extsnd_nameclickhook_tip = "name-click-hook (snd): called when sound name clicked. If it returns #t, the usual informative minibuffer babbling is squelched.";
var extsnd_newsound_tip = "(new-sound :file :header-type :data-format :srate :channels :comment :size): creates a new sound file with the indicated attributes; if any are omitted, the corresponding default-output variable is used. The 'size' argument sets the number of samples (zeros) in the newly created sound.  (new-sound \"test.snd\" mus-next mus-bshort 22050 1 \"no comment\" 1000)";
var extsnd_nextsample_tip = "(next-sample reader): next sample from reader";
var extsnd_normalizefft_tip = "(transform-normalization :optional snd chn): one of dont-normalize, normalize-by-channel, normalize-by-sound, or normalize-globally. decides whether spectral data is normalized before display (default: normalize-by-channel)";
var extsnd_openfiledialog_tip = "(open-file-dialog :optional (managed #t)): create the file dialog if needed and display it if 'managed'";
var extsnd_openhook_tip = "open-hook (filename): called each time a file is opened (before the actual open). If it returns #t, the file is not opened.";
var extsnd_openrawsoundhook_tip = "open-raw-sound-hook (filename current-choices): called when a headerless sound file is opened. Its result can be a list describing the raw file's attributes (thereby bypassing the Raw File Dialog and so on). The list (passed to subsequent hook functions as 'current-choice') is interpreted as (list chans srate data-format data-location data-length) where trailing elements can be omitted (location defaults to 0, and length defaults to the file length in bytes).";
var extsnd_opensound_tip = "(open-sound filename): open filename (as if opened from File:Open menu option), and return the new sound's index";
var extsnd_optimization_tip = "(optimization): the current 'run' optimization level (default 0 = off, max is 6)";
var extsnd_optimizationhook_tip = "optimization-hook (msg): called if the run macro encounters something it can't optimize.  'msg' is a string description of the offending form:  (add-hook! optimization-hook (lambda (msg) (snd-print msg)))  You can often slightly rewrite the form to make run happy.";
var extsnd_padchannel_tip = "(pad-channel beg dur :optional snd chn edpos): insert dur zeros at beg in snd's chn";
var extsnd_peaksfont_tip = "(peaks-font): normal font used by fft peak display";
var extsnd_play_tip = "(play :optional (start 0) snd chn sync end (pos -1) stop-proc out-chan): play snd or snd's channel chn starting at start. 'start' can also be a function or a filename: (play \"oboe.snd\").  If 'sync' is true, all sounds syncd to snd are played. If 'end' is not given, play plays to the end of the sound.  If 'pos' is -1 or not given, the current edit position is played.";
var extsnd_playandwait_tip = "(play-and-wait (start 0) snd chn syncd end (pos -1) stop-proc out-chan): play snd or snd's channel chn starting at start and waiting for the play to complete before returning.  'start' can also be a function or a filename:  (play-and-wait \"oboe.snd\")";
var extsnd_playhook_tip = "play-hook (samps): called each time a buffer is sent to the DAC.";
var extsnd_playregion_tip = "(play-region :optional (reg 0) wait stop-proc): play region reg; if wait is #t, play to end before returning";
var extsnd_playselection_tip = "(play-selection :optional wait stop-proc): play the selection. 'wait', if #t, causes play-selection to wait until the playing is finished before returning.";
var extsnd_positiontox_tip = "(position->x val :optional snd chn (ax time-graph)): x axis value corresponding to pixel val";
var extsnd_previoussample_tip = "(previous-sample reader): previous sample from reader";
var extsnd_promptinminibuffer_tip = "(prompt-in-minibuffer msg :optional callback snd raw): post msg in snd's minibuffer then when the user eventually responds, invoke the function callback, if any, with the response.  If 'raw' is #t, the response is passed as a string to the prompt callback function; otherwise it is evaluated first as Scheme code.   (prompt-in-minibuffer \"what?\" (lambda (response) (snd-print response)))";
var extsnd_ptreechannel_tip = "(ptree-channel proc :optional (beg 0) (dur len) snd chn edpos peak-env-also init-func origin): apply 'proc' as a 'virtual edit'; that is, the effect of 'proc' (a function of one argument, the current sample, if init-func is not specified), comes about as an implicit change in the way the data is read.  This is similar to scaling and some envelope operations in that no data actually changes.  If 'peak-env-also' is #t, the same function is applied to the peak env values to get the new version. If 'proc' needs some state, it can be supplied in a vct returned by 'init-func'. 'init-func' is a function of 2 or 3 args, the current fragment-relative begin position, the overall fragment duration, and optionally the read direction. In this case, 'proc' is a function of 3 args: the current sample, the vct returned by 'init-func', and the current read direction.";
var extsnd_readmixsample_tip = "(read-mix-sample reader): read sample from mix reader";
var extsnd_readonly_tip = "(read-only :optional snd): whether snd is write-protected";
var extsnd_readsample_tip = "(read-sample reader): read sample from reader";
var extsnd_redo_tip = "(redo :optional (count 1) snd chn): redo 'count' edits in snd's channel chn";
var extsnd_regionchans_tip = "(region-chans :optional (reg 0): region channels";
var extsnd_regionframes_tip = "(region-frames :optional (reg 0) (chan 0)): region length in frames";
var extsnd_regionok_tip = "(region? reg): #t if region is active";
var extsnd_regularizedargs_tip = "no help";
var extsnd_reportinminibuffer_tip = "(report-in-minibuffer msg :optional snd as-error): display msg in snd's minibuffer. If 'as-error' is #t, place the message in the minibuffer's error label.";
var extsnd_resetlistenercursor_tip = "(reset-listener-cursor): reset listener cursor to the default pointer";
var extsnd_restorecontrols_tip = "(restore-controls :optional snd): restore the previously saved control panel settings";
var extsnd_reversesound_tip = "(reverse-sound :optional snd chn edpos): reverse snd's channel chn";
var extsnd_rightsample_tip = "(right-sample :optional snd chn): right sample number in time domain window";
var extsnd_run_tip = "(run thunk): try to optimize the procedure passed as its argument, then evaluate it; if the optimizer can't handle something in the procedure, it is passed to Scheme and is equivalent to (thunk).";
var extsnd_sample_tip = "(sample samp :optional snd chn edpos): return sample samp in snd's channel chn (this is a slow access -- use sample-readers for speed)";
var extsnd_samplereaderatendQ_tip = "(sample-reader-at-end? obj): #t if sample-reader has reached the end of its data";
var extsnd_samplereaderposition_tip = "(sample-reader-position obj): current (sample-wise) location of sample-reader";
var extsnd_samples_tip = "(samples :optional (start-samp 0) (samps len) snd chn edpos): return a vct containing snd channel chn's samples starting a start-samp for samps samples; edpos is the edit history position to read (defaults to current position).";
var extsnd_savedir_tip = "(save-dir): name of directory for saved state data (or #f=null)";
var extsnd_savehook_tip = "save-hook (snd name): called each time a file is about to be saved. If it returns #t, the file is not saved.  'name' is #f unless the file is being saved under a new name (as in sound-save-as).";
var extsnd_savesound_tip = "(save-sound :optional snd): save snd (update the on-disk data to match Snd's current version)";
var extsnd_savesoundas_tip = "(save-sound-as :file :sound :header-type :data-format :srate :channel :edit-position :comment): save sound in file using the indicated attributes.  If channel is specified, only that channel is saved (extracted). Omitted arguments take their value from the sound being saved. (save-sound-as \"test.snd\" index mus-next mus-bshort)";
var extsnd_savestatehook_tip = "save-state-hook (temp-filename): called each time the save-state mechanism is about to create a new temporary file to save some edit history sample values. temp-filename is the current file. If the hook returns a string, it is treated as the new temp filename.  This hook provides a way to keep track of which files are in a given saved state batch, and a way to rename or redirect those files.";
var extsnd_scaleby_tip = "(scale-by scalers :optional snd chn): scale snd by scalers (following sync); scalers can be a float or a vct/list of floats";
var extsnd_scalechannel_tip = "(scale-channel scaler :optional (beg 0) (dur len) snd chn edpos): scale samples in the given sound/channel between beg and beg + num by scaler.";
var extsnd_scaleselectionby_tip = "(scale-selection-by scalers): scale selected portion by scalers";
var extsnd_scaleto_tip = "(scale-to :optional (norms 1.0) snd chn): normalize snd to norms (following sync); norms can be a float or a vct/list of floats";
var extsnd_scanchannel_tip = "(scan-channel func :optional (start 0) (dur len) snd chn edpos): apply func to samples in current channel (or the specified channel) func is a function of one argument, the current sample. if func returns non-#f, the scan stops, and the value is returned to the caller with the sample number.  (scan-channel (lambda (y) (> y .1)))";
var extsnd_scriptarg_tip = "(script-arg): where we are in the startup arg list";
var extsnd_scriptargs_tip = "(script-args): the args passed to Snd at startup as a list of strings";
var extsnd_searchprocedure_tip = "(search-procedure :optional snd): global (if no 'snd' specified) or sound-local search function";
var extsnd_selectall_tip = "(select-all :optional snd chn): make a new selection containing all of snd's channel chn. If sync is set, all chans are included.  The new region id is returned (if selection-creates-region is #t).";
var extsnd_selectedchannel_tip = "(selected-channel :optional snd): currently selected channel in snd (or #f if none)";
var extsnd_selecteddatacolor_tip = "(selected-data-color): color used for selected data";
var extsnd_selectedgraphcolor_tip = "(selected-graph-color): background color of selected data";
var extsnd_selectedsound_tip = "(selected-sound): index of currently selected sound (or #f if none)";
var extsnd_selectioncreatesregion_tip = "(selection-creates-region): #t if a region should be created each time a selection is made. The default is currently #t, but that may change.  If you're dealing with large selections, and have no need of regions (saved selections), you can speed up many operations by setting this flag to #f";
var extsnd_selectionframes_tip = "(selection-frames :optional snd chn): selection length";
var extsnd_selectionmember_tip = "(selection-member? :optional snd chn): #t if snd's channel chn is a member of the current selection";
var extsnd_selectionok_tip = "(selection?): #t if selection is currently active, visible, etc";
var extsnd_selectionposition_tip = "(selection-position :optional snd chn): selection start samp";
var extsnd_selectionsrate_tip = "(selection-srate): selection srate";
var extsnd_setsamples_tip = "(set-samples start-samp samps data :optional snd chn truncate edname (infile-chan 0) edpos auto-delete): set snd's channel chn's samples starting at start-samp for samps from data (a vct, vector, or string (filename)); start-samp can be beyond current data end; if truncate is #t and start-samp is 0, the end of the file is set to match the new data's end.";
var extsnd_shortfilename_tip = "(short-file-name :optional snd): short form of snd's file name (no directory)";
var extsnd_showcontrols_tip = "(show-controls :optional snd): #t if snd's control panel is known to be open";
var extsnd_showindices_tip = "(show-indices): #t if sound name should be preceded by its index in the sound display.";
var extsnd_showlistener_tip = "(show-listener :optional (open #t)): if 'open' opens the lisp listener; returns whether the listener is visible.";
var extsnd_showtransformpeaks_tip = "(show-transform-peaks :optional snd chn): #t if fft display should include peak list";
var extsnd_smoothsound_tip = "(smooth-sound :optional (start-samp 0) (samps len) snd chn): smooth data from start-samp for samps in snd's channel chn";
var extsnd_sndhelp_tip = "(snd-help :optional (arg 'snd-help) (formatted #t)): return the documentation associated with its argument. (snd-help 'make-vct) for example, prints out a brief description of make-vct. The argument can be a string, symbol, or in some cases, the object itself. In the help descriptions, optional arguments are in parens with the default value (if any) as the 2nd entry. A ':' as the start of the argument name marks a CLM-style optional keyword argument.  If you load index.scm the functions html and ? can be used in place of help to go to the HTML description, and the location of the associated C code will be displayed, if it can be found. If help-hook is not empty, it is invoked with the subject and the snd-help result and its value is returned.";
var extsnd_sndprint_tip = "(snd-print str): display str in the listener window";
var extsnd_sndspectrum_tip = "(snd-spectrum data :optional (window rectangular-window) (len data-len) (linear #t) (beta 0.0) in-place (normalized #t)): magnitude spectrum of data (a vct), in data if in-place, using fft-window win and fft length len.";
var extsnd_sndtempnam_tip = "(snd-tempnam): return a new temp file name using temp-dir.";
var extsnd_sounddata_tip = "no help";
var extsnd_sounddatalength_tip = "(sound-data-length sd): length (in samples) of each channel of sound-data sd";
var extsnd_sounddataref_tip = "(sound-data-ref sd chan i): sample in channel chan at location i of sound-data sd: sd[chan][i]";
var extsnd_sounddataset_tip = "(sound-data-set! sd chan i val): set sound-data sd's i-th element in channel chan to val: sd[chan][i] = val";
var extsnd_soundfilep_tip = "(sound-file? name): #t if name has a known sound file extension";
var extsnd_soundfilesindirectory_tip = "(sound-files-in-directory :optional (directory \".\")): return a list of the sound files in 'directory'";
var extsnd_soundp_tip = "(sound? :optional (index 0)): #t if sound associated with 'index' is active (accessible)";
var extsnd_sounds_tip = "(sounds): list of active sounds (a list of indices)";
var extsnd_speedcontrol_tip = "(speed-control :optional snd): current speed (srate) slider setting";
var extsnd_squelchupdate_tip = "(squelch-update :optional snd chn): #t if updates (redisplays) are turned off in snd's channel chn";
var extsnd_srate_tip = "(srate :optional snd): snd's srate";
var extsnd_srcchannel_tip = "(src-channel ratio-or-env :optional (beg 0) (dur len) snd chn edpos): sampling-rate convert snd's channel chn by ratio, or following an envelope (a list or a CLM env generator).";
var extsnd_srcsound_tip = "(src-sound ratio-or-env :optional (base 1.0) snd chn edpos): sampling-rate convert snd's channel chn by ratio, or following an envelope. A negative ratio reverses the sound";
var extsnd_startplayinghook_tip = "start-playing-hook (snd): called when a play request is triggered. If it returns #t, the sound is not played.";
var extsnd_startplayingselectionhook_tip = "start-playing-selection-hook (): called when the selection starts playing";
var extsnd_stopdachook_tip = "stop-dac-hook (): called upon mus_audio_close (when DAC is turned off)";
var extsnd_stopplaying_tip = "(stop-playing :optional snd): stop play (DAC output) in progress";
var extsnd_stopplayinghook_tip = "stop-playing-hook (snd): called when a sound finishes playing.";
var extsnd_stopplayingselectionhook_tip = "stop-playing-selection-hook (): called when the selection stops playing";
var extsnd_sync_tip = "(sync :optional snd): snd's sync value (0 = no sync).  Some editing operations are applied to all sounds sharing the sync value of the selected sound.";
var extsnd_tempdir_tip = "(temp-dir): name of directory for temp files (or #f=null)";
var extsnd_timegraphtype_tip = "(time-graph-type :optional snd chn): graph-as-wavogram if Snd's time domain display is a 'wavogram',otherwise graph-once.";
var extsnd_tinyfont_tip = "(tiny-font): font use for some info in the graphs";
var extsnd_transformgraphp_tip = "(transform-graph? :optional snd chn): #t if fft display is active in snd's channel chn";
var extsnd_transformgraphtype_tip = "(transform-graph-type :optional snd chn) can be graph-once, graph-as-sonogram, or graph-as-spectrogram.";
var extsnd_transformsize_tip = "(transform-size :optional snd chn): current fft size (512)";
var extsnd_transformtovct_tip = "(transform->vct :optional snd chn obj): return a vct (obj if it's passed), with the current transform data from snd's channel chn";
var extsnd_undo_tip = "(undo :optional (count 1) snd chn): undo 'count' edits in snd's channel chn";
var extsnd_updatesound_tip = "(update-sound :optional snd): update snd (re-read it from the disk after flushing pending edits)";
var extsnd_updatetimegraph_tip = "(update-time-graph :optional snd chn): redraw snd channel chn's graphs";
var extsnd_updatetransformgraph_tip = "(update-transform-graph :optional snd chn): redraw snd channel chn's fft display";
var extsnd_vct_tip = "(vct args...): returns a new vct with args as contents; same as list->vct: (vct 1 2 3)";
var extsnd_vctadd_tip = "(vct-add! v1 v2 :optional (offset 0)): element-wise add of vcts v1 and v2: v1[i + offset] += v2[i], returns v1";
var extsnd_vctcopy_tip = "(vct-copy v): returns a copy of vct v";
var extsnd_vctfill_tip = "(vct-fill! v val): set each element of v to val: v[i] = val, returns v";
var extsnd_vctlength_tip = "(vct-length v): length of vct v";
var extsnd_vctmap_tip = "(vct-map! v proc): set each element of v to value of proc (a thunk): v[i] = (proc), returns v. (vct-map! v (lambda () 3.0)) is the same as (vct-fill! v 3.0)";
var extsnd_vctmove_tip = "(vct-move! obj new old :optional backwards): moves vct obj data from old to new: v[new++] = v[old++], or v[new--] = v[old--] if backwards is #f.";
var extsnd_vctmultiply_tip = "(vct-multiply! v1 v2): element-wise multiply of vcts v1 and v2: v1[i] *= v2[i], returns v1";
var extsnd_vctoffset_tip = "(vct-offset! v val): add val to each element of v: v[i] += val, returns v";
var extsnd_vctp_tip = "(vct? obj): is obj a vct";
var extsnd_vctpeak_tip = "(vct-peak v): max of abs of elements of v";
var extsnd_vctref_tip = "(vct-ref v n): element n of vct v, v[n]";
var extsnd_vctreverse_tip = "(vct-reverse! vct len): in-place reversal of vct contents";
var extsnd_vctscale_tip = "(vct-scale! v val): scale each element of v by val: v[i] *= val, returns v";
var extsnd_vctset_tip = "(vct-set! v n val): sets element of vct v to val, v[n] = val";
var extsnd_vctsubseq_tip = "(vct-subseq v start :optional end len vnew): v[start..end], placed in vnew if given or new vct";
var extsnd_vcttochannel_tip = "(vct->channel vct :optional (beg 0) (dur len) snd chn edpos origin): set snd's channel chn's samples starting at beg for dur samps from vct data";
var extsnd_vcttosounddata_tip = "(vct->sound-data v sd chan): copies vct v's data into sound-data sd's channel chan";
var extsnd_widgetposition_tip = "(widget-position wid): widget's position, (list x y), in pixels";
var extsnd_widgetsize_tip = "(widget-size wid): widget's size, (list width height), in pixels";
var extsnd_windowheight_tip = "(window-height): current Snd window height in pixels";
var extsnd_windowproperty_tip = "(window-property win-name name): get or set the window property.";
var extsnd_windowwidth_tip = "(window-width): current Snd window width in pixels";
var extsnd_withmixtags_tip = "(with-mix-tags): #t if Snd should try to use virtual (tagged) mixing";
var extsnd_withtrackingcursor_tip = "(with-tracking-cursor :optional snd): #t if cursor moves along in waveform display as sound is played";
var extsnd_xaxislabel_tip = "(x-axis-label :optional snd chn (ax time-graph)): current x axis label";
var extsnd_xaxisstyle_tip = "(x-axis-style :optional snd chn) The x axis labelling of the time domain waveform can be in seconds (x-axis-in-seconds), in samples (x-axis-in-samples), expressed as a percentage of the overall duration (x-axis-as-percentage), as a beat number (x-axis-in-beats, as a measure number (x-axis-in-measures, or clock-style (dd:hh:mm:ss) (x-axis-as-clock).";
var extsnd_xbounds_tip = "(x-bounds :optional snd chn): a list (x0 x1) giving the current x axis bounds of snd channel chn";
var extsnd_xtoposition_tip = "(x->position val :optional snd chn (ax time-graph)): x pixel loc of val";
var extsnd_xzoomslider_tip = "(x-zoom-slider :optional snd chn): current x axis zoom slider of snd channel chn";
var extsnd_ybounds_tip = "(y-bounds :optional snd chn): a list (y0 y1) giving the current y axis bounds of snd channel chn";
var extsnd_ytoposition_tip = "(y->position val :optional snd chn (ax time-graph)): y pixel loc of val";
var extsnd_yzoomslider_tip = "(y-zoom-slider :optional snd chn): current y axis zoom slider of snd channel chn";
var sndclm_amplitude_modulate_tip = "(amplitude-modulate carrier in1 in2): in1 * (carrier + in2)";
var sndclm_array_interp_tip = "(array-interp v phase :optional size): v[phase] taking into account wrap-around (size is size of data), with linear interpolation if phase is not an integer.";
var sndclm_comb_tip = "(comb gen :optional (val 0.0) (pm 0.0)): comb filter val, pm changes the delay length.";
var sndclm_continue_sampletofile_tip = "(continue-sample->file filename): return an output generator that reopens an existing sound file 'filename' ready for output via sample->file";
var sndclm_contrast_enhancement_tip = "(contrast-enhancement sig (index 1.0)): sin(sig * pi / 2 + index * sin(sig * 2 * pi))";
var sndclm_convolve_tip = "(convolve gen :optional input-func): next sample from convolution generator";
var sndclm_delay_tip = "(delay gen :optional (val 0.0) (pm 0.0)): delay val according to the delay line's length and pm ('phase-modulation'). If pm is greater than 0.0, the max-size argument used to create gen should have accommodated its maximum value. (The Scheme function delay is available as %delay)";
var sndclm_dot_product_tip = "(dot-product v1 v2 :optional size): sum of (vcts) v1[i] * v2[i] (also named scalar product)";
var sndclm_env_tip = "(env gen): next sample from envelope generator";
var sndclm_fft_tip = "no help";
var sndclm_filetoarray_tip = "(file->array filename chan start samples data): read the sound file 'filename' placing samples from channel 'chan' into the vct 'data' starting in the file at frame 'start' and reading 'samples' samples altogether.";
var sndclm_filetosample_tip = "(file->sample obj frame chan): sample value in sound file read by 'obj' in channel chan at frame";
var sndclm_filter_tip = "(filter gen :optional (input 0.0)): next sample from filter";
var sndclm_fir_filter_tip = "(fir-filter gen :optional (input 0.0)): next sample from FIR filter";
var sndclm_formant_tip = "(formant gen :optional (input 0.0) freq-in-radians): next sample from resonator generator";
var sndclm_frame_ref_tip = "(frame-ref f chan): f[chan] (the chan-th sample in frame f";
var sndclm_frame_set_tip = "no help";
var sndclm_frame_times_tip = "(frame* f1 f2 :optional outf): multiply f1 and f2 (elementwise) returning outf; if outf is not given, a new frame is created. outf[i] = f1[i] * f2[i].";
var sndclm_granulate_tip = "(granulate gen :optional input-func edit-func): next sample from granular synthesis generator";
var sndclm_hztoradians_tip = "(hz->radians hz): convert frequency in Hz to radians per sample: hz * 2 * pi / srate";
var sndclm_in_any_tip = "(in-any frame chan stream): input stream sample at frame in channel chan";
var sndclm_ina_tip = "(ina frame stream): input stream sample in channel 0 at frame";
var sndclm_locsig_set_tip = "(locsig-set! gen chan val): set the locsig generator's channel 'chan' scaler to 'val'";
var sndclm_locsig_tip = "(locsig gen loc val): add 'val' to the output of locsig at frame 'loc'";
var sndclm_make_env_tip = "(make-env :envelope (:scaler 1.0) :duration (:offset 0.0) (:base 1.0) :end :length): return a new envelope generator.  'envelope' is a list or vct of break-point pairs. To create the envelope, these points are offset by 'offset', scaled by 'scaler', and mapped over the time interval defined by either 'duration' (seconds) or 'length' (samples).  If 'base' is 1.0, the connecting segments are linear, if 0.0 you get a step function, and anything else produces an exponential connecting segment.";
var sndclm_make_pulse_train_tip = "(make-pulse-train (:frequency *clm-default-frequency*) (:amplitude 1.0) (:initial-phase 0.0)): return a new pulse-train generator.  This produces a sequence of impulses.";
var sndclm_make_comb_tip = "(make-comb :scaler :size :initial-contents (:initial-element 0.0) :max-size (:type mus-interp-linear)): return a new comb filter (a delay line with a scaler on the feedback) of size elements. If the comb length will be changing at run-time, max-size sets its maximum length. initial-contents can be either a list or a vct.";
var sndclm_make_convolve_tip = "(make-convolve :input :filter :fft-size): return a new convolution generator which convolves its input with the impulse response 'filter'.";
var sndclm_make_delay_tip = "(make-delay :size :initial-contents (:initial-element 0.0) (:max-size) (:type mus-interp-linear)): return a new delay line of size elements. If the delay length will be changing at run-time, max-size sets its maximum length, so  (make-delay len :max-size (+ len 10)) provides 10 extra elements of delay for subsequent phasing or flanging. initial-contents can be either a list or a vct.";
var sndclm_make_env_tip = "(make-env :envelope (:scaler 1.0) :duration (:offset 0.0) (:base 1.0) :end :length): return a new envelope generator.  'envelope' is a list or vct of break-point pairs. To create the envelope, these points are offset by 'offset', scaled by 'scaler', and mapped over the time interval defined by either 'duration' (seconds) or 'length' (samples).  If 'base' is 1.0, the connecting segments are linear, if 0.0 you get a step function, and anything else produces an exponential connecting segment.";
var sndclm_make_filetosample_tip = "(make-file->sample filename :optional buffer-size): return an input generator reading 'filename' (a sound file)";
var sndclm_make_filter_tip = "(make-filter :order :xcoeffs :ycoeffs): return a new direct form FIR/IIR filter, coeff args are vcts";
var sndclm_make_fir_filter_tip = "(make-fir-filter :order :xcoeffs): return a new FIR filter, xcoeffs a vct";
var sndclm_make_formant_tip = "(make-formant :frequency :radius): return a new formant generator (a resonator).  radius sets the pole radius (in terms of the 'unit circle'). frequency sets the resonance center frequency (Hz).";
var sndclm_make_frame_tip = "(make-frame chans val0 val1 ...): return a new frame object with chans samples, each sample set from the trailing arguments (defaulting to 0.0): (make-frame 2 .1 .2)";
var sndclm_make_granulate_tip = "(make-granulate :input (:expansion 1.0) (:length .15) (:scaler .6) (:hop .05) (:ramp .4) (:jitter 1.0) :max-size :edit): return a new granular synthesis generator.  'length' is the grain length (seconds), 'expansion' is the ratio in timing between the new and old (expansion > 1.0 slows things down), 'scaler' scales the grains to avoid overflows, 'hop' is the spacing (seconds) between successive grains upon output jitter controls the randomness in that spacing, input can be a file pointer. 'edit' can be a function of one arg, the current granulate generator.  It is called just before a grain is added into the output buffer. The current grain is accessible via mus-data. The edit function, if any, should return the length in samples of the grain, or 0.";
var sndclm_make_locsig_tip = "(make-locsig (:degree 0.0) (:distance 1.0) (:reverb 0.0) (:output *output*) (:revout *reverb*) (:channels (mus-channels *output*)) (:type mus-interp-linear)): return a new generator for signal placement in n channels.  Channel 0 corresponds to 0 degrees.";
var sndclm_make_moving_average_tip = "(make-moving-average :size :initial-contents (:initial-element 0.0)): return a new moving_average generator. initial-contents can be either a list or a vct.";
var sndclm_make_ncos_tip = "(make-ncos (:frequency *clm-default-frequency*) (:n 1)): return a new ncos generator, producing a sum of 'n' equal amplitude cosines.";
var sndclm_make_one_pole_tip = "(make-one-pole :a0 :b1): return a new one-pole filter; a0*x(n) - b1*y(n-1)";
var sndclm_make_one_zero_tip = "(make-one-zero :a0 :a1): return a new one-zero filter;  a0*x(n) + a1*x(n-1)";
var sndclm_make_oscil_tip = "(make-oscil (:frequency *clm-default-frequency*) (:initial-phase 0.0)): return a new oscil (sinewave) generator";
var sndclm_make_phase_vocoder_tip = "(make-phase-vocoder :input :fft-size :overlap :interp :pitch :analyze :edit :synthesize): return a new phase-vocoder generator; input is the input function (it can be set at run-time), analyze, edit, and synthesize are either #f or functions that replace the default innards of the generator, fft-size, overlap and interp set the fftsize, the amount of overlap between ffts, and the time between new analysis calls. 'analyze', if given, takes 2 args, the generator and the input function; if it returns #t, the default analysis code is also called.  'edit', if given, takes 1 arg, the generator; if it returns #t, the default edit code is run.  'synthesize' is a function of 1 arg, the generator; it is called to get the current vocoder output.";
var sndclm_make_polyshape_tip = "(make-polyshape (:frequency *clm-default-frequency*) (:initial-phase 0.0) :coeffs (:partials '(1 1)) (:kind mus-chebyshev-first-kind)): return a new polynomial-based waveshaping generator:   (make-polyshape :coeffs (partials->polynomial '(1 1.0))) is the same in effect as make-oscil";
var sndclm_make_rand_interp_tip = "(make-rand-interp (:frequency *clm-default-frequency*) (:amplitude 1.0) :envelope :distribution :size): return a new rand-interp generator, producing linearly interpolated random numbers. frequency is the rate at which new end-points are chosen.";
var sndclm_make_rand_tip = "(make-rand (:frequency *clm-default-frequency*) (:amplitude 1.0) :envelope :distribution :size): return a new rand generator, producing a sequence of random numbers (a step  function). frequency is the rate at which new numbers are chosen.";
var sndclm_make_readin_tip = "(make-readin :file (:channel 0) (:start 0) (:direction 1) :size): return a new readin (file input) generator reading the sound file 'file' starting at frame 'start' in channel 'channel' and reading forward if 'direction' is not -1";
var sndclm_make_sampletofile_tip = "(make-sample->file filename :optional chans data-format header-type comment): return an output generator writing the sound file 'filename' which is set up to have 'chans' channels of 'data-format' samples with a header of 'header-type'.  The latter should be sndlib identifiers:  (make-sample->file \"test.snd\" 2 mus-lshort mus-riff)";
var sndclm_make_src_tip = "(make-src :input (:srate 1.0) (:width 10)): return a new sampling-rate conversion generator (using 'warped sinc interpolation'). 'srate' is the ratio between the new rate and the old. 'width' is the sine width (effectively the steepness of the low-pass filter), normally between 10 and 100. 'input' if given is an open file stream.";
var sndclm_make_sum_of_cosines_tip = "(make-sum-of-cosines (:cosines 1) (:frequency *clm-default-frequency*) (:initial-phase 0.0)): return a new sum-of-cosines generator, producing a band-limited pulse train.";
var sndclm_make_triangle_wave_tip = "(make-triangle-wave (:frequency *clm-default-frequency*) (:amplitude 1.0) (:initial-phase 0.0)): return a new triangle-wave generator.";
var sndclm_make_two_zero_tip = "(make-two-zero :a0 :a1 :a2 or :frequency :radius): return a new two-zero filter; a0*x(n) + a1*x(n-1) + a2*x(n-2)";
var sndclm_moving_average_tip = "(moving-average gen :optional (val 0.0)): moving window moving_average.";
var sndclm_mus_channels_tip = "(mus-channels gen): gen's mus-channels field, if any";
var sndclm_mus_close_tip = "(mus-close gen): close the IO stream managed by 'gen' (a sample->file generator, for example)";
var sndclm_mus_data_tip = "(mus-data gen): gen's internal data (a vct), if any";
var sndclm_mus_frequency_tip = "(mus-frequency gen): gen's frequency (Hz)";
var sndclm_mus_increment_tip = "(mus-increment gen): gen's mus-increment field, if any";
var sndclm_mus_length_tip = "(mus-length gen): gen's length, if any";
var sndclm_mus_offset_tip = "(mus-offset gen): gen's offset, if any";
var sndclm_mus_random_tip = "(mus-random val): a random number between -val and val. the built-in 'random' function returns values between 0 and its argument";
var sndclm_mus_scaler_tip = "(mus-scaler gen): gen's scaler, if any.  This is often an amplitude adjustment of some sort.";
var sndclm_mussrate_tip = "(mus-srate): current sampling rate";
var sndclm_ncos_tip = "(ncos gen :optional (fm 0.0)): get the next sample from 'gen', an ncos generator";
var sndclm_one_pole_tip = "(one-pole gen :optional (input 0.0)): one pole filter of input";
var sndclm_optional_key_tip = "no help";
var sndclm_oscil_tip = "(oscil gen :optional (fm 0.0) (pm 0.0)): next sample from oscil gen: val = sin(phase + pm); phase += (freq + fm)";
var sndclm_out_any_tip = "(out-any frame val chan stream): add val to output stream at frame in channel chan";
var sndclm_outa_tip = "(outa frame val stream): add val to output stream at frame in channel 0";
var sndclm_partialstopolynomial_tip = "(partials->polynomial partials :optional (kind mus-chebyshev-first-kind)): produce a Chebyshev polynomial suitable for use with the polynomial generator to create (via waveshaping) the harmonic spectrum described by the partials argument: <pre>  (let ((v0 (partials->polynomial '(1 1.0 2 1.0)))<br>        (os (make-oscil)))<br>    (polynomial v0 (oscil os)))</pre>";
var sndclm_phase_vocoder_tip = "(phase-vocoder gen input-function analyze-func edit-func synthesize-func): next phase vocoder value";
var sndclm_polynomial_tip = "(polynomial coeffs x): evaluate a polynomial at x.  coeffs are in order of degree, so coeff[0] is the constant term.";
var sndclm_polyshape_tip = "(polyshape gen :optional (index 1.0) (fm 0.0)): next sample of polynomial-based waveshaper";
var sndclm_pulse_train_tip = "(pulse-train gen :optional (fm 0.0)): next pulse train sample from generator";
var sndclm_rand_interp_tip = "(rand-interp gen :optional (fm 0.0)): gen's current (interpolating) random number. fm modulates the rate at which new segment end-points are chosen.";
var sndclm_rand_tip = "(rand gen :optional (fm 0.0)): gen's current random number. fm modulates the rate at which the current number is changed.";
var sndclm_readin_tip = "(readin gen): next sample from readin generator (a sound file reader)";
var sndclm_secondstosamples_tip = "(seconds->samples secs): use mus-srate to convert seconds to samples";
var sndclm_src_tip = "(src gen :optional (pm 0.0) input-function): next sampling rate conversion sample. 'pm' can be used to change the sampling rate on a sample-by-sample basis.  'input-function' is a function of one argument (the current input direction, normally ignored) that is called internally whenever a new sample of input data is needed.  If the associated make-src included an 'input' argument, input-function is ignored.";
var sndclm_tap_tip = "(tap gen :optional (pm 0.0)): tap the delay generator offset by pm";
var sndclm_timestosamples_tip = "no help";
var sndclm_triangle_wave_tip = "(triangle-wave gen :optional (fm 0.0)): next triangle wave sample from generator";

